<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>How-to C++</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">How-to C++</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="about"><a class="header" href="#about">About</a></h1>
<p>This website contains some helpful c++ tips, examples or explanations which are collected for years .They may be unique or common but I'm sure they will help you with learning more about c++...</p>
<blockquote>
<p>Some of the examples are from AI (copilot, claude) , cppreference, high performance c++ book so you can check these websites or github links for more details.</p>
</blockquote>
<p>if you -</p>
<ul>
<li>have any questions</li>
<li>want to correct my mistakes (I would be glad by learning it btw. because some of the notes are old and copied here without testing - if they fail; inform me)</li>
<li>want to advice something</li>
<li>...</li>
</ul>
<p>send me an email please.</p>
<p>Also whenever I find something interesting I will push it here.</p>
<p><strong>Hakan Gedek</strong>
<a href="mailto:hgedek@pm.me">hgedek@pm.me</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="start-learning-in-swe"><a class="header" href="#start-learning-in-swe">start learning in swe</a></h1>
<p>learning: WWH!</p>
<ul>
<li>what: find the target (topic, problem, feature...) and learn it's simple definition - no need too much details at first.</li>
<li>why or when: find the use cases (reasons ) why it's created or it's sole reason of existence.</li>
<li>how: find or create samples...own examples teach better. it's time to delve into depths / details now.</li>
</ul>
<p>debugging:</p>
<ul>
<li>what: definition of the problem. don't start debugging without understanding the problem</li>
<li>how: direct or indirect solutions. sometimes you debug existing problem but sometimes you need to create dummy coding just to open path to the problem.</li>
</ul>
<blockquote>
<p>when developing own solutions debugging may not be an issue because you have clear picture of the project but like working on a legacy project, taking ownership of an existing problem... are different. you may find yourself in an blurred situation in which you need to clear... then debugging the problem may become key to understand it... ask what and how to it.</p>
</blockquote>
<h2 id="some-c-advices"><a class="header" href="#some-c-advices">some c++ advices</a></h2>
<ul>
<li>you don't need to put all declarations in .h files. .h is only exist to <strong>share</strong> logic between translation units (cpps - modules) or libs. anything special / specific for a TU doesn't need to be put in .h files.</li>
<li>you don't need to impl / wrap everything with class or structs, you can use namespace { functions too } like c - functional programming.</li>
<li>never use MACROs for defining true constants. use constexpr, constinit. if necessary; wrap them with a class or struct and use static constexpr but never use MACRO</li>
<li>if your type is a compound data type then define your new data type with struct not class. use struct for datas, integral constants, type_traits etc.</li>
<li>how to place member fields in class ?
<ul>
<li>think about bits: you can shrink your data types using bit fields</li>
<li>think about byte sizes - don't randomly pick your types</li>
<li>ordering the fields : largest to smallest (in size)...it's all about padding and alignment</li>
</ul>
</li>
<li>classes are there to define objects which may simulate reality or imaginary but they need these:
<ul>
<li>some state data (fields, variables)</li>
<li>some behaviors (functions)
<ul>
<li>if you don't have any; then you don't need a class</li>
</ul>
</li>
</ul>
</li>
<li>never put unrelated fields or behaviors into a class
<ul>
<li>class is a united existence. putting unrelated stuff into it will convert it a trash bin at the end. having 3rd eye or having 3 legs or arms are not applicable for humans so don't design stupid things</li>
</ul>
</li>
<li>always use namespaces
<ul>
<li>a program has always at least one namespace - it's own name</li>
<li>or a library : it's own name
<ul>
<li>if you're coding correctly and hiding specific things in .cpp modules then ::impl - check pimpl idiom or nvi(non-virtual interface) idiom</li>
</ul>
</li>
</ul>
</li>
<li>start with unit testing</li>
<li>if your classes have some logic / algorithm / business operation / state machines... i mean that if they are not just a wrapper of data then you have to test them. create a test lib and always test your code.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design-code-via-ownership"><a class="header" href="#design-code-via-ownership">design code via ownership</a></h1>
<p>one of the core rules of coding is deciding the ownership of the data / memory. almost everything is shaped around it and with a bad design; your project will fall very badly.</p>
<p>options:</p>
<ul>
<li>
<p>sole owner</p>
</li>
<li>
<p>shared ownership</p>
</li>
<li>
<p>borrower</p>
</li>
</ul>
<h2 id="sole-owner"><a class="header" href="#sole-owner">sole owner</a></h2>
<p>std::unique_ptr: not copyable, movable...only one owner can exist.</p>
<p>singleton pattern: it simulates sole ownership of the data... return types of the resource must be <code>const T&amp;</code> and mutable ops should be supported via methods. be careful with heap resources.</p>
<pre><code class="language-c++">
std::unique_ptr&lt;int&gt; soleOwner = std::make_unique&lt;int&gt;(10);
// std::unique_ptr&lt;int&gt; anotherOwner = soleOwner; // Error: cannot copy
std::unique_ptr&lt;int&gt; anotherOwner = std::move(soleOwner); // Correct: move ownership

</code></pre>
<h2 id="shared"><a class="header" href="#shared">shared</a></h2>
<p>std::shared_ptr, raw pointers, std::weak_ptr</p>
<p>std::shared_ptr: counting based owner. if the last owner destroyed; resource will be released.</p>
<p>raw-pointers: no control, open to memory leaks, open to UB, needs almost max concentration</p>
<pre><code class="language-c++">
std::shared_ptr&lt;int&gt; sharedOwner1 = std::make_shared&lt;int&gt;(10);
std::shared_ptr&lt;int&gt; sharedOwner2 = sharedOwner1; // Shared ownership

or

int* ptr1 = new int(1);
int* ptr2 = ptr1;
int* ptr3 = ptr2;
...

delete ptr1;

std::cout &lt;&lt; *ptr2 &lt;&lt; std::endl;  =&gt; UB

</code></pre>
<h2 id="borrowers"><a class="header" href="#borrowers">borrowers</a></h2>
<p>std::weak_ptr: generally called as used to break cycling reference but it's not only use case. it can support shared ownership but only one of them is the master. if it's destroyed then we lose the resource too. beneficiaries, users, slaves... this doesn't control the resource but only uses - if it's available via the owner.</p>
<p>references: c++'s core feature is &amp; - you cannot find it in c. &amp; is signature of the borrowing. in rust &amp; needs lifetime checkers which c++ needs it too. &amp; means - resource exists and I can be alive as long as data exists.</p>
<pre><code class="language-c++">std::shared_ptr&lt;int&gt; sharedOwner = std::make_shared&lt;int&gt;(10);
std::weak_ptr&lt;int&gt; borrower = sharedOwner; // Non-owning reference

if (auto locked = borrower.lock()) {
    // Use the resource
    std::cout &lt;&lt; *locked &lt;&lt; std::endl;
} else {
    // Resource no longer exists
}

int data = 1;
int&amp; borrower = data;
const int&amp; immutable_borrower = data;

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-decorator-with-lambda"><a class="header" href="#create-decorator-with-lambda">create decorator with lambda</a></h1>
<p>key feature of a lambda is capturing around. using this feature; we can create a creator / decorator easily.</p>
<p>let create a printer...</p>
<pre><code class="language-c++">
void print(auto arg) { std::cout &lt;&lt; arg &lt;&lt; ' '; }
void print(auto arg, auto... args) {
    print(arg);
    print(args...);
}


// decorating inner creator with outer params
auto create_printer(auto...args) { // args: shared by inner creator
    return [=](auto arg) {
        print(args...); // 
        print(arg);

        std::cout &lt;&lt; '\n';
    };
}

// 3 layered decorator... we can share first and second layers between inner typed objects
auto create_more_printer(auto ...args) {
    return [=](auto arg0) {
        return [=](auto arg1) {
            print(args...);
            print(arg0);
            print(arg1);

            std::cout &lt;&lt; '\n';
        };
    };
}

int main() {
    // first layer is fixed and captured by inner of decorator
    auto printer = create_printer(1,2,3);

    // we can use them with different args now
    printer("hakan"); 
    printer("gedek");
}

</code></pre>
<blockquote>
<p>when capturing I used by-value (=) because the captured args lifetimes maybe shorter than decorated instance. If by-ref(&amp;) was used then it would create an UB (undefined behaviour) so when capturing with lambda be careful with lifetimes of the args.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-tuple-in-different-ways"><a class="header" href="#create-tuple-in-different-ways">create tuple in different ways</a></h1>
<p>std::tuple is an amazing type which allows us to create unnamed structs. It's best to use as param or return type from functions when we need an anonymous compound type - supports templates which is best</p>
<h2 id="using-constructors"><a class="header" href="#using-constructors">using constructors</a></h2>
<pre><code class="language-c++">
// variable
std::tuple t{1,"hakan", 'x', 3.4f};

// on the place creation of anonymous compound type: tuple - not named !
auto create_tpl() -&gt; std::tuple&lt;int, float, char const *&gt; {
    int i = 0;
    float f = 0.3f;
    const char *c = "hakan gedek";

    return {i, f, c};
}

// template integration
template &lt;class ...Ts&gt;
auto create_tpl(Ts...args) -&gt; std::tuple&lt;Ts...&gt;{
    return {args...};
}

int main() {
    auto t1 = create_tpl();
    auto t2 = create_tpl(1,1.1f, "hakan");
}

</code></pre>
<h2 id="using-make_tuple"><a class="header" href="#using-make_tuple">using make_tuple</a></h2>
<p>std::make_tuple <code>creates copy</code> of the params and constructs the tuple. using std::ref and std::cref; we can store ref too. (std::reference_wrapper)...don't use &amp; in the tuple definition.</p>
<pre><code class="language-c++">
int main()
{
    {
        auto t = std::make_tuple(0, "hakan");

        std::cout &lt;&lt; std::get&lt;0&gt;(t) &lt;&lt; ":" &lt;&lt; std::get&lt;1&gt;(t) &lt;&lt; std::endl;
    }

    {
        int n = 0;
        auto t = std::make_tuple(0, "hakan", std::ref(n));
        auto&amp; m = std::get&lt;2&gt;(t);

        m = 1;

        assert(n == 1);
    }
}

</code></pre>
<h2 id="using-forward_as_tuple"><a class="header" href="#using-forward_as_tuple">using forward_as_tuple</a></h2>
<p>std::forward_as_tuple <code>creates ref to originals</code> of the params so it's for passing params as ref. if you wish to create readonly variables keep const.</p>
<pre><code class="language-c++">void print(const std::tuple&lt;int&amp;, int&amp;, const char*&gt;&amp; t) {
    std::cout &lt;&lt; std::get&lt;0&gt;(t) &lt;&lt; ' ' &lt;&lt; std::get&lt;1&gt;(t) &lt;&lt; ' ' &lt;&lt; std::get&lt;2&gt;(t) &lt;&lt; std::endl;
}

// pass as T&amp; : mutable
void foo(std::tuple&lt;int &amp;, float &amp;&gt; const &amp;t)
{
    auto &amp;i = std::get&lt;0&gt;(t);
    auto &amp;f = std::get&lt;1&gt;(t);

    i = 10;
    f = 10.2f;
}

// pass as const T&amp;: immutable
void bar(std::tuple&lt;int const &amp;, float const &amp;&gt; const &amp;t)
{
    // even without using const; we will still get const in auto so assignments will not work
    const auto &amp;i = std::get&lt;0&gt;(t);
    const auto &amp;f = std::get&lt;1&gt;(t);

    // fails
    // i = 10;
    // f = 10.2f;
}

int main() {

    int x = 1;
    int y = 2;
    char const* name = "hakan";

    print(std::forward_as_tuple(x, y, name));

    int i = 0;
    float f = 0.0f;

    foo(std::forward_as_tuple(i, f));

    std::cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; f &lt;&lt; std::endl;
}
</code></pre>
<h2 id="using-stdtie"><a class="header" href="#using-stdtie">using std::tie</a></h2>
<p>can destruct but also can construct - valid for both solutions...it creates copy of the data.</p>
<pre><code class="language-c++">
struct Data
{
    int i;
    float f;
    std::string s;

    auto to_tuple() const -&gt; std::tuple&lt;int, float, std::string&gt;
    {
        return std::tie(this-&gt;i, this-&gt;f, this-&gt;s);
    }
};

int main()
{
    Data data{.i = 101, .f = 1.01f, .s = "hakan gedek"s};

    const auto tpl = data.to_tuple();

    std::cout &lt;&lt; std::get&lt;0&gt;(tpl) &lt;&lt; ":" &lt;&lt; std::get&lt;1&gt;(tpl) &lt;&lt; ":" &lt;&lt; std::get&lt;2&gt;(tpl) &lt;&lt; std::endl;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="capture-this-pointer-by-value"><a class="header" href="#capture-this-pointer-by-value">capture this pointer by value</a></h1>
<p>we can capture this as by-ref normally but when we need to create a copy from it ?</p>
<pre><code class="language-c++">
struct Type
{
    void by_ref() {
        auto f = [this]{
            std::cout &lt;&lt; m_Id &lt;&lt; std::endl; 
        };
        f();
    }

    void by_value() {
        auto f = [*this]{
            std::cout &lt;&lt; m_Id &lt;&lt; std::endl;
        };
        f();
    }

    void by_copy_value() {
        auto f = [thisCopy = *this] {
            std::cout &lt;&lt; thisCopy.m_Id &lt;&lt; std::endl;
        };
    }

    int m_Id;
};

int main() {
    Type t{101};
    t.by_ref();
    t.by_value();
    t.by_copy_value();
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="initialize-fields-with-functions"><a class="header" href="#initialize-fields-with-functions">initialize fields with functions</a></h1>
<p>struct/class/union has an order of initialization of fields in the order of they are defined.</p>
<ul>
<li>we can initialize them like any other variables</li>
<li>depending on decl of thme { static, constexpr } we can use better inits</li>
<li>we can pass them to next init functions</li>
</ul>
<pre><code class="language-c++">
auto getId() {
    static int counter = 101;
    return counter++;
}

auto getName(int id) { return std::format("Object: {}", id); }

auto getFullName(std::string const &amp;name, uintptr_t addr) {
    return std::format("{} {}", name, addr);
}

struct Object {
    int id = getId();
    std::string name = getName(id);
    std::string fullName = getFullName(name, reinterpret_cast&lt;uintptr_t&gt;(this));
};

void print(Object const &amp;obj) {
    std::cout &lt;&lt; std::format("Id: {} Name: {} FullName: {}", obj.id, obj.name,
                             obj.fullName)
              &lt;&lt; std::endl;
}

int main() 
{
    Object obs[] = {{}, {}, {}};
    print(obs[0]);
    print(obs[1]);
    print(obs[2]);
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="define-singleton-pattern-in-multiple-ways"><a class="header" href="#define-singleton-pattern-in-multiple-ways">define singleton pattern in multiple ways</a></h1>
<p>there are multiple ways to define singleton pattern in c++.</p>
<blockquote>
<p>local static variables are thread-safe.
if you need; you can wrap creation with <code>lock_guard&lt;mutex&gt;</code> or you can use atomics</p>
</blockquote>
<pre><code class="language-c++">// using static - standard
struct Manager {
  private:
    std::tuple&lt;int, float&gt; m_Data;

    template &lt;class... Ts&gt;
    constexpr Manager(Ts... args) : m_Data(std::forward&lt;Ts&gt;(args)...) {}

  public:
    template &lt;class... Ts&gt;
        requires std::same_as&lt;std::tuple&lt;Ts...&gt;, decltype(m_Data)&gt;
    static Manager instance(Ts... args) {
        static Manager inst{std::forward&lt;Ts&gt;(args)...};
        return inst;
    }
};

</code></pre>
<pre><code class="language-c++">// using shared_ptr
struct Manager {
    private:
    std::tuple&lt;int, float&gt; m_Data;

    template &lt;class...Ts&gt;
    constexpr Manager(Ts...args): m_Data(std::forward&lt;Ts&gt;(args)...){}

    public:

    template &lt;class...Ts&gt;
        requires std::same_as&lt;std::tuple&lt;Ts...&gt;, decltype(m_Data)&gt; 
    static std::shared_ptr&lt;Manager&gt; instance(Ts...args) {
        static std::shared_ptr&lt;Manager&gt; inst{std::forward&lt;Ts&gt;(args)...};
        return inst;
    }
};
</code></pre>
<pre><code class="language-c++">// using call-once 
class Manager;

class Deletor {
public:
    void operator()(Manager* inst);
};

class Manager {
    Manager() { std::cout &lt;&lt; "instance" &lt;&lt; std::endl; }
    Manager(Manager const&amp;) = delete;
    Manager(Manager&amp;&amp;) = delete;

    ~Manager() = default;
    
public:
    static Manager&amp; instance() {
        std::call_once(flag_, []{
            inst_ = std::unique_ptr&lt;Manager, Deletor&gt;(new Manager(), Deletor());
        });

        return *inst_;
    }

    inline static std::unique_ptr&lt;Manager, Deletor&gt;  inst_;
    inline static std::once_flag flag_;

    friend Deletor;
};


void Deletor::operator()(Manager* inst) {
    delete inst;
}

void foo() {
    [[maybe_unused]]
    auto&amp; inst = Manager::instance();
}

int main() {
    std::jthread{foo},
    std::jthread{foo},
    std::jthread{foo},
    std::jthread{foo},
    std::jthread{foo},
    std::jthread{foo};

    std::this_thread::sleep_for(2s);

    return 0;
}

</code></pre>
<blockquote>
<p>If you want you can use define your instance as atomic too.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="define-static-local-variables"><a class="header" href="#define-static-local-variables">define static local variables</a></h1>
<p>static is tightly coupled with scope paradigm. it defines something native to target scope.</p>
<h2 id="class-local"><a class="header" href="#class-local">class local</a></h2>
<p>scope: class/struct</p>
<p>it's shared by all class instance so it belongs to class</p>
<pre><code class="language-c++">class MyClass {
    static inline int counter = 0;
};
</code></pre>
<h2 id="function-local"><a class="header" href="#function-local">function local</a></h2>
<p>scope: function</p>
<p>it's shared by all function users so it belongs to function</p>
<pre><code class="language-c++">class MyClass {
    void foo() {
        static int counter = 0;
    }
};

// or
// foo.cpp

void foo() {
    static int counter = 0;
}

</code></pre>
<h2 id="module-local"><a class="header" href="#module-local">module local</a></h2>
<p>scope: module (translation unit)</p>
<p>it's shared by all module functions so it belongs to module - tu</p>
<p>foo.cpp</p>
<pre><code class="language-c++">
static int counter = 0;

void foo() {
    counter++;
}

void bar() {
    counter++;
}

</code></pre>
<blockquote>
<p>static has internal linkage so it's only visible in translation unit
other translation units cannot access internal linkage symbols</p>
</blockquote>
<blockquote>
<p>Global Variable (External Linkage)</p>
</blockquote>
<p>When you define a global variable (without static), it has external linkage and the following characteristics:</p>
<ul>
<li>Lifetime: The variable is created when the program starts and destroyed when the program ends.</li>
<li>Scope: It is accessible from any translation unit (i.e., any .cpp file) that declares it using the extern keyword.</li>
</ul>
<blockquote>
<p>Static Global Variable (Internal Linkage)</p>
</blockquote>
<p>When you define a global variable with the static keyword, it has internal linkage and the following characteristics:</p>
<ul>
<li>Lifetime: The variable is created when the program starts and destroyed when the program ends, just like a global variable.</li>
<li>Scope: It is only accessible within the translation unit where it is defined. Other translation units cannot access it.</li>
</ul>
<blockquote>
<p>there is not implicitly static state but all is implicitly external so if you want to hide something in tu, then use static with it</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-stdforward-to-assign-moved-fields"><a class="header" href="#use-stdforward-to-assign-moved-fields">use std::forward to assign moved fields</a></h1>
<p>move semantics is topic of another snippet but here we will talk about using forward instead of move when assigning source to target</p>
<p>voyage of the data:</p>
<ul>
<li>create a moved data ( T&amp;&amp; ) either creating a RValue or moving a LValue</li>
<li>transfer it through operations by std::forward</li>
<li>finish assignment with std::forward again instead std::move</li>
</ul>
<p>std::move creates T&amp;&amp; from T or T&amp;
std::forward keeps inner type of T so if it's T&amp;&amp; then it's T&amp;&amp; when assigned and field(T&amp;&amp;) will trigger move_constructor (mvtor)</p>
<pre><code class="language-c++">
struct Manager {
  private:
    std::tuple&lt;int, float&gt; m_Data;

    template &lt;class... Ts&gt;
    constexpr Manager(Ts... args)
        : m_Data(std::forward&lt;Ts&gt;(args)...) {} // assigned with forward

  public:
    template &lt;class... Ts&gt;
        requires std::same_as&lt;std::tuple&lt;Ts...&gt;, decltype(m_Data)&gt;
    static Manager create(Ts... args) {
        static Manager inst{
            std::forward&lt;Ts&gt;(args)...}; // pass it through here with forward
        return inst;
    }
};

int main() {
    // directly using T&amp;&amp;
    {
        auto manager = Manager::create(1, 1.2f);
    }

    // T =&gt; T&amp;&amp;
    {
        int x = 0;
        float y = .3f;

        auto manager = Manager::create(std::move(x), std::move(y));
    }
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-variadic-inheritance"><a class="header" href="#create-variadic-inheritance">create variadic inheritance</a></h1>
<p>use cases:</p>
<ul>
<li>impl decorator pattern</li>
<li>impl plugin pattern</li>
</ul>
<pre><code class="language-c++">
struct watchable{
    bool status = false;
};

struct listenable{
    bool status = false;
};

struct readable{
    bool status = false;
};

// whenever you're working with T&amp;&amp;; you should be carefull

// if you're passing tha param to somewhere else compiler will dispose &amp;&amp; and create a copy from it by default
// so always pass T&amp;&amp; with std::forward to store it's correct type and to access correct function

template &lt;class...Ts&gt;
struct Movie: Ts... {
    Movie(Ts&amp;&amp;...args): Ts(std::forward&lt;Ts&gt;(args))... {} // this will call =&gt; Ts(Ts&amp;&amp;)
    // Movie(Ts&amp;&amp;...args): Ts(args)... {} =&gt; this will call Ts(Ts const&amp;)
};

int main() {
    Movie&lt;watchable, listenable&gt; m1{
        watchable{.status = true },
        listenable{.status = false }
    };

    std::cout &lt;&lt; "watch: " &lt;&lt; m1.watchable::status &lt;&lt;
        " listen: " &lt;&lt; m1.listenable::status &lt;&lt; std::endl;
}

</code></pre>
<blockquote>
<p>also supports borrowing scheme via using declarations - check related page about using delegations.</p>
</blockquote>
<blockquote>
<p>useful to design mixins and policy based design which you can find details in their pages</p>
</blockquote>
<p>ad-hoc types</p>
<pre><code class="language-c++">
template &lt;class...Ts&gt;
class Target: Ts... {
public:
    using Ts::operator()...
};

template &lt;class...Ts&gt;
Target(Ts...) -&gt; Target&lt;Ts...&gt;;


struct Message {
    int id;
    std::string data;

    static std::string toString(Message const&amp; msg) {
        return std::format("Message: {} {}", msg.id, msg.data);
    }
};


int main() {
    auto target = Target{
        [](int var){ std::println("int : {}", var); },
        [](float var) { std::println("float: {}", var); },
        [](std::string_view sv) {std::println("sv: {}", sv);},
        [](Message const&amp; msg) { std::println("{}", Message::toString(msg)); }
    };

    auto i = 10;
    auto f = 1.2f;
    auto sv = "hakan gedek"sv;
    auto msg = Message { .id = 101, .data ="hakan gedek" };
    target(i);
    target(f);
    target(sv);
    target(msg);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-callables"><a class="header" href="#create-callables">create callables</a></h1>
<blockquote>
<p>callable: types which can be called like a function...</p>
</blockquote>
<h2 id="stdfunction"><a class="header" href="#stdfunction">std::function</a></h2>
<p>this can wrap any callable and can be stored in a vector. it's usa case is wide.</p>
<ul>
<li>wraps callables</li>
<li>can be used as a callable</li>
<li>can be used in containers</li>
<li>usable with std::invoke or std::apply</li>
</ul>
<pre><code class="language-c++">
template &lt;class Fn&gt;
void foo(Fn&amp;&amp; fn) {
    std::invoke(fn);
}

template &lt;class Fn&gt;
void bar(std::function&lt;Fn&gt; const&amp; fn) {
    std::invoke(fn);
}

void my_foo() { std::cout &lt;&lt; "my_foo" &lt;&lt; std::endl; }

struct functor {
    void operator()() { std::cout &lt;&lt; "functor" &lt;&lt; std::endl; }
};

using fn_t = std::function&lt;void()&gt;;

using fn_ptr_t = void (*)();

int main() {
    std::vector&lt;fn_t&gt; fns{functor{}, my_foo};
    for (auto&amp;&amp; fn : fns) std::invoke(fn);

    fn_t foo_ins = my_foo;
    fn_t func_ins = functor{};

    foo(foo_ins);
    bar(func_ins);

    fn_ptr_t f_ptr = my_foo;
    foo(f_ptr);

    return 0;
}

</code></pre>
<h2 id="functor"><a class="header" href="#functor">functor</a></h2>
<p>function objects - a class/struct type which implemented <code>operator()</code> function. there are many pre-defined functors in std lib like greater,less,negate,plus, not_fn,...they are useful for clean coding.</p>
<ul>
<li>class/struct type</li>
<li>can be used in containers</li>
<li>can be used with invoke/apply</li>
<li><code>operator()</code> can be overloaded</li>
</ul>
<pre><code class="language-c++">
class MyClass {
   public:
    void operator()() { std::cout &lt;&lt; "void" &lt;&lt; std::endl; }
    void operator()(int) { std::cout &lt;&lt; "one arg" &lt;&lt; std::endl; }
    void operator()(int, int) { std::cout &lt;&lt; "two args" &lt;&lt; std::endl; }
};

int main() {
    MyClass func_obj;

    std::invoke(func_obj);
    std::invoke(func_obj, 0);
    std::invoke(func_obj, 0, 1);

    std::vector&lt;int&gt; v{1, 2, 3, 4};
    std::for_each(v.begin(), v.end(), MyClass{});


    // checks at compilation time if func_obj supports the necessary convertion with operator() functions
    std::function&lt;void()&gt; fn_0 = func_obj;
    std::function&lt;void(int)&gt; fn_1 = func_obj;
    std::function&lt;void(int, int)&gt; fn_2 = func_obj;

    return 0;
}


</code></pre>
<h2 id="lambda"><a class="header" href="#lambda">lambda</a></h2>
<p>anonymous functors - compiler generates it's class name and <code>operator()</code> functions according to your lambda definition. it's by default immutable but you can change is by using <code>mutable</code>.</p>
<pre><code class="language-c++">
struct type {
    type() = default;
    type(const type&amp;) = delete;
};

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, type const&amp;) {
    out &lt;&lt; "type obj" &lt;&lt; std::endl;
    return out;
}

// out of function
const auto out_of_func_l = [](int arg) { std::cout &lt;&lt; arg &lt;&lt; std::endl; };

int main() {

    // internal
    const auto func_l = [](int arg) { std::cout &lt;&lt; arg &lt;&lt; std::endl; };

    out_of_func_l(0);
    func_l(0);

    // capture by ref
    {
        auto x = 0;

        auto ref_l = [&amp;x] { x = 101; };

        ref_l();

        // inner updated outer because both are same
        assert(x == 101);
    }

    {
        auto y = 0;

        auto val_l = [y] mutable { y = 101; }; // use mutable to update member y (belongs to lambda object)

        // no update for outer one
        assert(y == 0);
    }

    // generic lambda: can be defined with `template` or just `auto`
    {

        const auto template_l = []&lt;typename T&gt;(T value) {
            std::cout &lt;&lt; value &lt;&lt; std::endl;
        };

        const auto template_univ_l = []&lt;typename T&gt;(T&amp;&amp; value) {
            std::cout &lt;&lt; value &lt;&lt; std::endl;
        };

        template_l(1);
        template_l("hakan gedek");

        template_univ_l(1);
        template_univ_l("hakan gedek");

        type t;
        template_univ_l(t); // template_l fails - doesnt' accept &amp;
    }

    {
        const auto auto_template_l = [](auto value) {
            std::cout &lt;&lt; value &lt;&lt; std::endl;
        };

        type t;
        auto_template_l(1);
        auto_template_l("hakan gedek");
        // auto_template_l(t); =&gt; fails =&gt; auto without &amp; allows only moved or copied

        const auto auto_univ_template_l = [](auto&amp;&amp; value) {
            std::cout &lt;&lt; value &lt;&lt; std::endl;
        };

        auto_univ_template_l(1);
        auto_univ_template_l("hakan gedek");
        auto_univ_template_l(t);
    }
}


</code></pre>
<p>capture by ref: be careful with scopes and lifetime of captured variables</p>
<pre><code class="language-c++">
// this is invalid but it will be compiled
int main() {
    std::function&lt;void()&gt; fn;

    {
        int x = 0;

        fn = [&amp;x] { x = 101; };
    }

    // x goes out of scope and not valid =&gt; UB

    fn();
}

</code></pre>
<p>this is correct impl. if you keep lambda definition longer then captured variables then capture them by value and if you will update them then make lambda mutable - if you want to alias them [new_name = x] is used</p>
<pre><code class="language-c++">int main() {
    std::function&lt;void()&gt; fn;

    {
        int x = 0;

        fn = [x] mutable { x = 101; std::cout &lt;&lt; x &lt;&lt; std::endl;};
    }
    fn();

</code></pre>
<h2 id="function-pointer"><a class="header" href="#function-pointer">function pointer</a></h2>
<p>oldest method...like anything else functions also have a memory address so why not having a pointer for them too ? if you have a memory address then you have a pointer too !</p>
<pre><code class="language-c++">
// type
typedef void(*fptr_t)(int);
// or
// using f_ptr_t = void(*)(int);

// var
void (*fvar)(int);

void foo(int arg) {
    std::cout &lt;&lt; arg &lt;&lt; std::endl;
}

int main() {
    fvar = foo;

    fptr_t fn = foo;

    fvar(1);
    fn(1);

    return 0;
}

</code></pre>
<blockquote>
<p>allowed to be used in containers like std::function but function pointers are faster - better performance (benchmark shows that lambda and function pointers are faster than function objects )</p>
</blockquote>
<pre><code class="language-c++">
using fptr_t = void (*)(int);

void foo(int arg) { std::cout &lt;&lt; arg &lt;&lt; std::endl; }

int main() {
    std::vector&lt;fptr_t&gt; fns{foo, foo, foo};

    for (auto&amp; fn : fns) fn(1);

}

</code></pre>
<blockquote>
<p>std::function is a great tool to convert callables into objects which can be stored in containers</p>
</blockquote>
<p>you can keep function pointers or functors too but std::function is more readable and more generic.</p>
<pre><code class="language-c++">
class CallbackHandler {
public:
    void registerCallback(std::function&lt;void(int)&gt; callback) {
        callbacks.push_back(callback);
    }

    void triggerCallbacks(int value) {
        for (auto&amp; callback : callbacks) {
            callback(value);
        }
    }

private:
    std::vector&lt;std::function&lt;void(int)&gt;&gt; callbacks;
};

void demonstrateCallbackUsage() {
    std::cout &lt;&lt; "\n--- Callback Reference Handling ---\n";

    int shared_state = 0;
    CallbackHandler handler;

    // Register callbacks with reference to shared state
    handler.registerCallback([&amp;shared_state](int increment) {
        shared_state += increment;
    });

    handler.triggerCallbacks(10);

    std::cout &lt;&lt; "Shared state after callback: " &lt;&lt; shared_state &lt;&lt; std::endl;
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-a-packaged_task"><a class="header" href="#create-a-packaged_task">create a packaged_task</a></h1>
<p>use case: multi-threaded environment... channeling between different threads like producer - consumer etc...</p>
<p>using packaged_task on the same thread is same with using std::invoke with callables (functor, lambda, function...) so only use it when you need a channel between threads - packaged_task returns results over future object so you channel data from one thread to another thread asyncly.</p>
<pre><code class="language-c++">
auto median(std::vector&lt;int&gt; const&amp; data) {

    if (data.empty()) 
        return 0.0f;

    const auto len = data.size();
    const auto tot = std::accumulate(data.begin(), data.end(), 0);

    return (float)tot/len;
}

auto task() -&gt; float
{
    // simulate an IO operation
    std::this_thread::sleep_for(std::chrono::milliseconds(200));

    std::vector&lt;int&gt; data = {1,2,3,4};

    return median(data);
}

template &lt;typename T&gt;
using channel_t = std::future&lt;T&gt;;

auto print(channel_t&lt;float&gt; ch) {
    ch.wait(); // wait for data is ready like golang

    auto res = ch.get(); // read the data
    
    // process the data from producer thread
    {
        std::cout &lt;&lt; "data: " &lt;&lt; res &lt;&lt; std::endl;
    }
}

int main() {

    std::packaged_task&lt;decltype(task)&gt; pt{task};
    
    channel_t&lt;float&gt; ch = pt.get_future();

    std::jthread tp{std::move(pt)}, tc{print, std::move(ch)};

    std::this_thread::sleep_for(std::chrono::seconds(1)); // let the main thread go on

    std::cout &lt;&lt; "done..." &lt;&lt; std::endl;

    // I don't care what happened with IO or process of the data - it's done asyncly
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="define-specialized-template-functions"><a class="header" href="#define-specialized-template-functions">define specialized template functions</a></h1>
<p>template functions only support full specializations but you can overload them without using template headers.</p>
<pre><code class="language-c++">
template &lt;typename T&gt;
void foo(T&amp;&amp; arg) {
    std::cout &lt;&lt; "base::foo" &lt;&lt; std::endl;
}

// no need to put template header for functions - template is lazy - if you implemented it; compiler will not generate it
void foo(int&amp;) { std::cout &lt;&lt; "foo:int" &lt;&lt; std::endl; }
void foo(int&amp;&amp;) { std::cout &lt;&lt; "foo:int" &lt;&lt; std::endl; }

// T holds
// float =&gt; (float&amp;&amp;)
// float&amp; =&gt; (float&amp;)
// const float&amp; =&gt; (const&amp; float)
template &lt;&gt;
void foo&lt;float&amp;&gt;(float&amp; arg) {
    std::cout &lt;&lt; "foo::float" &lt;&lt; std::endl;
}

template &lt;&gt;
void foo&lt;double&amp;&gt;(double&amp; arg) {}

template &lt;&gt;
void foo&lt;double&gt;(double&amp;&amp; arg) {}

void foo(double&amp; arg) { std::cout &lt;&lt; "foo::double" &lt;&lt; std::endl; }

int main() {
    int i;
    float f;
    double d;

    foo(i);
    foo(0);
    foo(f);
    foo(d);
}

</code></pre>
<blockquote>
<p>you can full specialize or overload the non member template functions...both works and I prefer overloading them: cleaner.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="define-specialized-template-classes"><a class="header" href="#define-specialized-template-classes">define specialized template classes</a></h1>
<p>a very simple variant impl. when compared to the one I did for union type. no need to create anything - let the correct base to store the variable and a flag to track if it's set...</p>
<pre><code class="language-c++">
#include &lt;cassert&gt;
#include &lt;iostream&gt;

template &lt;class T, class... Ts&gt;
struct variant : variant&lt;Ts...&gt; {
    constexpr variant() = default;
    constexpr variant(T&amp;&amp; arg) : _value(std::forward&lt;T&gt;(arg)), _flag{true} {}
    constexpr operator T() const {
        if (!_flag) throw std::logic_error("invalid type");
        return _value;
    }

    T _value{};
    bool _flag = false;
};

template &lt;class T&gt;
struct variant&lt;T&gt; {
    constexpr variant() = default;
    constexpr variant(T&amp;&amp; arg) : _value(std::forward&lt;T&gt;(arg)), _flag{true} {}
    constexpr operator T() const {
        if (!_flag) throw std::logic_error("invalid type");
        return _value;
    }
    T _value{};
    bool _flag = false;
};

int main() {
    variant&lt;int, float&gt; var{1};
    const int x = var;
    std::cout &lt;&lt; x &lt;&lt; std::endl;

    assert(x == 1);
    try {
        double const d = var;
    } catch (std::exception const&amp; e) {
        std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
    }

    return 0;
}

</code></pre>
<p>fixed types: you have to provide all and specialization count &lt;&gt; has to be same</p>
<pre><code class="language-c++">
template &lt;class T, class U&gt;
struct variant {};

template &lt;class T&gt;
struct variant&lt;T&gt; {}; // fails -&gt; base has fixed 2 params so you have to keep it

template &lt;class T&gt;
struct variant&lt;T, int&gt; {}; // works


// but
</code></pre>
<p>flexible types: variadic... you can create new bases and count is flexible</p>
<pre><code class="language-c++">template &lt;class T, class...Ts&gt;
struct variant{};

template &lt;class T&gt;
struct variant&lt;T&gt; {}; // works. ...Ts. is more flexible and allows use to create new bases -&gt; this is a base now for 1 param

template &lt;class T, class U&gt;
struct variant&lt;T,U&gt; {}; // works -&gt; again a base to create 2 params version
...

</code></pre>
<p>max flexible one is &lt;class...Ts&gt;. you can support empty version too. previous one needs at least one template type but this one nothing...</p>
<pre><code class="language-c++">#include &lt;cassert&gt;
#include &lt;iostream&gt;

// base for more types
template &lt;class... Ts&gt;
struct variant {};

// base for one T
template &lt;class T&gt;
struct variant&lt;T&gt; {};

// base for two Ts
template &lt;class T, class U&gt;
struct variant&lt;T, U&gt; {};

// no need template
template &lt;&gt;
struct variant&lt;&gt; {
    static constexpr auto value = 101;
};

int main() {
    constexpr variant v;

    static_assert(v.value == 101);

    return 0;
}

</code></pre>
<p>you can specialize to different states of a type:</p>
<pre><code class="language-c++">
#include &lt;cassert&gt;
#include &lt;iostream&gt;

template &lt;class T&gt;
struct wrapper {
    static constexpr auto val = 1;
};

template &lt;class T&gt;
struct wrapper&lt;T*&gt; {
    static constexpr auto val = 2;
};

template &lt;class T&gt;
struct wrapper&lt;T&amp;&gt; {
    static constexpr auto val = 3;
};

template &lt;class T&gt;
struct wrapper&lt;T&amp;&amp;&gt; {
    static constexpr auto val = 4;
};

template &lt;class T&gt;
struct wrapper&lt;T const&amp;&gt; {
    static constexpr auto val = 5;
};

int main() {
    constexpr int i = 0;
    static_assert(wrapper&lt;decltype(i)&gt;::val == 1);

    constexpr const int ci = 0;
    static_assert(wrapper&lt;decltype(ci)&gt;::val == 1);

    const int&amp; ri = i;
    assert(wrapper&lt;decltype(ri)&gt;::val == 5);

    const int* ptr = &amp;i;

    assert(wrapper&lt;decltype(ptr)&gt;::val == 2);
}

</code></pre>
<p>or you can code all by yourself:</p>
<pre><code class="language-c++">
template &lt;class T&gt;
struct wrapper {};

template &lt;&gt;
struct wrapper&lt;int&gt; {};

template &lt;&gt;
struct wrapper&lt;float&gt; {};

template &lt;&gt;
struct wrapper&lt;const char*&gt; {};
...

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="define-specialized-template-methods"><a class="header" href="#define-specialized-template-methods">define specialized template methods</a></h1>
<p>you can either full specialize the member methods or overload them - overloading is cleaner - you cannot place specializations in class either - put outside or even in cpp file !</p>
<pre><code class="language-c++">
struct MyS {
    template &lt;class T&gt;
    void foo(T&amp;&amp;) {
        std::cout &lt;&lt; "base" &lt;&lt; std::endl;
    }

    // just overload - instead of specialization : always works
    void foo(int&amp;) { std::cout &lt;&lt; "int" &lt;&lt; std::endl; }
    void foo(char&amp;) { std::cout &lt;&lt; "char" &lt;&lt; std::endl; }
};

// carry these to cpp
template&lt;&gt;
void MyS::foo&lt;float&amp;&gt;(float&amp;) { std::cout &lt;&lt; "float" &lt;&lt; std::endl; }

template&lt;&gt;
void MyS::foo&lt;float&gt;(float&amp;&amp;) { std::cout &lt;&lt; "float" &lt;&lt; std::endl; }


int main() {
    int x = 0;
    float f = 0.0;

    MyS ms;

    ms.foo(x);
    ms.foo(f);
    ms.foo(1.2f);
    ms.foo(1.2);
    ms.foo("hakan");

    return 0;
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-strlen-and-sizeof-with-bytes"><a class="header" href="#use-strlen-and-sizeof-with-bytes">use strlen and sizeof with bytes</a></h1>
<p>null ending character arrays (c string) has special functions like strlen, strcpy, strcmp... strlen is useful to find the real length of the string ( without '\0' ) or you can use sizeof to get all.</p>
<pre><code class="language-c++">#include &lt;cassert&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;

int main() {
    // null ending
    const char name[] = "hakan gedek";
    const char* name2 = "hakan gedek";
    const char jpn[] = "こんにちは世界";

    // you can use sizeof with variables as
    // sizeof var
    // sizeof(var)
    std::cout &lt;&lt; strlen(name) &lt;&lt; ':' &lt;&lt; sizeof name &lt;&lt; std::endl;
    // sizeof will return 8bytes for const char* which is sizeof a ptr on 64bit system
    std::cout &lt;&lt; strlen(name2) &lt;&lt; ':' &lt;&lt; sizeof(name2) &lt;&lt; std::endl;
    // utf8 didn't change the byte len &amp; byte calc: both safe
    std::cout &lt;&lt; strlen(jpn) &lt;&lt; ':' &lt;&lt; sizeof jpn &lt;&lt; std::endl;

    const int nums[] = {1, 2, 3, 4, 5};
    std::cout &lt;&lt; sizeof(nums) / sizeof(nums[0]) &lt;&lt; ":" &lt;&lt; sizeof nums
              &lt;&lt; std::endl;

    const double dls[] = {1.0, 2.0, 3.0, 4.0, 5.0};
    std::cout &lt;&lt; sizeof(dls) / sizeof(dls[0]) &lt;&lt; ":" &lt;&lt; sizeof dls &lt;&lt; std::endl;

    return 0;
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="define-mixins"><a class="header" href="#define-mixins">define mixins</a></h1>
<blockquote>
<p>mixin: classes with functionality / behaviors but they cannot stand alone - they provides them to other classes via inheritance.</p>
</blockquote>
<p>methods to define mixins</p>
<ul>
<li>
<p>variadic inheritance</p>
</li>
<li>
<p>policy based design</p>
</li>
<li>
<p>composition</p>
</li>
<li>
<p>crtp</p>
</li>
</ul>
<p>I believe best is variadic parents...</p>
<pre><code class="language-c++">
struct Loggable {
    void log(const std::string&amp; msg) {}
};


struct Serializable {
    std::string serialize() const {}
};

template &lt;class ...Mixins&gt;
struct MyS: Mixins... {
    void foo() {
        log("...");
        std::cout &lt;&lt; serialize()  &lt;&lt; std::endl;
    }
};

</code></pre>
<blockquote>
<p>mixin classes are ability or functionality classes and they are useless alone...you use them like plugins to add them to other classes. call it decorating ? why not !</p>
</blockquote>
<pre><code class="language-c++">
struct A {};

struct B {};

template &lt;typename ...Ts&gt;
struct C: Ts...
{
    C(Ts...args): Ts(args)...
};


C&lt;A,B&gt; c(A{}, B{}); =&gt; think them as configured... and now C has them

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="define-policy-based-design"><a class="header" href="#define-policy-based-design">define policy based design</a></h1>
<p>looks like mixins but policy classes seems more concrete yet at the end you define some standalone behaviors, logics, ideas in policy classes and provide them to others via template headers</p>
<pre><code class="language-c++">
struct ConsoleLoggingPolicy {
    void log(std::string const&amp;) {}
};

struct FileLoggingPolicy {
    void log(std::string const&amp;) {}
};

struct JsonSerializePolicy {
    std::string serialize() const {}
};

struct XmlSerializePolicy {
    std::string serialize() const {}
};

template &lt;class LoggingPolicy, class SerializePolicy&gt;
struct MyS: LoggingPolicy, SerailizePolicy {
    void foo() {
        log();
        std::cout &lt;&lt; serialize() &lt;&lt; std::endl;
    }
};

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-meta-programming-to-work-with-types"><a class="header" href="#use-meta-programming-to-work-with-types">use meta programming to work with types</a></h1>
<p>using meta programming we can re-organize, sort, list ... types passed through template headers.</p>
<pre><code class="language-c++">
template&lt;typename...&gt;
struct Tuple {};

template&lt;typename T1, typename T2&gt;
struct Pair {};

template&lt;class... Args1&gt;
struct zip
{
    template&lt;class... Args2&gt;
    struct with
    {
        typedef Tuple&lt;Pair&lt;Args1, Args2&gt;...&gt; type;
        // Pair&lt;Args1, Args2&gt;... is the pack expansion
        // Pair&lt;Args1, Args2&gt; is the pattern
    };
};

typedef zip&lt;short, int&gt;::with&lt;unsigned short, unsigned&gt;::type T1;

</code></pre>
<p>let's implement push_front and push_back methods to create a variadic type list and capture it.</p>
<p>when working with recursive calls in types; all starts from the recursive ended point...
in this example... reverse&lt;int,float,double&gt;::type will come back with type_list<double> and then type_list<double>::type will be itself and it's own push_back will capture other type which is float and &lt;double,float...&gt; goes on..</p>
<pre><code class="language-c++">
template &lt;class... Ts&gt;
struct type_list {
    using type = type_list&lt;Ts...&gt;;

    template &lt;class T&gt;
    using push_back = type_list&lt;Ts..., T&gt;;

    template &lt;class T&gt;
    using push_front = type_list&lt;T, Ts...&gt;;
};

template &lt;&gt;
struct type_list&lt;void&gt; {};

template &lt;class T, class... Ts&gt;
struct reverse {
    using type = typename reverse&lt;Ts...&gt;::type::template push_back&lt;T&gt;;
};

template &lt;class T&gt;
struct reverse&lt;T&gt; {
    using type = type_list&lt;T&gt;;
};

template &lt;typename... Ts&gt;
using reverse_t = typename reverse&lt;Ts...&gt;::type;

int main() {
    static_assert(std::same_as&lt;type_list&lt;char, int, float, double&gt;,
                               reverse_t&lt;double, float, int, char&gt;&gt;);
}


</code></pre>
<p>meta-functions are structs with inner states like capturing type, setting a constant value via static constexpr etc. using meta funcs we can create some compile time stuff but generally it's recursive.</p>
<p>let filter types in variadic list and create a new list...</p>
<pre><code class="language-c++">
template &lt;class... Ts&gt;
struct type_list {
    using type = type_list&lt;Ts...&gt;;

    template &lt;class T&gt;
    using push_back = type_list&lt;Ts..., T&gt;;

    template &lt;class T&gt;
    using push_front = type_list&lt;T, Ts...&gt;;
};

template &lt;&gt;
struct type_list&lt;void&gt; {};

template &lt;template &lt;class&gt; class Cont, class T&gt;
concept has_value_field = requires {
    { Cont&lt;T&gt;::value } -&gt; std::convertible_to&lt;bool&gt;;
};

template &lt;template &lt;class&gt; class Cont, class T, class... Ts&gt;
    requires has_value_field&lt;Cont, T&gt;
struct filter {
    using type = std::conditional_t&lt;
        Cont&lt;T&gt;::value,
        typename filter&lt;Cont, Ts...&gt;::type::template push_front&lt;T&gt;,
        typename filter&lt;Cont, Ts...&gt;::type&gt;;
    ;
};

template &lt;template &lt;class&gt; class Cont, class T&gt;
    requires has_value_field&lt;Cont, T&gt;
struct filter&lt;Cont, T&gt; {
    using type = std::conditional_t&lt;Cont&lt;T&gt;::value, type_list&lt;T&gt;, type_list&lt;&gt;&gt;;
};

template &lt;template &lt;class&gt; class Cont, class... Ts&gt;
using filter_t = typename filter&lt;Cont, Ts...&gt;::type;

int main() {
    static_assert(
        std::same_as&lt;type_list&lt;int, bool&gt;,
                     filter_t&lt;std::is_integral, int, double, float, bool&gt;&gt;);
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-config-class"><a class="header" href="#create-config-class">create config class</a></h1>
<p>instead of using MACROs as true constants; using constexpr or statics are better. MACROs are not good solutions for creating constants because you cannot debug them and they don't hold mem addresses.</p>
<pre><code class="language-c++">
class Config {
public:
    static const int Index = 0;
    static const int Value = 0;
    constexpr static int Index = 0;
    constexpr static int Value = 0;
};

</code></pre>
<blockquote>
<p>static: they will initialized at the beginning of the program and exist till end of the program</p>
</blockquote>
<blockquote>
<p>static: thread-safe</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-stdconditional"><a class="header" href="#use-stdconditional">use std::conditional</a></h1>
<p>useful with branching when type checking... it can create a stop condition for you when you call recursively the same base type.</p>
<pre><code class="language-c++">
#include &lt;variant&gt;

template &lt;typename T, typename... Ts&gt;
struct HasIt : std::false_type {};

template &lt;typename T1, typename T2, typename... Ts&gt;
struct HasIt&lt;T1, T2, Ts...&gt;
    : public std::conditional_t&lt;std::is_same_v&lt;T1, T2&gt;, std::true_type,
                                HasIt&lt;T1, Ts...&gt;&gt; {};
template &lt;typename T, typename... Ts&gt;
struct InVarType : std::false_type {};

template &lt;typename T, typename... Ts&gt;
struct InVarType&lt;T, std::variant&lt;Ts...&gt;&gt; : HasIt&lt;T, Ts...&gt; {};

int main() {
    std::variant&lt;int, float, std::string&gt; var;
    fmt::println("{}", InVarType&lt;std::string, decltype(var)&gt;::value);
}

</code></pre>
<p>by capturing the Ts... but this is topic of variadic templates...</p>
<pre><code class="language-c++">
template &lt;typename T, typename... Ts&gt;
constexpr bool has_it(std::variant&lt;Ts...&gt;&amp;&amp;) {
    return ((std::is_same_v&lt;T, Ts&gt;) | ...);

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="abstract-template-class"><a class="header" href="#abstract-template-class">abstract template class</a></h1>
<p>if you forward decl a template class but didn't provide a default definition for it then you cannot use it for all so you can think it as <code>abstract</code> for not specialized types...</p>
<pre><code class="language-c++">
struct base_temp_traits{
};

struct Celcius{};

struct Kelvin{};

template &lt;class&gt;
struct temp_traits;

template &lt;&gt;
struct temp_traits&lt;Celcius&gt; : base_temp_traits {
    using value_type = int;

    static constexpr auto symbol() -&gt; const char* { return "C"; }
    static constexpr value_type water_freezing_threshold() { return 0; }
    static constexpr auto to_neutral(value_type value) { return value; }
    static constexpr auto from_neutral(value_type value) { return value; }
};

template &lt;&gt;
struct temp_traits&lt;Kelvin&gt;: base_temp_traits {
    using value_type = double;

    static constexpr auto symbol() -&gt; const char* { return "K"; }
    static constexpr value_type water_freezing_threshold() { return 273.15; }
    static constexpr value_type to_neutral(value_type value) { return val - water_freezing_threshold(); }
    static constexpr value_type from_neutral(value_type value) { return val + water_freezing_threshold(); }
}
</code></pre>
<blockquote>
<p>temp_traits is only implemented for Kelvin and Celcius types but it's not valid for int, float,... so you can think its abstract for them</p>
</blockquote>
<blockquote>
<p>std::vector&lt;int&gt; != std::vector&lt;float&gt;... : they just share the shell but content is not same ! never forget this when coding templates...if you specialize; you can change everything too.</p>
</blockquote>
<pre><code class="language-c++">class base_a { using type = int; };
class base_b { using type = float; };
class base_c { using type = double; };

template &lt;class&gt; struct type_trait;

template&lt;&gt; struct type_trait&lt;int&gt;: base_a {};
template&lt;&gt; struct type_trait&lt;float&gt;: base_b {};
template&lt;&gt; struct type_trait&lt;double&gt;: base_c {};

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="define-fold-expansions"><a class="header" href="#define-fold-expansions">define fold expansions</a></h1>
<blockquote>
<p>((logic), ...), ((logic) op ...)</p>
</blockquote>
<ul>
<li>unary left: (... op pack)</li>
<li>unary right: (pack op ...)</li>
<li>binary left: (init op ... op pack)</li>
<li>binary right: (pack op ... op init)</li>
</ul>
<pre><code class="language-c++">
((std::cout &lt;&lt; args), ...);

( args &amp;&amp;...)

</code></pre>
<pre><code class="language-c++">// unary left
template &lt;class...Args&gt;
auto sum(Args... args) {
    return (... + args);
}

// unary right
template &lt;class...Args&gt;
auto sum(Args...args) {
    return (args + ...);
}

//binary left
template &lt;class...Args&gt;
auto sum(Args...args) {
    return (0 + ... + args);
}

//binary right
template &lt;class...Args&gt;
auto sum(Args...args) {
    return (args + ... + 0);
}

</code></pre>
<p>we can repeat a pattern for each arg if necessary.</p>
<pre><code class="language-c++"> fn(args...) =&gt; fn(a,b,c,d,...)
 fn(&amp;args...) =&gt; fn(&amp;a,&amp;b,&amp;c,&amp;d...)
 fn(n, ++args...) =&gt; fn(n, ++a, ++b, ++c, ++d...)
 fn(++args..., n) =&gt; fn(++a, ++b, ++c, ++d,..., n)
 fn(const_cast&lt;Args*&gt;(arg)...) =&gt; fn(const_cast&lt;A*&gt;(a), const_cast&lt;B*&gt;(b)...)

</code></pre>
<blockquote>
<p>(): expansion operation outer wrapper</p>
</blockquote>
<blockquote>
<p>((pattern)op): form of the operation</p>
</blockquote>
<p>let's see some pattern repetitions for args...</p>
<pre><code class="language-c++">constexpr void dummy(auto arg) {}
constexpr auto dummy1(auto arg) { return arg; }

void func(auto... args) {
    // an op call
    ((std::cout &lt;&lt; args), ...);
    std::cout &lt;&lt; '\n';

    // void method call
    (dummy(args), ...);
    const auto res = (dummy1(args) + ...);

    // an op
    const auto r = (args + ...);
    const auto l = (... + args);

    std::cout &lt;&lt; "r: " &lt;&lt; r &lt;&lt; " l: " &lt;&lt; l &lt;&lt; std::endl;

    // some condition for all
    const auto res1 = ((args &gt; 0) &amp;&amp; ...);
    const auto res2 = ((args &lt; 10) &amp;&amp; ...);
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="define-template-variable"><a class="header" href="#define-template-variable">define template variable</a></h1>
<p>template allows us to create variables and also alias... (using... ) ...</p>
<pre><code class="language-c++">
template &lt;size_t N&gt;
constexpr auto Height = N * 100;

#define HEIGHT(N) N * 100

template &lt;typename T&gt;
constexpr auto Max = std::numeric_limits&lt;T&gt;::max();

template &lt;typename T&gt;
constexpr auto PI = T(3.14); // each type will generate own PI with value...PI&lt;int&gt; != PI&lt;float&gt; ... both different - name and value

int main() {

   assert( Max&lt;int&gt; != Max&lt;float&gt;); // but it's templated and shows a VALUE
}


</code></pre>
<p>compile time total calculation - always think about stop condition.</p>
<pre><code class="language-c++">template &lt;size_t N&gt;
constexpr auto total = N + total&lt;N - 1&gt;;

template &lt;&gt;
constexpr auto total&lt;0&gt; = 0;

int main() {
    fmt::print("{}", total&lt;100&gt;);
    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-rvalues-correctly"><a class="header" href="#use-rvalues-correctly">use rvalues correctly</a></h1>
<blockquote>
<p><code>T var = value;</code> is a normal assignment. var is lvalue and value is rvalue ( left-value and right-value)</p>
</blockquote>
<p>there are 2 kinds of rvalue:</p>
<ul>
<li>xvalue: expiring value (std::move result...)</li>
<li>prvalue: pure rvalue (real rvalues like literals)</li>
</ul>
<blockquote>
<p>think rvalue value and move semantics if the data is heap based or forget it. for stack based data you will end with copying.</p>
</blockquote>
<blockquote>
<p>don't think move semantics and rvalue convertions for literals types - let compiler handle it itself like int, char, char const* etc...</p>
</blockquote>
<h2 id="xvalue"><a class="header" href="#xvalue">xvalue</a></h2>
<pre><code class="language-c++">
std::string foo() {
    std::string name = "hakan gedek";
    return name; // RVO ( return value optimization) will return an rvalue and mem will be kept
}

struct MyStruct {
    void foo()&amp;&amp; {}
};

int main() {

    MyStruct src{};

    MyStruct other = std::move(src); // if src has a heap data like std::string; it will be released

    MyStruct{}.foo(); // MyStruct{} is an xvalue - expring after usage
}

</code></pre>
<h2 id="prvalue"><a class="header" href="#prvalue">prvalue</a></h2>
<p>pure rvalue</p>
<pre><code class="language-c++">
struct S {
    void foo()&amp;&amp; {}
};

int main() {
    int x = 0; // 0 is rvalue
    const char* name = "hakan gedek"; // "hakan gedek" is a rvalue
}

</code></pre>
<h2 id="rvalue-supported-custom-types"><a class="header" href="#rvalue-supported-custom-types">rvalue supported custom types</a></h2>
<p>you can call them move constructor or move assignment operator supported types too - generally by default they are implemented by compiler if you allow it. but if you manually implement copy special functions; they will not be generated.</p>
<pre><code class="language-c++">
struct only_moveable {
    only_moveable() = default;
    only_moveable(only_moveable&amp;&amp;) = default;
    only_moveable&amp; operator=(only_moveable&amp;&amp;) = default;
    // if you pick move funcs then copy funcs are deleted
    // if you pick copy funcs then move funcs are deleted
    // if you don't impl any of them compiler generates all for you
};

struct derived : private only_moveable {};

derived get_object() {
    derived d;
    return d;
}

int main() {
    // rvo
    derived d1 = get_object();

    // derived d2 = d1; =&gt; copy call =&gt; fails

    derived d3 = std::move(d1);

    derived d4;
    d4 = std::move(d3);
}

</code></pre>
<h2 id="only-rvalue-accessible-methods"><a class="header" href="#only-rvalue-accessible-methods">only rvalue accessible methods</a></h2>
<p>we will show this in <code>how to design builder pattern</code> too but also check <code>how to use forward references correctly</code></p>
<pre><code class="language-c++">
struct S {
    void foo()&amp; {
        std::cout &lt;&lt; "can be called by only lvalues"  &lt;&lt; std::endl;
    }

    void foo()&amp;&amp; {
        std::cout &lt;&lt; "can be called by only lvalues"  &lt;&lt; std::endl;
    }
};

int main() {
    S s;
    s.foo(); // calls lvalue &amp; method

    S{}.foo(); // calls rvalue &amp;&amp; method
}
</code></pre>
<h2 id="rvalue-ref-vs-const"><a class="header" href="#rvalue-ref-vs-const">rvalue ref vs const &amp;</a></h2>
<p><code>const &amp;</code> can contain rvalue but it's <strong>immutable</strong>
rvalue ref ( &amp;&amp;) is <strong>mutable</strong> like lvalue ref (&amp;)</p>
<p>You can change &amp;&amp; data as it's a normal lvalue type passed as a reference - rvalue ref is not immutable but mutable.</p>
<pre><code class="language-c++">
#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include &lt;print&gt;

int getValue() { return 0; }

void foo(int&amp; value) {
    std::println("lvalue ref");
    std::println("{}", value);
    value += 20;
    std::println("{}", value);
}

void foo(int&amp;&amp; value) {
    std::println("rvalue ref");
    std::println("{}", value);
    value += 200;
    std::println("{}", value);
}

void bar(const int&amp; value) {
    std::println("const ref");
    std::println("{}", value);
    // value += 200; // doesn't allow =&gt; immutable
    std::println("{}", value);
}

int main() {
    int a = 0;
    foo(a);
    foo(10);
    foo(getValue());

    bar(a);

    // rvalue ref acted as lvalue ref and overwrote the data like pass by ref
    int b = 0;
    foo(std::move(b));
    std::cout &lt;&lt; b &lt;&lt; std::endl;
    assert(b == 200);

    // heap type -&gt; when passed into baz released the inner pointer and in baz
    // rvalue owned the data and update it but when returned back
    // name still holds that address in variable which is DAMN STUPID but well it's like this in c++
    std::string name = "";
    baz(std::move(name));
    assert(name == "hakan gedek")
}

</code></pre>
<blockquote>
<p>int&amp; =&gt; mutable</p>
</blockquote>
<blockquote>
<p>int&amp;&amp; =&gt; mutable</p>
</blockquote>
<blockquote>
<p>const int&amp; =&gt; immutable</p>
</blockquote>
<h2 id="class-template-vs-function-template"><a class="header" href="#class-template-vs-function-template">class template vs function template</a></h2>
<pre><code class="language-c++">
template &lt;class T&gt;
struct MyS {
    MyS(T&amp;&amp;)
};

is `not` same with

template &lt;class T&gt;
void foo(T&amp;&amp;) {}

when generating the T's possible values...

</code></pre>
<ul>
<li>
<p>the first one real rvalue reference which by default only accepts {int&amp;}</p>
</li>
<li>
<p>the second one universal reference which will be extended to box {int&amp;, int&amp;&amp;, const int&amp;}</p>
</li>
</ul>
<p>how to solve it ?</p>
<pre><code class="language-c++">
int x = 0;

MyS  obj{s}; // fails by default
MyS obj{std::move(s)}; // works
MyS&lt;const int&amp;&gt; obj{s}; // works - explicitly set the T
MyS&lt;int&amp;&gt; obj{s}; // works - explicitly set the T

</code></pre>
<blockquote>
<p>whenever you use T&amp;&amp;; you touched forward references so whenever you use that variable; wrap it std::forward&lt;T&gt;(arg) to call correct stuff</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-condition-variable"><a class="header" href="#use-condition-variable">use condition variable</a></h1>
<p>synchronizers of the threads. cv is more efficient than looping around an atomic boolean flag because cv doesn't consume cpu power and puts the thread into sleep mode.</p>
<p>you can implement cv's condition control as default or predicate based - if predicated is ok then it will go on.</p>
<pre><code class="language-c++">// a simple cv example without predicate

// these should be shared by threads
std::atomic_int value = 0;

std::mutex mtx;
std::condition_variable cv;

std::atomic_bool done = false;

using namespace std::chrono_literals;

void produce()
{
    while (value &lt; 100)
    {
        std::unique_lock&lt;std::mutex&gt; lck{mtx};
        value++;

        std::cout &lt;&lt; "producing =&gt; " &lt;&lt; value &lt;&lt; '\n';

        cv.notify_one(); // release the consumer
        cv.wait(lck);
    }

    done = true;
}

void consume()
{
    while (true)
    {
        std::unique_lock&lt;std::mutex&gt; lck{mtx};
        cv.wait(lck);

        std::cout &lt;&lt; "consuming =&gt; " &lt;&lt; value &lt;&lt; '\n';
        cv.notify_one(); // release the producer

        if (done)
            break;
    }
}

int main()
{
    std::jthread j0{consume};
    std::this_thread::sleep_for(1ms);
    std::jthread j1{produce};
}

</code></pre>
<p>and with predicate:</p>
<pre><code class="language-c++">
using std::condition_variable;
using std::mutex;
using std::cout, std::endl;
using std::this_thread, std::jthread;


condition_variable cv;
mutex mtx;

int i = 0;
bool done = false;

void waits() {
    unique_lock&lt;mutex&gt; lck{mtx};
    cout &lt;&lt; "waiting...\n";

    cv.wait(lck, []{ return i == 1;});
    cout &lt;&lt; "...finished waiting i == " &lt;&lt; i &lt;&lt; '\n';

    done = true;
}

void signals() {
    this_thread::sleep_for(100ms);
    cout &lt;&lt; "notifying...\n" ;

    cv.notify_one(); // wakes up and controls the predicate. if condition is ok releases the thread or returns to wait

    unique_lock&lt;mutex&gt; lck{mtx};
    i = 1;

    while (!done) {
        cout &lt;&lt; "notifying the change\n";
        lck.unlock();
        cv.notify_one();
        this_thread::sleep_for(200ms);
        lck.lock();
    }
}

int main() {
    jthread{waits}, jhread{signals};
}

</code></pre>
<p>and a simple cake cooker example.</p>
<pre><code class="language-c++">
using namespace std::chrono_literals;

using std::cout, std::endl;

std::condition_variable cv;
std::mutex mtx;

struct Cake
{
    size_t id = 0;
};

std::queue&lt;Cake&gt; cake_queue;

struct Cooker
{
    void operator()(std::stop_token token)
    {
        size_t count = 0;

        while (not token.stop_requested())
        {
            std::this_thread::sleep_for(1ms);

            auto cake = Cake{count++};
            {
                std::lock_guard&lt;std::mutex&gt; lck{mtx};
                cake_queue.push(cake);
            }

            cv.notify_one();
        }
    }
};

struct Consumer
{
    void operator()()
    {
        std::unique_lock&lt;std::mutex&gt; lck{mtx};
        cv.wait(lck);

        auto cake = cake_queue.front();
        cake_queue.pop();

        std::cout &lt;&lt; std::this_thread::get_id() &lt;&lt; " consumed cake: " &lt;&lt; cake.id &lt;&lt; std::endl;
    }
};

int main()
{
    std::array&lt;std::jthread, 5&gt; consumers = {std::jthread{Consumer{}}, std::jthread{Consumer{}},
                                             std::jthread{Consumer{}}, std::jthread{Consumer{}},
                                             std::jthread{Consumer{}}};

    std::jthread cooker{Cooker{}};

    std::this_thread::sleep_for(10ms);

    cooker.request_stop();

    std::cout &lt;&lt; "done...left cakes count: " &lt;&lt; cake_queue.size() &lt;&lt; std::endl;

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-lock-free-solutions"><a class="header" href="#create-lock-free-solutions">create lock-free solutions</a></h1>
<p>these are not pure lock-free. some will contain blocking features which are new features of atomics. you can use atomics to develop a pure lock-free without touching any blocking ( wait - notify) or sleep ( mutex) features too if your problems is ok with it.</p>
<blockquote>
<p>atomics: pure lock-free. shared data type is atomic so no need a complex blocking / sleeping mechanism - let it go</p>
</blockquote>
<pre><code class="language-c++">#include &lt;atomic&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;

std::atomic&lt;int&gt; counter(0);

void increment(int n) {
    for (int i = 0; i &lt; n; ++i) {
        ++counter;
    }
}

int main() {
    const int num_threads = 10;
    const int increments_per_thread = 1000;

    std::vector&lt;std::thread&gt; threads;
    for (int i = 0; i &lt; num_threads; ++i) {
        threads.emplace_back(increment, increments_per_thread);
    }

    for (auto&amp; t : threads) {
        t.join();
    }

    std::cout &lt;&lt; "Final counter value: " &lt;&lt; counter.load() &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<blockquote>
<p>binary semaphore: blocking</p>
</blockquote>
<pre><code class="language-c++">
#include &lt;chrono&gt;
#include &lt;print&gt;
#include &lt;semaphore&gt;
#include &lt;thread&gt;

int main() {
    std::binary_semaphore sync{1};

    auto func = [&amp;] {
        sync.acquire();
        {
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
            std::println("{}", std::this_thread::get_id());
        }
        sync.release();
    };

    std::jthread j0{func}, j1{func}, j2{func};
}

</code></pre>
<blockquote>
<p>atomic_flag: blocking</p>
</blockquote>
<p>compare the memory_order naming with binary_semaphore func calls - parallel so you can understand memory orders better - follow the order</p>
<pre><code class="language-c++">#include &lt;atomic&gt;
#include &lt;cassert&gt;
#include &lt;chrono&gt;
#include &lt;print&gt;
#include &lt;semaphore&gt;
#include &lt;thread&gt;

int main() {
    std::atomic_flag flag{false};

    auto func = [&amp;] {
        // block the threads here and use system call to wake up them
        if (flag.test_and_set(std::memory_order_acquire))
            flag.wait(true, std::memory_order_acquire);

        {
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
            std::println("{}", std::this_thread::get_id());
        }

        flag.clear(std::memory_order_release);  // think these order like
                                                // calling aqcuire and release
                                                // calls of binary-semaphore
        flag.notify_one();
    };

    std::jthread j0{func}, j1{func}, j2{func};
}

</code></pre>
<blockquote>
<p>atomic: lock-free and blocking (new)</p>
</blockquote>
<pre><code class="language-c++">#include &lt;atomic&gt;
#include &lt;cassert&gt;
#include &lt;chrono&gt;
#include &lt;print&gt;
#include &lt;semaphore&gt;
#include &lt;thread&gt;

int main() {
    std::atomic_flag flag{false};

    auto func = [&amp;] {
        // block the threads here and use system call to wake up them
        if (flag.test_and_set(std::memory_order_acquire))
            flag.wait(true, std::memory_order_acquire);

        {
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
            std::println("{}", std::this_thread::get_id());
        }

        flag.clear(std::memory_order_release);  // think these order like
                                                // calling aqcuire and release
                                                // calls of binary-semaphore
        flag.notify_one();
    };

    std::jthread j0{func}, j1{func}, j2{func};
}

</code></pre>
<blockquote>
<p>condition variables: blocking - not suitable for lock-free schema but sharing it here as an example</p>
</blockquote>
<pre><code class="language-c++">
#include &lt;atomic&gt;
#include &lt;cassert&gt;
#include &lt;chrono&gt;
#include &lt;condition_variable&gt;
#include &lt;print&gt;
#include &lt;semaphore&gt;
#include &lt;thread&gt;

int main() {
    std::condition_variable cv;
    std::mutex m;
    bool cond{false};

    auto func = [&amp;] {
        std::unique_lock lck{m};
        cv.wait(lck, [&amp;cond] { return cond; });
        {
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
            std::println("{}", std::this_thread::get_id());
        }
        cv.notify_one();
    };

    cond = true;

    std::jthread j0{func}, j1{func}, j2{func};
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-memory-orderings-with-atomics"><a class="header" href="#use-memory-orderings-with-atomics">use memory orderings with atomics</a></h1>
<p>use atomics to order memory access in the code - you can think them a line or a point that connected each other and lets you to control when to read or write..</p>
<p>default memory order already does it's job so without using anything you can achieve it but costly. so by using relaxed, acquire and release you can challenge with performance.</p>
<p>we actually challenge against cpu reorderings by using memory ordering tools.</p>
<p>an example by copilot:</p>
<p>you have 2 threads means you have a line from from producer to consumer to sync the access to a shared mem. so one of them must allow to others to act.</p>
<p>in example; ready is strict and data is relaxed ( it's just out there)</p>
<p>ready uses release means that memory ops done before this cannot happen after this line ? didn't understand ? it tells cpu that don't reorder instructions as you wished; data HAS to be updated before me you mfckr. so cpu cannot reorder it -</p>
<p>data.store will always come before ready.store so it doesn't need an order -releaxed.</p>
<p>ready.load has to use acquire to get the update from line... and also data.load HAS to come after it...so CPU again cannot re-order here.</p>
<pre><code class="language-c++">
#include &lt;atomic&gt;
#include &lt;thread&gt;
#include &lt;iostream&gt;

std::atomic&lt;int&gt; data(0);
std::atomic&lt;bool&gt; ready(false);

void producer() {
    data.store(42, std::memory_order_relaxed);
    ready.store(true, std::memory_order_release);
}

void consumer() {
    while (!ready.load(std::memory_order_acquire));
    std::cout &lt;&lt; "Data: " &lt;&lt; data.load(std::memory_order_relaxed) &lt;&lt; std::endl;
}

int main() {
    std::thread t1(producer);
    std::thread t2(consumer);

    t1.join();
    t2.join();

    return 0;
}

</code></pre>
<p>or lambda...</p>
<pre><code class="language-c++">
int main() {
    std::atomic_int data{0};
    std::atomic_bool flag{false};

    auto produce = [&amp;] {
        data.store(10, std::memory_order_relaxed);
        flag.store(true, std::memory_order_release);
    };

    auto consume = [&amp;] {
        while (not flag.load(std::memory_order_acquire));

        auto result = data.load(std::memory_order_relaxed);
        std::cout &lt;&lt; result &lt;&lt; std::endl;
    };

    std::jthread j0(consume), j1{produce};
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-constexpr-literal-type"><a class="header" href="#create-constexpr-literal-type">create constexpr literal type</a></h1>
<p>constexpr is flexible with compile time executions which means that having constexpr doesn't mean the expression will be executed at compilation but at runtime if the conditions are not matched.</p>
<p>we can define our class types as literal type and use them with constexpr expressions.</p>
<pre><code class="language-c++">
template &lt;class T&gt;
    requires requires(T t0, T t1) { t0 + t1; }
struct my_literal {
    T _value;

    constexpr my_literal(T value): _value(value) {}
    constexpr operator T() const { return _value; }
};

template &lt;class T&gt;
constexpr my_literal&lt;T&gt; operator+(const my_literal&lt;T&gt; l1, const my_literal&lt;T&gt; l2) {
    return {l1._value + l2._value};
}

int main() {
    constexpr my_literal l1{2};
    constexpr my_literal l2{3};
    constexpr my_literal l3 = l1 + l2;

    static_assert(l3._value == 5, "failed");
    static_assert(std::is_literal_type_v&lt;m_literal&lt;int&gt;&gt;, "invalid");
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-multi-layered-template-types"><a class="header" href="#create-multi-layered-template-types">create multi layered template types</a></h1>
<ul>
<li>we can use different template type for inner type of class</li>
<li>we can capture outer type in inner type and apply operations on types</li>
</ul>
<h2 id="inner-type-with-different-template-type"><a class="header" href="#inner-type-with-different-template-type">inner type with different template type</a></h2>
<pre><code class="language-c++">
template &lt;typename T&gt;
struct outer {
    T value_;

    constexpr outer() = default;
    constexpr outer(T&amp;&amp; value): value_{std::forward&lt;T&gt;(value)} {}
    constexpr operator T() const { return value_; }

    template &lt;typename U&gt;
    struct rebind {
        using resut_t = outer&lt;U&gt;;
    };
};


template &lt;typename T, typename U&gt;
typename outer&lt;T&gt;::template rebind&lt;U&gt;::result_t get_result(T&amp;&amp; input) {
    return typename outer&lt;T&gt;::template rebind&lt;U&gt;::result_t{U{input}};
}

struct A {
    int value_;
};

struct B {
    A value_;
};

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const A&amp; input) {
    out &lt;&lt; " A:" &lt;&lt; input.value_  &lt;&lt; '\n';
    return out;
}

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const B&amp; input) {
    out &lt;&lt; "B: \n{ " &lt;&lt; input.value_ &lt;&lt; "}\n";
    return out;
}

int main() {
    A a{10};
    [[maybe_unused]] auto b = get_result&lt;A,B&gt;(std::move(a));
    std::cout &lt;&lt; b &lt;&lt; std::endl;
}

</code></pre>
<h2 id="capturing-outer-type-and-generating-new-types"><a class="header" href="#capturing-outer-type-and-generating-new-types">capturing outer type and generating new types</a></h2>
<pre><code class="language-c++">
template &lt;typename... Ts&gt;
struct outer {
    template &lt;typename U&gt;
    using push_front = outer&lt;U, Ts...&gt;;

    template &lt;typename U&gt;
    using push_back = outer&lt;Ts..., U&gt;;

    using type = outer&lt;Ts...&gt;;
};

int main() {
    outer&lt;int&gt;::push_front&lt;float&gt;::type o_front;
    outer&lt;int&gt;::push_back&lt;float&gt;::type o_back;

    static_assert(std::same_as&lt;decltype(o_front), outer&lt;float, int&gt;&gt;,
                  "invalid");
    static_assert(std::same_as&lt;decltype(o_back), outer&lt;int, float&gt;&gt;, "invalid");
}

</code></pre>
<p>another example</p>
<pre><code class="language-c++">
struct Any {
    template &lt;typename T&gt;
    Any(T&amp;&amp; item): _data{std::make_unique&lt;Inner&lt;std::decay_t&lt;T&gt;&gt;&gt;(std::forward&lt;T&gt;(item))},
    id(typeid(std::decay_t&lt;T&gt;)),
    id_ptr{Inner&lt;std::decay_t&lt;T&gt;&gt;::ptr} {}
    // template inner =&gt; data bunda tutalim...
private:
    struct Base{};
    template &lt;typename T&gt;
    struct Inner: Base {
        Inner(T&amp;&amp; value): _data{std::move(value)} {}
        T _data;
        static inline int* ptr = new int{};
    };
    template &lt;typename T&gt;
    friend T any_cast(Any const&amp; any);
    std::unique_ptr&lt;Base&gt; _data;
    std::type_index id;
    int* id_ptr;
};
template &lt;typename T&gt;
T any_cast(Any const&amp; any) {
    // if (any.id != typeid(std::decay_t&lt;T&gt;))
    if (any.id_ptr != Any::Inner&lt;std::decay_t&lt;T&gt;&gt;::ptr)
        throw std::logic_error{"type error"};

    return static_cast&lt;Any::Inner&lt;T&gt;*&gt;(any._data.get())-&gt;_data;
}
</code></pre>
<p>or (it seems i tried any impl after luxoft interview :d many times...)</p>
<pre><code class="language-c++">auto print(auto&amp;&amp;...args) {
    (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; std::endl;
}
struct Any {
    template &lt;typename T&gt;
    Any(T&amp;&amp; item): _data{std::make_unique&lt;Inner&lt;std::decay_t&lt;T&gt;&gt;&gt;(std::forward&lt;T&gt;(item))} , id(typeid(std::decay_t&lt;T&gt;)){}

private:
    struct Base{};
    template &lt;typename T&gt;
    struct Inner: Base {
        Inner(T&amp;&amp; value): _data{std::move(value)} {}
        T _data;
    };

    template &lt;typename T&gt;
    friend T any_cast(Any const&amp; any);

private:
    std::unique_ptr&lt;Base&gt; _data;
    std::type_index id;
};
template &lt;typename T&gt;
T any_cast(Any const&amp; any) {
    if (any.id != typeid(std::decay_t&lt;T&gt;))
        throw std::logic_error{"type error"};

    return static_cast&lt;Any::Inner&lt;T&gt;*&gt;(any._data.get())-&gt;_data;
}
int main() {
    Any a = 101;
    Any b = "hakan";
    Any c = 1.2f;
    int a_i = any_cast&lt;int&gt;(a);
    const char* b_p = any_cast&lt;const char*&gt;(b);
    float c_f = any_cast&lt;float&gt;(c);
    print(a_i);
    print(b_p);
    print(c_f);
    return 0;
}
</code></pre>
<p>and another outer : inner example</p>
<pre><code class="language-c++">
template &lt;typename T&gt;
struct Outer {
    template &lt;typename U&gt;
    struct Inner {
        template &lt;typename Z&gt;
        void nested();
    };
};
template &lt;typename T, typename U, typename Z&gt;
struct User {
    void call(typename Outer&lt;T&gt;::template Inner&lt;U&gt; const&amp; inner) {
        inner.template nested&lt;Z&gt;();
        // if its pointer inner-&gt;template nested&lt;Z&gt;();
    }
};

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-raw-pointers-correctly"><a class="header" href="#use-raw-pointers-correctly">use raw pointers correctly</a></h1>
<p>generally this topic is taught incorrectly. my teacher was russian and explained this topic using matrushka babies :) and as you can guess I didnt get it and years later I got it so I will explain it simply.</p>
<h2 id="whats-a-pointer-"><a class="header" href="#whats-a-pointer-">What's a pointer ?</a></h2>
<ul>
<li>pointer is a unique type in c/c++</li>
<li>pointer has it's own address like any other variables</li>
<li>pointer has 8 bytes (64bit) or 4 bytes (32bit) memory and it's unique as others</li>
<li>pointer's value is address value of the right side (variable, function...) { address value: uintptr_t or uint64_t : unsigned int value}</li>
<li>pointer stores the unsigned int (uintptr_t, uint64_t...) value of target memory address in it's memory address
<ul>
<li>it looks like <code>uintptr_t pointer_value = address_value_of(variable)</code></li>
<li><code>*</code> is special operator and when used with pointer it retrieves the data stored in the address it stores. if address is not valid it crashes - null pointer error.</li>
</ul>
</li>
<li>the pointed real data size equals to pointer type. if you created an int* then the data's size equals to sizeof(int)</li>
<li>pointer can point <strong>HEAP</strong> or <strong>STACK</strong> memory address</li>
<li>only new keyword creates a memory in the heap (c++)</li>
<li>only delete removes that memory - deallocation | releasing : whatever you feel good as definition</li>
<li>pointer of pointer can be created to point to another pointer or more...</li>
<li>pointer of pointer of pointer... can be created because T* is a variable like T ( int***, int**, int*, int...all are simple types)</li>
</ul>
<blockquote>
<p>Please read <a href="https://https://hgedek.github.io/howtocpp/different_memory_regions.html">memory_regions</a></p>
</blockquote>
<p><strong>does pointer mean a contiguous address space like array ?</strong></p>
<blockquote>
<p>NO. It only shows a simple address and by default start address of the block.</p>
</blockquote>
<p><strong>does pointer need always delete call ?</strong></p>
<blockquote>
<p>NO. if it's created with new then yes but if it's not then NO.</p>
</blockquote>
<p><strong>how does pointer know where to go when + (int) used ?</strong></p>
<blockquote>
<p>It's type is used to calculate the next address to jump</p>
</blockquote>
<pre><code class="language-c++">int* ptr =&gt; ptr + 1 =&gt; 4 bytes to go because sizeof(int) == 4bytes

char* ptr =&gt; ptr + 1 =&gt; 1 byte to go because sizeof(char) == 1byte

short* ptr =&gt; ptr + 1 =&gt; 2 bytes to go because sizeof(short) == 2bytes
...

</code></pre>
<h2 id="heap-pointer"><a class="header" href="#heap-pointer">heap pointer</a></h2>
<p>depends on new and delete in c++. heap size is larger than stack so whenever you need more memory space you will allocate it on heap.</p>
<pre><code class="language-c++">T: any type

// normal
T* ptr = new T();

delete ptr;

// array
T* ptr = new T[10]();

for (auto i = 0; i &lt; 10; ++i)
    ptr[i] = T{};

delete[] ptr;

// create
T** ptr_of_ptrs = new T*[10];
for (auto i = 0; i &lt; 10; ++i)
    ptr_of_ptrs[i] = new int();

// delete
for (auto i = 0; i &lt; 10; ++i)
    delete ptr[i];

delete[] ptr;

</code></pre>
<h2 id="stack-pointer"><a class="header" href="#stack-pointer">stack pointer</a></h2>
<p>doesn't use new or delete but only &amp; (address) of lvalues or rvalues. never call <strong>delete</strong> for it. It's used with polymorphic types generally.if it's not polymorphic you will lose derived type's data - no access to vtable etc...</p>
<p>stack memory is limited so be carefull with allocations on stack ( stackoverflow error is common - 64bit systems may have 8MB stack size)</p>
<blockquote>
<p>used to support polymorphic types</p>
</blockquote>
<blockquote>
<p>instead of *; &amp; can be also used for polymorphic types</p>
</blockquote>
<pre><code class="language-c++">T value = T{};
T* ptr = &amp;value;

struct base {
    virtual ~base() = default;
    virtual void foo() = 0;
};

struct derived_A: base {
    void foo() override {
        std::cout &lt;&lt; "derived_A"  &lt;&lt; std::endl;
    }
};
struct derived_B: base {
    void foo() override {
        std::cout &lt;&lt; "derived_B"  &lt;&lt; std::endl;
    }
};

void process(base* ptr) {
    ptr-&gt;foo();
}

void process_with_ref(base&amp; alias) {
    alias.foo();
}

int main() {
    derived_A da;
    derived_B db;

    process(&amp;da);
    process(&amp;db);

    // or
    base* ptr = &amp;da;
    process(ptr);
    ptr = &amp;db;
    process(ptr);
}


</code></pre>
<h2 id="contigous-pointer"><a class="header" href="#contigous-pointer">contigous pointer</a></h2>
<p>pointer is not an array type but like any other types (int, char, float) you can create an array from it.</p>
<pre><code class="language-c++">
int i = 0;

// stack based array
int ia[] = {1,2,3,4}; // signature of this =&gt; int(*)[4] =&gt; usable with templates

// assigned variable which means the address (uintptr_t or uint64_t int value) is set as value for this pointer
int* pi = &amp;i;

// assigned to first address of the array
int* pia = ia; // yes you can assign it directly to int* but this doesn't mean ia == pia

sizeof(pia) != sizeof(ia); // 8 != 16

const auto len = sizeof(ia) / sizeof(ia[0]);
for (auto i = 0; i &lt; len; i++)
    std::cout &lt;&lt; *(pia + i) &lt;&lt; std::endl; // jump to =&gt; addressof(ia[0]) + sizeof(int)* i and retrieve that value to ostream

// heap based array but still sizeof(ptr) == 8 (64bit)
// if it was an int arr[10] =&gt; sizeof(arr) would be 4*10 bytes (64bits)
int* ptr = new int[10];
// you've to manage it like array - compiler doesn't know anything about it

for (auto i = 0; i &lt; 10; ++i)
    ptr[i] = i;

delete [] ptr;

</code></pre>
<h2 id="constness-of-pointer"><a class="header" href="#constness-of-pointer">constness of pointer</a></h2>
<p>first of all: a pointer has a 2 const definitions</p>
<ul>
<li>constness of data which owned by the data pointer points</li>
<li>constness of pointer which owned by pointer itself</li>
</ul>
<p>let's check a normal int variable...</p>
<pre><code class="language-c++">
int x = 0; // =&gt; mutable
const int x = 0; // =&gt; immutable

</code></pre>
<p>let's check a pointer</p>
<pre><code class="language-c++">
int* ptr = nullptr;
// when reading left side of the pointer variable you should read like
// data owned &lt;= * =&gt; pointer owned
// so ?
// int : data is mutable
// {} : pointer it mutable

const int* ptr = nullptr;
// data =&gt; immutable
// ptr =&gt; mutable

const int* const ptr = nullptr;
// data =&gt; immutable
// ptr =&gt; immutable

</code></pre>
<h2 id="mutable-and-immutable-pointer"><a class="header" href="#mutable-and-immutable-pointer">mutable and immutable pointer</a></h2>
<p>mutable pointer:</p>
<pre><code class="language-c++">int x = 0, y = 0;

int* ptr = nullptr; // mutable pointer

// ptr's value is address value of others
// x is an int and it's value is something from int::min ~ int::max
// ptr is an int pointer and it's value `&amp;` =&gt; yes that's all... a pointer's value is &amp;{something here} =&gt; whatever &amp; returns

ptr = &amp;x; // let's assign a new value to ptr variable
// now ptr variable pointers to the x. as I told before; pointers have own address space and if you check it's memory; some uint64_t (64bit unsigned int) data is recored there which is the address of the x. if you get it and try to access it using `*` you can read x's value

ptr = &amp;y; // immutable so we can re-assign it without any issue

</code></pre>
<p>immutable pointer:</p>
<pre><code class="language-c++">
int x = 0, y = 0;

int* const ptr = &amp;x; // assignable only once

// ptr = &amp;y; // fails because ptr variable is const !

// but data is not const so

*ptr = 1; // writes to memory of x


// if both immutable ?

const int* const ptr = &amp;x;

// *ptr = 1; =&gt; fails
// ptr = &amp;y; =&gt; fails

</code></pre>
<h2 id="pointer-of-pointer"><a class="header" href="#pointer-of-pointer">pointer of pointer</a></h2>
<blockquote>
<p>pointers are lvalues too like any normal variables... so never think too complex about them... they are simple types with extra *</p>
</blockquote>
<pre><code class="language-c++">
int x = 0;

// stack memory types
int* p1 = &amp;x;
int** p2 = &amp;p1;
int*** p3 = &amp;p2;
int****p4 = &amp;p3;

-&gt; [] -&gt;  [] -&gt; []


int* p1 = new int(0);   // one level pointer =&gt; one node
delete p1;

int* pa1 = new int[5];  // one level pointer =&gt; 5 nodes =&gt; array type
delete []pa1;

int** p2 = new int*();  // two level pointer to keep one level pointer =&gt; one node
*p2 = new int(101); // assigned to that node
std::cout &lt;&lt; **p2 &lt;&lt; std::endl;

delete *p2;
delete p2;

int** pa2 = new int*[5];                          // 5 array of int*
for (int i = 0; i &lt; 5; ++i) pa2[i] = new int(i);  // int

for (int i = 0; i &lt; 5; ++i) delete pa2[i];

delete[] pa2;

</code></pre>
<p>extra: constness + void const* + void const* const* + reinterpret_cast + static_cast</p>
<pre><code class="language-c++">
int main() {

    int const* ptr: pointer to const int
    int const* const ptr: const pointer to const int
    int const* const* ptr: ptr to const pointer which points to const int

    int const* ptr = new int(1);
    int const* const* ptr2 = &amp;ptr;
    void const* vptr = ptr2;

    decltype(ptr2) ptr3 = static_cast&lt;decltype(ptr2)&gt;(vptr);
    std::cout &lt;&lt; **ptr3  &lt;&lt; std::endl;

}

int main() {
    int value = 101;
    void const* const ptr = &amp;value;
    void const* const* pptr = &amp;ptr;

    int const* iptr = static_cast&lt;int const*&gt;(*pptr);
    std::cout &lt;&lt; *iptr &lt;&lt; std::endl;

    // This will fail because static_cast cannot convert between unrelated
    // pointer types though they are same so we sure that they can be converted so
    // using reinterpret_cast is possible

    // const int* const* intPtr1 = static_cast&lt;const int* const*&gt;(pptr);

    const int* const* ipptr = reinterpret_cast&lt;const int* const*&gt;(pptr);
    std::cout &lt;&lt; **ipptr &lt;&lt; std::endl;
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="define-memory-mapped-address"><a class="header" href="#define-memory-mapped-address">define memory mapped address</a></h1>
<p>this is about how convert a numeric value which is actually value of the memory address to a pointer.</p>
<p>memory-mapped addresses are common topic if you're working in an embedded project... mem is well-known, limited and not changing. so they are constants and you need to read / write from there.</p>
<p>c/c++ beginners are afraid of pointers so much because it's not explained simply but opposite: to much info.</p>
<blockquote>
<p>pointer is a uintptr_t , uint64_t , uint32_t ( depends on the platform) integer !</p>
</blockquote>
<ul>
<li>a pointer has it's own address like any other variable</li>
</ul>
<p>int x = 0; // has memory address - a hex value
int* ptr = nullptr; // has a memory address - a hex value</p>
<pre><code class="language-c++">#include &lt;iostream&gt;

int main() {
    int x = 0;
    int* ptr = nullptr;

    std::cout &lt;&lt; (void*)&amp;x &lt;&lt; std::endl;
    std::cout &lt;&lt; (void*)&amp;ptr &lt;&lt; std::endl;
}

</code></pre>
<pre><code class="language-c++">0x7ffe1a9dffbc
0x7ffe1a9dffb0
</code></pre>
<p>int* ptr = &amp;x; =&gt; yes that's assigning a value to ptr variable now it has a value.</p>
<p>whatever...</p>
<p>what about memory-mapped address ?</p>
<pre><code class="language-c++">
// device info supported this to us

const uintptr_t BASE = 0x4000C0000;


volatile uint32_t&amp; RED = *reinterpret_cast&lt;volatile uint32_t*&gt;(BASE + 0x00);
volatile uin32_t&amp; BLUE = *reinterpret_cast&lt;volatile uint32_t*&gt;(BASE + 0x18);
// ...

// now we have some mutable variables to access some volatile memories... volatile: don't optimize this and this will be updated

int main() {
    RED = 0xFF;
    BLUE = 0x00;
    ...
}

</code></pre>
<blockquote>
<p>using void* : void* is just a pointer without type info and it's raw pointer with address data...cout supports to write it as uintptr_t so (void*) is a short-cut to print address info.</p>
</blockquote>
<pre><code class="language-c++">int main() {
    int x = 0;
    const uintptr_t addrx = *reinterpret_cast&lt;uintptr_t*&gt;(&amp;x);
    ...

    int* ptr = new int(0);
    const uintptr_t addrptr = *reinterpret_cast&lt;uintptr_t*&gt;(&amp;ptr);
    ...
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get-size-of-a-c-style-array"><a class="header" href="#get-size-of-a-c-style-array">get size of a c-style array</a></h1>
<p>this is a very common - simple solution</p>
<pre><code class="language-c++">
#include &lt;iostream&gt;

template &lt;typename T, size_t N&gt;
constexpr size_t size(const T (&amp;)[N]) {
    return sizeof(T) * N;
}

int main() {
    const char name[] = "hakan";
    const int values[] = {1, 2, 3, 4, 5};

    static_assert(size(name) == 6);
    static_assert(size(values) == 20);
}

</code></pre>
<p>and length of a null-ended string at compile time: ( strlen is runtime)</p>
<pre><code class="language-c++">
#include &lt;iostream&gt;

constexpr size_t length(const char* ptr) {
    auto len = 0;
    while (*(ptr + len) != '\0') len++;

    return len;
}

template &lt;size_t N&gt;
constexpr size_t length(const char (&amp;arr)[N]) {
    auto len = 0;
    while (arr[len] != '\0') {
        len++;
    }

    return len;
}

int main() {
    // broken texts
    constexpr const char name[] = "hakan\0gedek";
    constexpr const char* nptr = "hakan\0gedek";
    // normal null-ending
    constexpr const char name2[] = "hakan";
    constexpr const char* nptr2 = "hakan";

    static_assert(length(name) == 5);
    static_assert(length(nptr) == 5);
    static_assert(length(name2) == 5);
    static_assert(length(nptr2) == 5);
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-atomic_flag"><a class="header" href="#use-atomic_flag">use atomic_flag</a></h1>
<p>atomic_boolean type which is block-free guaranteed.</p>
<ul>
<li>test_and_set: sets the flag to true and returns old value</li>
<li>clear: set the flag to false</li>
<li>test: returns the current value</li>
<li>wait: takes the old value and locks the thread and if value changes then it releases it and notifies - removes the blockage of the waiting</li>
</ul>
<p>without wait: spins and consumes cpu</p>
<pre><code class="language-c++">
int main() {
    std::atomic_flag flag{};

    constexpr auto N = 1'000'000;
    auto counter = 0;
    {
        auto inc_counter = [&amp;] {
            for (auto i = 0; i &lt; N; ++i) {
                if (flag.test_and_set(std::memory_order_acquire))
                    ;
                ++counter;
                flag.clear(std::memory_order_release);
            }
        };

        std::jthread j0{inc_counter}, j1{inc_counter};
    }

    std::println("counter: {}", counter);

}

</code></pre>
<pre><code class="language-c++">counter: 1737966
</code></pre>
<p>wait: don't spin</p>
<pre><code class="language-c++">

int main() {
    std::atomic_flag flag{};

    constexpr auto N = 1'000'000;
    auto counter = 0;
    {
        auto inc_counter = [&amp;] {
            for (auto i = 0; i &lt; N; ++i) {
                // keep the loop to keep thread here
                while (flag.test_and_set(std::memory_order_acquire))
                    flag.wait(true);

                ++counter;
                flag.clear(std::memory_order_release);
                flag.notify_one();
            }
        };

        std::jthread j0{inc_counter}, j1{inc_counter};
    }

    std::println("counter: {}", counter);


</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-static-correctly"><a class="header" href="#use-static-correctly">use static correctly</a></h1>
<p>hide the data in the used scope - doesn't allow access from outside. uses special memory areas known as <code>static storage area</code> or <code>data segment</code>. if the variable is initialized then it's allocated in <code>initialized area</code> or <code>not initialized area</code>.</p>
<p>types:</p>
<ul>
<li>module: hide the data into translation unit, no access from outside ( module =&gt; .cpp file). it's shared by functions located in this TU(module).</li>
<li>function: hide the data into function scope and share it by this functions users.</li>
<li>class: hide the data into class scope and share it by class instances: also called as class variable or function.</li>
</ul>
<p>use cases:</p>
<ul>
<li>static variable allocated at the beginning of the program - before main called so it can be used to check some pre-conditions</li>
<li>they have a unique memory address so it's address can be used as identification for classes (id of class-type)</li>
<li>class functions are generally stateless and used as helper functions ( helper pattern)</li>
<li>static variable ( local to function or class ) is thread-safe</li>
</ul>
<blockquote>
<p>if you create a cpp file global (defined in cpp file out of anything); it's not implicitly static but it's external so other translation units can access it via extern keyword</p>
</blockquote>
<p>let's use it as identity of a class by implementing something like std::any !</p>
<pre><code class="language-c++">
struct variant {
private:
    struct base {
        virtual ~base() = default;
    };

    template &lt;class T&gt;
    struct data: base {
        constexpr data(T value): value_(std::forward&lt;T&gt;(value)) {}

        static inline int id = 0;

        constexpr operator T() const noexcept {
            return value_;
        }

    private:
        T value_;
    };

public:
    template &lt;class T&gt;
    constexpr variant(T value): data_{new data&lt;T&gt;(std::forward&lt;T&gt;(value))} {
        id_ = reinterpret_cast&lt;uintptr_t&gt;((void*)(&amp;data&lt;T&gt;::id));
    }

    ~variant() {
        delete data_;
    }

    base* data_;
    uintptr_t id_;

    template &lt;class T&gt;
    constexpr operator T() const {
        if(to_id(&amp;data&lt;T&gt;::id) != id_)
            throw std::invalid_argument{"not valid type"};

        return (*static_cast&lt;data&lt;T&gt;*&gt;(data_));
    }

private:
    constexpr uintptr_t to_id(void* addr) const {
        return reinterpret_cast&lt;uintptr_t&gt;(addr);
    }
};

int main() {
    variant v = 10;

    int i = v;

    assert(i == 10);

    // float f = v; =&gt; crashes
}

</code></pre>
<p>using static in template functions with constexpr to set that type's unique features as const</p>
<pre><code class="language-c++">
template &lt;class T, T val&gt;
struct constant {
    using type = T;

    static constexpr auto value = val;

    constexpr operator T() const noexcept { return value; }
};

namespace {
template &lt;class T, T val&gt;
constexpr auto constant_v = constant&lt;T, val&gt;::value;
}

int main(){
    // constant
    constexpr auto i1 = constant&lt;int, 1&gt;{};
    // int
    constexpr auto i10 = constant_v&lt;int, 10&gt;;

    std::cout &lt;&lt; typeid(i1).name() &lt;&lt; "\n" &lt;&lt; typeid(i10).name() &lt;&lt; std::endl;

    decltype(i1)::type i20 = constant_v&lt;int, 20&gt;;
}


</code></pre>
<pre><code class="language-c++">
// global_variable.cpp
#include &lt;vector&gt;

std::vector&lt;int&gt; globalVector; // Global variable with external linkage
static std::vector&lt;int&gt; staticVector; // Global variable with internal linkage



// main.cpp
#include &lt;vector&gt;

extern std::vector&lt;int&gt; globalVector; // Accessing the global variable from another file
// extern std::vector&lt;int&gt; staticVector; // This would cause a linker error

int main() {
    globalVector.push_back(1);
    // staticVector.push_back(1); // This is not accessible here
    return 0;
}

</code></pre>
<p>Global Variable (External Linkage)</p>
<blockquote>
<p>When you define a global variable (without static), it has external linkage and the following characteristics:</p>
</blockquote>
<ul>
<li>Lifetime: The variable is created when the program starts and destroyed when the program ends.</li>
<li>Scope: It is accessible from any translation unit (i.e., any .cpp file) that declares it using the extern keyword.</li>
</ul>
<p>Static Global Variable (Internal Linkage)</p>
<blockquote>
<p>When you define a global variable with the static keyword, it has internal linkage and the following characteristics:</p>
</blockquote>
<ul>
<li>Lifetime: The variable is created when the program starts and destroyed when the program ends, just like a global variable.</li>
<li>Scope: It is only accessible within the translation unit where it is defined. Other translation units cannot access it.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-semaphore-to-sync-threads"><a class="header" href="#use-semaphore-to-sync-threads">use semaphore to sync threads</a></h1>
<p>new c++ has semaphore type and it's really useful to sync the threads - using binary_semaphore we can sync threads without too much effort.</p>
<p>semaphores are used to control the number of the threads to access to resource. if the count &gt; 1 then using counting_semaphore is good but if it's only 0~1 then binary_semaphore is better.</p>
<p>a counting_semaphore example to organize threads:</p>
<blockquote>
<p>acquire =&gt; count - 1</p>
</blockquote>
<blockquote>
<p>release =&gt; count + 1</p>
</blockquote>
<pre><code class="language-c++">
template &lt;class T, int N&gt;
class bounded_buffer {
    std::array&lt;T, N&gt; buffer_;
    std::size_t read_pos_{};
    std::size_t write_pos_{};
    std::mutex m_{};

    std::counting_semaphore&lt;N&gt; n_empty_slots_{N};
    std::counting_semaphore&lt;N&gt; n_full_slots_{0};


    template &lt;typename U&gt;
    void do_push(U&amp;&amp; item) {
        n_empty_slots_.acquire();
        try {
            auto lock = std::unique_lock{m_};
            buffer_[write_pos_] = std::forward&lt;U&gt;(item);
            write_pos_ = (write_pos_ + 1) % N;
        } catch (...) {
            n_empty_slots_.release();
            throw;
        }

        n_full_slots_.release();
    }

public:
    void push(const T&amp; item) { do_push(item); }
    void push(T&amp;&amp; item) { do_push(std::move(item)); }

    void pop() {
        n_full_slots_.acquire();

        auto item = std::optional&lt;T&gt;{};

        try {
            auto lock = std::unique_lock{m_};
            item = std::move(buffer_[read_pos_]);
            read_pos_ = (read_pos_ + 1) % N;
        } catch(...) {
            n_full_slots_.release();
            throw;
        }

        n_empty_slots_.release();
        return std::move(*item);
    }
};

int main() {
    auto buffer = bounded_buffer&lt;std::string, 10&gt;{};
    auto sentinel = std::string{""};

    auto producer = std::thread([&amp;]{
        buffer.push("A");
        buffer.push("B");
        buffer.push("C");
        buffer.push(sentinel);
    });

    auto consumer = std::thread([&amp;]{
        while(true) {
            auto s = buffer.pop();
            if (s != sentinel) {
                std::println("{}", s);
            } else {
                break;
            }
        }
    });

    producer.join();
    consumer.join();
}

</code></pre>
<p>only one thread can access to critical section at once so using binary_semaphores is better</p>
<p>acquire: count =&gt; 0
release: count =&gt; 1</p>
<pre><code class="language-c++">
std::binary_semaphore smp{1};

using namespace std::chrono_literals;

void work(std::stop_token token) {
    while (not token.stop_requested()) {
        smp.acquire();
        std::cout &lt;&lt; std::this_thread::get_id() &lt;&lt; " in critical section"
                  &lt;&lt; std::endl;
        std::this_thread::sleep_for(1ms);
        smp.release();

        std::this_thread::yield();
    }
}

TEST(CPP, Book) {
    std::vector&lt;std::jthread&gt; ths;

    ths.emplace_back(work);
    ths.emplace_back(work);
    ths.emplace_back(work);

    std::this_thread::sleep_for(5ms);
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-partial-specialization-with-sfinae"><a class="header" href="#use-partial-specialization-with-sfinae">use partial specialization with sfinae</a></h1>
<p>sfinae uses std::enable_if to validate a condition to accept the special implementation. important point here is compiler always searches for our implementations. if it can validate it, it will not generate another definition. sfinae uses this principle.</p>
<pre><code class="language-c++">
template &lt;class T, class = void&gt; // if nothing given; use void
struct result_wrapper; // by default nothing defined


template &lt;class T&gt; // started with 2 and now same definition has only 1 variable but not 2
struct result_wrapper&lt;T, std::enable_if_t&lt;std::is_integral&lt;T&gt;&gt;&gt; { // by default, std::enable_if_t uses void and if condition is correct
// it will result as result_wrapper&lt;T, void&gt; {} =&gt; and we will use it as result_wrapper&lt;int&gt; with second is default void
    void display() { std::println("integral"); }
};

template &lt;class T&gt;
struct result_wrapper&lt;T, std::enable_if_t&lt;std::is_floating_point&lt;T&gt;&gt;&gt; {
    void display() {
        std::println("floating point");
    }
};

</code></pre>
<p>although T is part of the class definiton ( vector<int> is not same with vector<float>) we cannot use it like:</p>
<pre><code class="language-c++">
struct result {};

template &lt;class T&gt;
struct result{};

</code></pre>
<p>so we must always give a base version and build partial states on it like:</p>
<pre><code class="language-c++">
template &lt;class T, class U&gt;
struct result; // base state without definition because I want to use it only with selected types

template &lt;class T&gt;
struct result&lt;T, int&gt; {};

template &lt;class T&gt;
struct result&lt;T, float&gt; {};


// we can use result with T,[int, float] but not with T,double

</code></pre>
<blockquote>
<p>concepts with sfinae!</p>
</blockquote>
<pre><code class="language-c++">#include &lt;print&gt;

template &lt;class T, class = void&gt;
struct result_wrapper;

template &lt;class T&gt;
struct result_wrapper&lt;T, std::enable_if_t&lt;std::integral&lt;T&gt;&gt;&gt; {
    void display() { std::println("integral"); }
};

template &lt;class T&gt;
struct result_wrapper&lt;T, std::enable_if_t&lt;std::floating_point&lt;T&gt;&gt;&gt; {
    void display() { std::println("floating point"); }
};

template &lt;&gt;
struct result_wrapper&lt;void&gt; {
    void display() { std::println("void"); }
};

int main() {
    result_wrapper&lt;int&gt;{}.display();
    result_wrapper&lt;float&gt;{}.display();
    result_wrapper&lt;void&gt;{}.display();

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-partial-specialization-with-concepts"><a class="header" href="#use-partial-specialization-with-concepts">use partial specialization with concepts</a></h1>
<p>instead of using sfinae rules we can define partial specialization with concepts easly.</p>
<pre><code class="language-c++">
template &lt;class T&gt;
struct result;

template &lt;std::integral T&gt;
struct result&lt;T&gt; {};

template &lt;std::floating_point T&gt;
struct result&lt;T&gt; {};

int main() {
    result&lt;int&gt; ri;
    result&lt;float&gt; rf;
    // fails
    // result&lt;std::string&gt; rs;
}

</code></pre>
<p>Please check the note about concepts for details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="define-and-use-concepts"><a class="header" href="#define-and-use-concepts">define and use concepts</a></h1>
<p>concept: compilation time value - depends on conditions</p>
<p>possible methods to define a concept:</p>
<pre><code class="language-c++">
template &lt;typename T&gt;
concept C = requires (...) {...};

template &lt;typename T&gt;
concept C = type_traits...;

template &lt;typename T&gt;
concept C = constexpr...

</code></pre>
<pre><code class="language-c++">
struct Analogue;
struct Digital;

template &lt;typename T&gt;
concept Configurable = requires(T t, std::stringstream&amp; ss) {
    t.LoadConfig(ss);
    t.SaveConfig(ss);
};
template &lt;Configurable T&gt;
struct PointTrait : T {
    using type = T;
    using T::LoadConfig;
    using T::SaveConfig;
    // void LoadConfig(std::stringstream&amp; ss) {
    //     // some logic here then pass ss to...
    //     m_obj.LoadConfig(ss);
    // }
    // void SaveConfig(std::stringstream&amp; ss) {
    //     // some logic here then pass ss to ...
    //     m_obj.SaveConfig(ss);
    // }
};
struct Analogue {
    void LoadConfig(std::stringstream&amp; ss) { ss &lt;&lt; "Analogue::LoadConfig\n"; }
    void SaveConfig(std::stringstream&amp; ss) { ss &lt;&lt; "Analogue::SaveConfig\n"; }
};
struct Digital {
    void LoadConfig(std::stringstream&amp; ss) { ss &lt;&lt; "Digital::LoadConfig\n"; }
    void SaveConfig(std::stringstream&amp; ss) { ss &lt;&lt; "Digital::SaveConfig\n"; }
};
struct PointManager {
    using point_type = std::variant&lt;PointTrait&lt;Analogue&gt;, PointTrait&lt;Digital&gt;&gt;;
    std::vector&lt;point_type&gt; m_Points;
    template &lt;typename T&gt;
    void emplace(PointTrait&lt;T&gt;&amp;&amp; point) {
        m_Points.emplace_back(std::forward&lt;decltype(point)&gt;(point));
    }
    void SaveConfig(std::stringstream&amp; ss) {
        for (auto&amp; vP : m_Points) {
            std::visit([&amp;ss](auto&amp;&amp; point) { point.SaveConfig(ss); }, vP);
        }
    }
    void LoadConfig(std::stringstream&amp; ss) {
        for (auto&amp; vP : m_Points) {
            std::visit([&amp;ss](auto&amp;&amp; point) { point.LoadConfig(ss); }, vP);
        }
    }
};
int main() {
    PointManager manager;
    manager.emplace(PointTrait&lt;Digital&gt;{});
    manager.emplace(PointTrait&lt;Analogue&gt;{});
    std::stringstream ss;
    manager.SaveConfig(ss);
    manager.LoadConfig(ss);
    fmt::print("{}\n", ss.str());
}

</code></pre>
<h2 id="requires"><a class="header" href="#requires">requires</a></h2>
<pre><code class="language-c++">
requires (T v, int i) {
{
    v.foo(i) } -&gt; std::convertible_to&lt;int&gt;;
};

requires (T v, int i) {
    { v.fi(i) } -&gt; std::same_as&lt;int&gt;;
};

requires (Iter it) {
    typename Iter::value_type;
    {*it++} -&gt; std::same_as&lt;typename Iter::value_type&gt;;
};

//// requires chaining

requires (Iter it) {
    requires sizeof(it) &lt;= sizeof(void*);
};

requires (Iter it) {
    *it++; // op ( checking it allows it and we dont need to check return type etc )
    requires std::convertible_to&lt;decltype(*it++), typename Iter::value_type&gt;;
};

requires (Iter it) {
    *it++; // cond1 =&gt; i will use it next
    requires noexcept(*it++);
};

template &lt;typename Iter&gt;
concept iterator = requires (Iter iter) { *iter++; };

static_assert(iterator&lt;int*&gt;);

// nested

requires (Iter iter)
{
    *iter++;

    typename Iter::value_type;
    requires requires (typename Iter::value_type value) {
        *iter = value;
        value = *iter;
    };
};


template &lt;typename T&gt;
constexpr bool value() { return T::value; } // assumption

template &lt;typename T&gt;
constexpr bool req = requires {
    requires value&lt;T&gt;(); // use constexpr for a requires expression
};

constexpr bool v = req&lt;int&gt;;

template &lt;typename T&gt;
constexpr bool req = requires {
    T::value; // T has a value and...
    requires value&lt;T&gt;;
};

// So in general:
// requires {
// expression;
// requires predicate;
// };

</code></pre>
<blockquote>
<p>predicates</p>
</blockquote>
<pre><code class="language-c++">
predicates

template &lt;typename T&gt;
concept C = requires (T t) {}; // predicate

template &lt;typename T&gt;
requires requires (T t) {} || C&lt;T&gt;;

template &lt;typename T&gt;
requires (std::is_trivial_v&lt;T&gt;) || std::trivial&lt;T&gt;;

template &lt;typename T&gt;
requires (constexpr_is_trivial&lt;T&gt;) || std::trivial&lt;T&gt;;

</code></pre>
<blockquote>
<p>iterator concepts</p>
</blockquote>
<pre><code class="language-c++">template &lt;typename T&gt;
concept Comparable  = requires (T l, T r) {
    { l == r };
    { l != r };
};
template &lt;typename T&gt;
concept Incremental = requires (T obj) {
    { obj++ };
    { ++obj };
};
template &lt;typename T&gt;
concept Dereferencable = requires (T obj) {
    {*obj} -&gt; std::same_as&lt;typename T::value_type &amp;&gt;;
};
template &lt;typename T&gt;
concept ConstDereferencable = requires (T obj) {
    {*obj} -&gt; std::same_as&lt;typename T::value_type const&amp;&gt;;
}
</code></pre>
<blockquote>
<p>How to test a function call return type ?</p>
</blockquote>
<pre><code class="language-c++">template &lt;typename T, typename R&gt;
concept RetTest = requires (T obj) {
    {obj()} -&gt; std::same_as&lt;R&gt;;
};

template &lt;typename L, typename R&gt;
struct SameTypes {
    static const bool value = false; // initial for all different types
};
// compiler always use best...
template &lt;typename L&gt;
struct SameTypes&lt;L, L&gt; {
    static const bool value = true;
};
// partial specialization
template &lt;typename T, typename U&gt;
concept Same = SameTypes&lt;T,U&gt;::value;
template &lt;typename T&gt;
concept MultiArgs = requires (T l, T r) {
    l + r;
    { l + r }; // same
    l * r;
    {l + r} -&gt; Same&lt;T&gt;;
    {l * r} -&gt; Same&lt;T&gt;;
    {l.c_str()} -&gt; std::same_as&lt;const char*&gt;;
};
``
</code></pre>
<blockquote>
<p>compound requirement</p>
</blockquote>
<pre><code class="language-c++">
template &lt;typename T, typename R&gt;
concept RetFooTest = requires (T obj) {
    {obj.foo()} -&gt; std::same_as&lt;R&gt;; // foo must return R
};

template &lt;typename T, typename R&gt;
concept Return = requires(T obj) {
    {obj[0]} -&gt; std::same_as&lt;R&gt;;  // operator[] =&gt; returns R
};
struct S {
    int foo() const { return {}; }
};
struct SS {
};
template &lt;typename T, typename R&gt; requires RetFooTest&lt;T,R&gt;
void calc(T const&amp; obj) {
    print(obj.foo());
}

template &lt;typename L, typename R&gt;
struct SameTypes {
    static const bool value = false; // initial for all different types
};
// compiler always use best...
template &lt;typename L&gt;
struct SameTypes&lt;L, L&gt; {
    static const bool value = true;
};
// partial specialization
template &lt;typename T, typename U&gt;
concept Same = SameTypes&lt;T,U&gt;::value;
template &lt;typename T&gt;
concept MultiArgs = requires (T l, T r) {
    l + r;
    { l + r }; // same
    l * r;
    {l + r} -&gt; Same&lt;T&gt;;
    {l * r} -&gt; Same&lt;T&gt;;
    {l.c_str()} -&gt; std::same_as&lt;const char*&gt;;
};
</code></pre>
<blockquote>
<p>query if T has a sub type</p>
</blockquote>
<pre><code class="language-c++">
template &lt;typename T&gt;
concept HasType = requires () { typename T::type; };

template &lt;typename T&gt;
concept HasIterator = requires(T obj) { typename T::iterator; obj.begin(); };

// if you only need T in requires you dont need obj

</code></pre>
<blockquote>
<p>query if T supports something ?</p>
</blockquote>
<pre><code class="language-c++">template &lt;typename T, typename U&gt;
concept BasicMath = requires ( T l, U r) {
    l + r;
    l - r;
    l * r;
    l / r;
};
template &lt;typename T&gt;
concept HasIndex = requires (T obj) {
    obj[0];
};
template &lt;HasIndex T&gt;
auto Index(T const&amp; obj, size_t index) {
    return obj[index];
}
template &lt;typename T&gt;
concept HasStrIndex = requires (T obj) {
    obj[std::string{}];
};
template &lt;HasStrIndex T&gt;
auto Value(T&amp; obj, std::string const&amp; index) {
    return obj[index];
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-jthread-with-stop_token"><a class="header" href="#use-jthread-with-stop_token">use jthread with stop_token</a></h1>
<p>jthread is joinable thread and it calls join in it's destructor. also it supports stop_token class which allows us to control thread from outside.</p>
<p>jthread has 2 methods: <code>get_stop_token</code> and <code>get_stop_source</code></p>
<p>stop_token and stop_source are copyable types and best is using them as T const&amp; or T formats.</p>
<p>there are 3 classes useable with stopping</p>
<ul>
<li>stop_token: state object - state owner</li>
<li>stop_source: state contoller - can request to stop the thread</li>
<li>stop_callback: register to stop_token and called after stop requested</li>
</ul>
<blockquote>
<p>we can hold multiple stop_source to follow one token.</p>
</blockquote>
<blockquote>
<p>use jthread::get_stop_source to get the source object</p>
</blockquote>
<pre><code class="language-c++">int main() {
    
    std::jthread j0{[](std::stop_token token) {
        while (not token.stop_requested()) std::this_thread::yield();
    }};

    auto src = j0.get_stop_source();
    auto tok = src.get_token();

    [[maybe_unused]] auto s0 = std::stop_callback(tok, []{ std::cout &lt;&lt; "cb 0 called..." &lt;&lt; std::endl; });
    [[maybe_unused]] auto s1 = std::stop_callback(tok, []{ std::cout &lt;&lt; "cb 1 called..." &lt;&lt; std::endl; });

    std::this_thread::sleep_for(1ms);
    src.request_stop();

    std::this_thread::sleep_for(1s);
    std::cout &lt;&lt; "done..." &lt;&lt; std::endl;
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-promise"><a class="header" href="#use-promise">use promise</a></h1>
<p>future - promise allows us to create a channel between threads.</p>
<pre><code class="language-c++">
int main() {

    auto producer = [](std::promise&lt;int&gt; prom) {
        std::this_thread::sleep_for(std::choro::seconds(1));
        prom.set_value(1);
    };

    auto consumer = [](std::fututure&lt;int&gt; fut) {
        auto value = fut.get();
        std::println("value: {}", value);
    };

    auto prod = std::promise&lt;int&gt;{};
    auto fut = prod.get_future();

    std::jthread j0{producer, std::move(prod)}, j1{consumer, std::move(fut)};

    return 0;
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-deferred-and-adapted-locking"><a class="header" href="#use-deferred-and-adapted-locking">use deferred and adapted locking</a></h1>
<p>we can use tags to control locking in c++. std::unique_lock type is good for this use case.</p>
<ul>
<li>defer_lock_t: don't have the lock so postpone it later</li>
<li>adopt_lock_t: already have the lock - adapt to it here - continue to hold the lock</li>
</ul>
<p>std::lock/unlock will be used and they can be used multiple lockers.</p>
<pre><code class="language-c++">
std::mutex mtx;

void defer_work() {
    std::unique_lock lck{mtx, std::defer_lock};
    // do some stuff like IO or ...
    lck.lock(); // enter to critical section here
    {
        // we got the lock and entered to critical section here so we can access shared data between threads
    }
}

void adopt_work() {
    std::lock(mtx); // enter into critical section

    std::unique_lock lck{mtx, std::adopt_lock}; // keep hold of it
    // std::lock_guard lck{mtx, std::adopt_lock};
}

</code></pre>
<blockquote>
<p>mutex has also lock/unlock functions. you can use them too.</p>
</blockquote>
<blockquote>
<p>adopt_lock is used to transfer ownership of locking to lock types so we ensure releasing locks done correctly</p>
</blockquote>
<pre><code class="language-c++">
std::mutex m0, m2;

void task() {
    std::lock(m0, m2);

    // thread_safe area here

    std::lock_guard l0{m1, std::adopt_lock};
    std::lock_guard l1{m2, std::adopt_lock};

    // thread_safe area here
    // release the lock correctly when disposing the l0 and l2 after here
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-template-aliasing"><a class="header" href="#use-template-aliasing">use template aliasing</a></h1>
<h2 id="type"><a class="header" href="#type">Type</a></h2>
<pre><code class="language-c++">
template &lt;class T&gt;
struct MyType {
    using type = T;
};


template &lt;class T&gt;
using my_type_t = MyType&lt;T&gt;;

template &lt;class T&gt;
using type_t = typename MyType&lt;T&gt;::type;

</code></pre>
<h2 id="variable"><a class="header" href="#variable">Variable</a></h2>
<pre><code class="language-c++">template &lt;class T&gt;
constexpr auto generate() {
    return T(3.14f);
}

template &lt;class T&gt;
constexpr auto PI = generate&lt;T&gt;();

template &lt;class T&gt;
static const T min = T();

</code></pre>
<h2 id="function"><a class="header" href="#function">Function</a></h2>
<pre><code class="language-c++">
template &lt;class T&gt;
void foo(T&amp;&amp;) {}

template &lt;class T&gt;
auto bar = foo&lt;T&gt;; // const auto bar = foo&lt;T&gt;;

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-spaceship-operator-with-data-type"><a class="header" href="#use-spaceship-operator-with-data-type">use spaceship operator with data type</a></h1>
<p>returns strong_ordering, weak_ordering and partial_ordering</p>
<pre><code class="language-c++">
struct Data {
    int id_;
    std::string name_;
    double value_;
};

constexpr bool operator==(Data const&amp; lhs, Data const&amp; rhs) {
    return std::tie(lhs.id_, lhs.name_, lhs.value_) == std::tie(rhs.id_, rhs.name_, rhs.value_);
}

constexpr std::partial_ordering operator &lt;=&gt;(Data const&amp; lhs, Data const&amp; rhs) {
    return std::tie(lhs.id_, lhs.name_, lhs.value_) &lt;=&gt; std::tie(rhs.id_, rhs.name_, rhs.value_);
}

int main() {
    Data d0{1, "hakan", 1.2};
    Data d1 = d0;

    std::cout &lt;&lt;  (d0 == d1) &lt;&lt; std::endl;
    std::cout &lt;&lt;  (d0 &lt; d1)  &lt;&lt; std::endl;

    if (d0 &lt;=&gt; d1 == std::partial_ordering::equivalent)
        std::cout &lt;&lt; "equal" &lt;&lt; std::endl;

    if (d0 &lt;=&gt; d1 == std::strong_ordering::equivalent)
        std::cout &lt;&lt; "equal" &lt;&lt; std::endl;
}

</code></pre>
<p>if you don't have any custom types you can use default version of this function for your classes.</p>
<h2 id="how-it-relates-to-operator"><a class="header" href="#how-it-relates-to-operator">How it Relates to operator==:</a></h2>
<p>When you define operator&lt;=&gt;, the compiler can automatically generate the other relational operators, including operator==, based on the result of the spaceship operator.</p>
<ul>
<li>
<p>If the result of operator&lt;=&gt; is std::strong_ordering or std::weak_ordering, then operator== and operator!= are automatically generated.</p>
</li>
<li>
<p>If the result is std::partial_ordering, then only the other relational operators (&lt;, &lt;=, &gt;, &gt;=) are automatically generated. operator== and operator!= are not generated in this case, because not all values can be compared for equality.</p>
</li>
</ul>
<p>if you need to define custom equality logic ( not defaulting == to default) then you need to manually implement operator==.</p>
<p>and if you return partial_ordering result then you need to implement them if you need.</p>
<pre><code class="language-c++">
// I only implemented this and ...
struct MyS {
    int value;
    constexpr auto operator&lt;=&gt;(MyS const&amp;) const = default;
};

// compiler generated this one... cppinsights.io

struct MyS
{
  int value;
  inline constexpr std::strong_ordering operator&lt;=&gt;(const MyS &amp;) const /* noexcept */ = default;
  inline constexpr bool operator==(const MyS &amp;) const noexcept = default;
  // inline constexpr MyS(const MyS &amp;) noexcept = default;
  // inline constexpr MyS &amp; operator=(const MyS &amp;) noexcept = default;
};

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="define-is-and-has-relationships"><a class="header" href="#define-is-and-has-relationships">define is and has relationships</a></h1>
<p>Based on the using the features of the relationship.</p>
<p>Is: public inheritance.</p>
<p>Has: private or protected inheritance (private is better).</p>
<p>By using public inheritance we can provide all features from base to derived. Using derived pointers we can access them freely - no restrictions outside.</p>
<p>private/protected inheritance restricts external usage so it's not a <code>is-a</code> relationship but can provide <code>has-a</code> relationship. In this inheritance derived types can still own base's features and access them or we can create an instance of them and put it into fields.o</p>
<p>a simple is-a relationship</p>
<pre><code class="language-c++">
struct base {
    int id_{};
};

struct derived: base {
    std::string name_{};
};

derived d {0, "hakan gedek"};
base* bptr = &amp;d;

std::cout &lt;&lt; bptr-&gt;id_ &lt;&lt; std::endl;

derived* dptr = static_cast&lt;derived*&gt;(bptr);

std::cout &lt;&lt; dptr-&gt;name_ &lt;&lt; std::endl;

</code></pre>
<p>using concepts <code>convertible_to</code> and <code>derived_from</code> to check if it's a <code>is-a</code> relationship.</p>
<p>public_derived =&gt; base: is-a relationship</p>
<pre><code class="language-c++">
struct base {
    int id{};
};

struct public_derived : base {
    std::string name{};
};

struct private_derived : private base {
    std::string name{};
}

int main() {
    std::cout &lt;&lt; std::boolalpha
              &lt;&lt; std::derived_from&lt;public_derived, base&gt; &lt;&lt; std::endl;
    std::cout &lt;&lt; std::boolalpha
              &lt;&lt; std::derived_from&lt;private_derived, base&gt; &lt;&lt; std::endl;
    std::cout &lt;&lt; std::boolalpha
              &lt;&lt; std::convertible_to&lt;public_derived, base&gt; &lt;&lt; std::endl;
    std::cout &lt;&lt; std::boolalpha
              &lt;&lt; std::convertible_to&lt;base, public_derived&gt; &lt;&lt; std::endl;
    std::cout &lt;&lt; std::boolalpha
              &lt;&lt; std::convertible_to&lt;private_derived, base&gt; &lt;&lt; std::endl;
    std::cout &lt;&lt; std::boolalpha

}
</code></pre>
<pre><code class="language-c++">true
false
true
false
false
false

</code></pre>
<p>has-a ?</p>
<ul>
<li>if you prefer private inheritance you can hide base contents from outside and they can be only accessible by deriveds</li>
<li>if you prefer having an instance in fields; you should either expose all (public access) or define a friendship</li>
</ul>
<pre><code class="language-c++">
// forward-decl
struct owner;

// this type will not be used for creating any instance
struct hidden_base {
   protected:
    int id_;
    std::string name_;

    hidden_base(int id, std::string name) : id_(id), name_(name) {}

    friend owner;
};

// has-a relationship
struct derived : private hidden_base {
    derived(int id, std::string name) : hidden_base(id, name) {}
    void print() const { std::cout &lt;&lt; id_ &lt;&lt; " " &lt;&lt; name_ &lt;&lt; std::endl; }
};

struct owner {
    hidden_base obj;

    owner(int id, std::string name) : obj{id, name} {}

    void print() const {
        std::cout &lt;&lt; obj.id_ &lt;&lt; " " &lt;&lt; obj.name_ &lt;&lt; std::endl;
    }
};

int main()
{
    derived d{0, "hakan gedek"};
    d.print();

    owner u{1, "hakan gedek"};
    u.print();
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="define-a-value-type"><a class="header" href="#define-a-value-type">define a value type</a></h1>
<p>if a class/struct doesn't have any pointer types and only built-in types like (int, float, double, char const*); it's called value type and using one value type in another will not change this state.</p>
<blockquote>
<p>for value types you don't need to implement special functions like ctors, dtors, equal ops... just use = default or just ignore all.</p>
</blockquote>
<pre><code class="language-c++">
// ignored all implementations but this value type will implement them if they are necessary
struct Point {
    int x;
    int y;
};

// used default but as I said you don't need to
struct Rectangle {
    Point bottom_left;
    Point  right_right;

    Rectangle() = default;
    ~Rectangle() = default;
    Rectangle(Rectangle const&amp;) = default;
    Rectangle(Rectangle&amp;&amp;) = default;
    Rectangle&amp; operator=(Rectangle const&amp;) = default;
    Rectangle&amp; operator=(Rectangle&amp;&amp;) = default;
};

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="define-a-stateful-function"><a class="header" href="#define-a-stateful-function">define a stateful function</a></h1>
<p>generally functions are stateless - they allocate some stack memory for params, locals and process it's logic and ends. but what if I want to create a stateful function ?</p>
<ul>
<li>static: scoped based visibility so it will belong to function</li>
<li>functor: an object with operator() which acts like function. you can keep as many variables as you wish</li>
<li>lambda: functor type again but with different signature and ananoymous naming</li>
</ul>
<pre><code class="language-c++">
// static in function
void foo() {
    static int counter = 0; // belongs to this function
    // logic
}

// functor
struct Functor {
    int id_ {};
    std::string name_{};

    void operator()(int id, std::string name) {
        id_ = id;
        name_ = std::move(name);
        // logic
    }
}

// lambda
int id = 0;
std::string name = "hakan";

// created own variables and by default they are readonly (const) but by tagging them mutable we can edit them
// this generate an anoymous functor type with operator()const and wraps the variables with mutable so ...
auto l = [id_ = id, name_ = name](auto...args) mutable {
    id_ += 1;
    name_ += " gedek";
    // logic...
};

l();

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-friendship"><a class="header" href="#use-friendship">use friendship</a></h1>
<p>this topic is explained too detailed in cppreference - if you are intersted you can check it</p>
<blockquote>
<p>this is a method to skip encapsulation rules to access protected area of a class/struct { private, protected} from outside</p>
</blockquote>
<blockquote>
<p>you can forward declare a type during friendship</p>
</blockquote>
<pre><code class="language-c++">// forward decl here - global
class B;

class A {
    // local forward decl
    friend class C;
    // no need to use `class` but it doesn't fail even you used it
    friend B;
    void foo() { std::cout &lt;&lt; "A::foo" &lt;&lt; std::endl; };
};

class B {
    // not valid here so used `class` again
    friend class C;
    void foo() { std::cout &lt;&lt; "B::foo" &lt;&lt; std::endl; }
};

class C {
    void foo() {
        A{}.foo();
        B{}.foo();
    }

    friend int main();
    friend void print(C&amp;);
};

void print(C&amp; c) { c.foo(); }

int main() {
    C c;
    c.foo();

    print(c);
}

</code></pre>
<h2 id="template-friends"><a class="header" href="#template-friends">template friends</a></h2>
<p>SS and foo are templates...</p>
<pre><code class="language-c++">
template &lt;class&gt;
struct X;

template &lt;class T&gt;
void foo(T);

struct S {
    template &lt;class T&gt;
    friend class X;

    friend class X&lt;int&gt;;

    template &lt;class T&gt;
    friend void foo(T);

   private:
    int value = 101;
};

template &lt;&gt;
struct X&lt;S&gt; {
    S inst;
    void foo() { std::cout &lt;&lt; inst.value &lt;&lt; std::endl; }
};

template &lt;&gt;
void foo&lt;S&gt;(S inst) {
    std::cout &lt;&lt; inst.value &lt;&lt; std::endl;
}

int main() {
    S s;

    X&lt;S&gt; x;
    x.foo();

    foo(s);
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-equal_range-to-get-subrange"><a class="header" href="#use-equal_range-to-get-subrange">use equal_range to get subrange</a></h1>
<p>std::equal_range is an algorithm operation which returns a pair for iteretors holding beg and end of sub range in the <strong>sorted</strong> collection.</p>
<p>std::multimap, std::multiset, std::unordered_multimap, std::unordered_multiset has their own methods to do same job so if you're using these data structures then prefer their own methods but if you have a sorted collection then use std::equal_range to find a subrange.</p>
<pre><code class="language-c++">
int main() {

    {
        const std::string bytes = "abcdefggggggghijk";

        const auto [beg, end] = std::equal_range(bytes.begin(), bytes.end(), 'g');

        std::cout &lt;&lt; "g count: " &lt;&lt; std::distance(beg, end) &lt;&lt; std::endl;
    }
    {
        const auto numbers[] = {1,2,3,4,4,4,4,5,6,7};

        const auto [beg, end] = std::equal_range(numbers.begin(), numbers.end(), 4);

        std::cout &lt;&lt; "4 count: " &lt;&lt; std::distance(beg, end) &lt;&lt; std::endl;
    }
    {
        const char ptr[] = "abcdeeeefghijk";

        const auto [beg, end] = std::equal_range(std::begin(ptr), std::end(ptr), 'e');

        std::cout &lt;&lt; "e count: " &lt;&lt; std::distance(beg, end) &lt;&lt; std::endl;
    }
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-if-constexpr"><a class="header" href="#use-if-constexpr">use if constexpr</a></h1>
<p>use it with compilation time variables like template header types - variables, constexprs, true constants. by conditions at compilation time it decides which section of the if/else to run and returns the result at compilation time.</p>
<pre><code class="language-c++">#include &lt;type_traits&gt;
#include &lt;iostream&gt;

template &lt;typename T&gt;
void print(T value) {
    if constexpr (std::is_integral_v&lt;T&gt;) {
        std::cout &lt;&lt; "integral type: " &lt;&lt; value &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; "non-integral type: " &lt;&lt; value &lt;&lt; std::endl;
    }
}

int main() {
    print(42);       // Integral type
    print(3.14);     // Non-integral type
    print("Hello");  // Non-integral type

    return 0;
}

</code></pre>
<pre><code class="language-c++">
template &lt;typename T&gt;
auto foo(T value ) {
    if constexpr (std::is_same_v&lt;T,bool&gt;)
        return "true";
    else if constexpr (std::is_same_v&lt;T,int&gt;)
        return 0;
    else
        return 1.2f;
}


</code></pre>
<pre><code class="language-c++">
struct MyS {
    int value;
    std::string name;
    float height;
};

enum Index { Value, Name, Height };

template &lt;Index I&gt;
constexpr decltype(auto) get(MyS const&amp; s) {
    if constexpr (I == Index::Value)
        return s.value;
    else if constexpr (I == Index::Name)
        return s.name;
    else
        return s.height;
}

int main()
{
    MyS s{10, "hakan", 1.81f};

    assert(get&lt;Index::Value&gt;(s), 10);
    assert(get&lt;Index::Name&gt;(s), "hakan");
    assert(get&lt;Index::Height&gt;(s), 1.81f);

    return 0;
}

</code></pre>
<pre><code class="language-c++">
constexpr auto foo(size_t value) { return value * 10; } // constant expression

template &lt;typename T&gt;
constexpr decltype(auto) is_ptr(T&amp;&amp; in) {
    if constexpr (std::is_pointer_v&lt;T&gt;)
        return true;
    else return false;
}

template &lt;size_t N, typename T&gt;
constexpr auto foo1(T value) {
    if constexpr (N &gt; 0)
        return value * N;
    else
        return value;
}

// same impl to show that if constexpr ( logic) =&gt; logic needs to be calculated
// as a constexpr
template &lt;size_t N&gt;
constexpr auto check_value() {
    return N &gt; 0;
}

template &lt;size_t N, typename T&gt;
constexpr auto foo2(T value) {
    if constexpr (check_value&lt;N&gt;())
        return value * N;
    else
        return value;
}

</code></pre>
<p>a string conversion wrapper:</p>
<pre><code class="language-c++">struct from_string {
    const std::string value;
    from_string() = delete;
    from_string(const char* str) : value{str} {}
    from_string(std::string&amp;&amp; str) : value{std::move(str)} {}
    from_string(std::string const&amp; str) : value{str} {}
    template &lt;typename T&gt;
    operator T() const {
        if constexpr (std::is_same_v&lt;T, float&gt;)
            return std::stof(value);
        else
            return std::stoi(value);
    }
    template &lt;typename T&gt;
    inline void foo(T);
};
template &lt;&gt;
inline void from_string::foo&lt;int&gt;(int) {}
template &lt;&gt;
inline void from_string::foo&lt;float&gt;(float) {}
</code></pre>
<p>if constexpr is connected to template header constants to evaluated at compilation time.</p>
<pre><code class="language-c++">template &lt;class T&gt;
constexpr auto foo(T const&amp; arg) {
    if constexpr (std::is_arithmetic_v&lt;T&gt;) {
        std::println("yes");
    }
}

int main() {
    foo(1);
    foo("hakan");
}

</code></pre>
<p>safe-cast example from high performance programming 2.ed, i took as example into my notes...</p>
<pre><code class="language-c++">#include &lt;cmath&gt;
#include &lt;print&gt;
#include &lt;cassert&gt;
#include &lt;type_traits&gt;

enum class never : int {};

template &lt;class T&gt;
constexpr auto make_false() {
    return false;
}

template &lt;class Dst, class Src&gt;
constexpr auto safe_cast(const Src&amp; v) -&gt; Dst {
    constexpr auto is_same_type = std::same_as&lt;Dst, Src&gt;;
    constexpr auto is_pointer_to_pointer =
        std::is_pointer_v&lt;Dst&gt; &amp;&amp; std::is_pointer_v&lt;Src&gt;;
    constexpr auto is_float_to_float =
        std::is_floating_point_v&lt;Src&gt; &amp;&amp; std::is_floating_point_v&lt;Dst&gt;;
    constexpr auto is_number_to_number =
        std::is_arithmetic_v&lt;Src&gt; &amp;&amp; std::is_arithmetic_v&lt;Dst&gt;;
    constexpr auto is_intptr_to_ptr =
        (std::is_same_v&lt;intptr_t, Src&gt; || std::is_same_v&lt;uintptr_t, Src&gt;) &amp;&amp;
        std::is_pointer_v&lt;Dst&gt;;
    constexpr auto is_ptr_to_intptr =
        (std::is_same_v&lt;intptr_t, Dst&gt; || std::is_same_v&lt;uintptr_t, Dst&gt;) &amp;&amp;
        std::is_pointer_v&lt;Src&gt;;

    if constexpr (is_same_type) {
        return v;
    } else if constexpr (is_intptr_to_ptr || is_ptr_to_intptr) {
        return reinterpret_cast&lt;Dst&gt;(v);
    } else if constexpr (is_pointer_to_pointer &amp;&amp;
                         std::is_convertible_v&lt;Src, Dst&gt;) {
        return static_cast&lt;Dst&gt;(v);
    } else if constexpr (is_float_to_float) {
        auto casted = static_cast&lt;Dst&gt;(v);
        auto casted_back = static_cast&lt;Src&gt;(casted);
        assert(!std::isnan(casted_back) &amp;&amp; !std::isinf(casted_back));
        return casted;
    } else if constexpr (is_number_to_number) {
        auto casted = static_cast&lt;Dst&gt;(v);
        [[maybe_unused]] auto casted_back = static_cast&lt;Src&gt;(casted);
        assert(casted == casted_back);
        return casted;
    } else {
        static_assert(make_false&lt;Src&gt;(), "cast error");
        return never{};
    }
}

int main() {
    [[maybe_unused]] auto x = safe_cast&lt;int&gt;(1.2f);
    [[maybe_unused]] auto y = safe_cast&lt;int&gt;(nullptr); // fails
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-if-consteval"><a class="header" href="#use-if-consteval">use if consteval</a></h1>
<p>consteval: immediate function which will produce a constant expression</p>
<p>func: if call is for creating a constant expression (compile time exec) then if consteval will be activated or else.</p>
<pre><code class="language-c++">consteval int formulate(int x) { return x * 10; }

constexpr int func(int x) {
    if consteval {
        return formulate(x);
    } else {
        return 0;
    }
}

int main() {
    std::cout &lt;&lt; func(100) &lt;&lt; std::endl;

    constexpr int val = func(1);
    static_assert(val == 10);
}
</code></pre>
<p>if you want to divide your logic into compile time / run time; you can split it with if consteval {} to wrap the compile time path.</p>
<pre><code class="language-c++">if consteval + else
if !consteval + else
</code></pre>
<blockquote>
<p>constant expression are very good with computation &amp; mathematical operations. their inputs depends on constants so they are not very flexible with generic OOP use cases</p>
</blockquote>
<pre><code class="language-c++">#include &lt;iostream&gt;

template &lt;int N&gt;
constexpr auto total(const int (&amp;a)[N]) {
    if consteval {
        int value = 0;
        for (auto i = 0; i &lt; N; i++) value += a[i];
        return value;
    } else {
        return 0;
    }
}

int main() {
    constexpr int data[] = {1, 2, 3, 4, 5};
    constexpr auto tot = total(data);
    static_assert(tot != 0);
    std::cout &lt;&lt; tot &lt;&lt; std::endl;

    int data2[] = {1, 2, 3, 4};
    auto tot2 = total(data2);
    std::cout &lt;&lt; tot2 &lt;&lt; std::endl;

</code></pre>
<blockquote>
<p>compile_time and run_time options can be created in a constexpr function and if consteval can direct args to a consteval function to calculate : this is good approach.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sync-threads-with-barrier-and-latch"><a class="header" href="#sync-threads-with-barrier-and-latch">sync threads with barrier and latch</a></h1>
<p>barrier and latch are new tools to synch threads by drawing a line at a point somewhere in the program and ask them to come there all. one of them is reusable and other is only usable once.</p>
<p>barrier: re-usable
latch: not re-usable</p>
<p>cppreference example shows that after on-completion method runs; you can re-use barrier again to block all</p>
<pre><code class="language-c++">#include &lt;barrier&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;syncstream&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;

int main()
{
    const auto workers = {"Anil", "Busara", "Carl"};

    auto on_completion = []() noexcept
    {
        // locking not needed here
        static auto phase =
            "... done\n"
            "Cleaning up...\n";
        std::cout &lt;&lt; phase;
        phase = "... done\n";
    };

    std::barrier sync_point(std::ssize(workers), on_completion);

    auto work = [&amp;](std::string name)
    {
        std::string product = "  " + name + " worked\n";
        std::osyncstream(std::cout) &lt;&lt; product;  // ok, op&lt;&lt; call is atomic
        sync_point.arrive_and_wait();

        product = "  " + name + " cleaned\n";
        std::osyncstream(std::cout) &lt;&lt; product;
        sync_point.arrive_and_wait();
    };

    std::cout &lt;&lt; "Starting...\n";
    std::vector&lt;std::jthread&gt; threads;
    threads.reserve(std::size(workers));
    for (auto const&amp; worker : workers)
        threads.emplace_back(work, worker);
}


</code></pre>
<p>dice example - HPCPP example</p>
<pre><code class="language-c++">
#include &lt;barrier&gt;
#include &lt;print&gt;
#include &lt;random&gt;
#include &lt;thread&gt;

int main() {
    auto random_int = [](int min, int max) {
        thread_local static auto engine =
            std::default_random_engine{std::random_device{}()};

        auto dist = std::uniform_int_distribution{min, max};
        return dist(engine);
    };

    constexpr auto N = 5;

    auto done = false;
    auto dice = std::array&lt;int, N&gt;{};
    auto threads = std::vector&lt;std::thread&gt;{};
    auto n_turns = 0;

    auto check_result = [&amp;] {
        ++n_turns;
        auto is_six = [](int i) { return i == 6; };
        done = std::all_of(std::begin(dice), std::end(dice), is_six);
    };

    auto barr = std::barrier{N, check_result};

    for (auto i = 0; i &lt; N; ++i) {
        threads.emplace_back([&amp;, i] {
            while (!done) {
                dice[i] = random_int(1, 6);
                barr.arrive_and_wait();
            }
        });
    }

    for (auto&amp;&amp; th : threads) th.join();

    std::println("{}", n_turns);
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-attributes"><a class="header" href="#use-attributes">use attributes</a></h1>
<p>they're used to help compiler with some special situations. like deprecated , fallthrough etc.</p>
<ul>
<li>[[nodiscard]]</li>
<li>[[fallthrough]]</li>
<li>[[deprecated]]</li>
<li>[[maybe_unused]]</li>
<li>[[noreturn]]</li>
</ul>
<blockquote>
<p>mixed</p>
</blockquote>
<pre><code class="language-c++">
// attributes are compiler directives
// helps it also block warnings
// function deprecated
[[deprecated]] void foo() {}
// deprecated type
struct [[deprecated]] S {};
[[deprecated]] constexpr auto value = 10;
void function(int selector) {
    switch (selector) {
        case 1:  // merging not falling through !
        case 2:
            std::cout &lt;&lt; "merged" &lt;&lt; std::endl;
            [[fallthrough]];
        case 3:
            std::cout &lt;&lt; "case 3\n";
            [[fallthrough]];
        case 4:
            std::cout &lt;&lt; "case 4\n";
    }
}
// param not used
void bar([[maybe_unused]] size_t length) {
    std::cout &lt;&lt; "hello world" &lt;&lt; std::endl;
    // not used...
    [[maybe_unused]] size_t id = 10;
}
// this return cannot be discarded
[[nodiscard]] int getId() { return 0; }
// this type cannot be discarded
struct [[nodiscard]] S2 {};
S2 getS2() { return {}; }
// cant use return even for void
[[noreturn]] void foo2() { return; }
[[noreturn]] void foo3() { exit(0); }
int main() {
    // nodiscard
    // noreturn
    S s;
    std::cout &lt;&lt; value &lt;&lt; std::endl;
    function(1);
    function(4);
    bar(10);
    int id = getId();
    S2 s2 = getS2();
    return 0;
}

</code></pre>
<blockquote>
<p>fallthrough</p>
</blockquote>
<pre><code class="language-c++">
case 'a':
    fmt::println("a");
    [[fallthrough]];
case 'b':
    fmt::println("b"):
    [[fallthrough]];
case 'c':
    fmt::println("c");
    [[fallthrough]];
...

</code></pre>
<p>another...</p>
<pre><code class="language-c++">int main() {
    std::string name = "hakan";
    switch (auto pos = name.find('a'); pos) {
        case 0:
        case 1:
            print("at first half");
            [[fallthrough]];   // don't forget ; at the end of it
        case 2:
        case 3:
        case 4:
            print("item found at ", pos);
    }
    return 0;
}
</code></pre>
<blockquote>
<p>maybe_unused</p>
</blockquote>
<pre><code class="language-c++">void foo() {
    [[maybe_unused]] int step = 0;
    if (1) {
        fmt::println("hakan");
    }
}
int main() { foo(); }

</code></pre>
<p>another...</p>
<pre><code class="language-c++">struct [[maybe_unused]] Unused {
    [[maybe_unused]] Unused&amp; operator=(const Unused&amp; other) {
       return *this;
    }
};

void foo([[maybe_unused]] const char* ptr) {
    print("dummy");
}

int main() {
    [[maybe_unused]] int size = 0;
    print("forgot to use variables");
    return 0;
}

</code></pre>
<blockquote>
<p>deprecated</p>
</blockquote>
<pre><code class="language-c++">[[deprecated]] void foo(const char* ptr) {
    print(ptr);
}
struct [[deprecated]] S {};
struct SS {
    [[deprecated]]
    void foo(const char* ptr) {}
};
enum [[deprecated]] Enum {
    A,
    B,
    C
}
</code></pre>
<blockquote>
<p>nodiscard</p>
</blockquote>
<pre><code class="language-c++">
 [[nodiscard]] const char*  getUserName() { return "hakan"; }
 struct [[nodiscard]] S {};
 S getS() { return S{}; }
enum [[nodiscard]] Enum {
    A,
    B,
    C
};
Enum getEnum() { return Enum::A; }
int main() {
    getUserName(); // error
    getS(); // error
    getEnum(); // error
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-variadic-templates"><a class="header" href="#use-variadic-templates">use variadic templates</a></h1>
<blockquote>
<p><code>template &lt;class...Ts&gt;</code> is classic form of variadic template</p>
</blockquote>
<blockquote>
<p>we can apply patterns to expansion. basic is using arg0,arg1... or combining them with a func call like func(arg0), func(arg1)...</p>
</blockquote>
<blockquote>
<p>new c++ supports <code>void foo(auto ...args)</code> form</p>
</blockquote>
<blockquote>
<p>... =&gt; pack of expansion: {},{},{},{},{},...</p>
</blockquote>
<pre><code class="language-c++">
template &lt;typename ...Ts&gt;
struct S;

// can generate:

struct S{};

template &lt;typename  T&gt;
struct S&lt;T&gt; {};

template &lt;typename T, typename U&gt;
struct S&lt;T, U&gt; {};

template &lt;typename T, typename U, typename K&gt;
struct S&lt;T,U,K&gt; {};

...

</code></pre>
<blockquote>
<p>creating template variable from args...</p>
</blockquote>
<pre><code class="language-c++">
template &lt;class ...Ts&gt;
constexpr auto size_of_args = sizeof...(Ts);

// template variadict variable
// good for compile time coding
template &lt;int...args&gt;
constexpr auto int_list= std::initializer_list&lt;int&gt;{args...};

// int_list&lt;1&gt; != int_List&lt;1,2&gt; =&gt; template shared but they're different values

int main() {
    int_list&lt;1&gt;;
    int_list&lt;1,2&gt;;
    int_list&lt;1,2,3&gt;;
    int_list&lt;1,2,3,4,5&gt;;


    std::cout &lt;&lt; int_list&lt;1&gt;.size() &lt;&lt; ":" &lt;&lt; int_list&lt;1,2&gt;.size() &lt;&lt; std::endl;

    return 0;
}

</code></pre>
<blockquote>
<p>let's store args... in collections</p>
</blockquote>
<pre><code class="language-c++">// single type in collection
template &lt;class T, class... Ts&gt;
constexpr auto func(T arg, Ts... args) {
    const std::initializer_list&lt;T&gt; l{arg, args...};
    const std::vector&lt;T&gt; v{arg, args...};
    const std::array&lt;T, sizeof...(args) + 1&gt; arr{arg, args...};
}

// different types in collection
template &lt;class...Ts&gt;
constexpr auto func2(Ts...args) {
// tuple
const std::tuple&lt;Ts...&gt; tpl1{args...};
const auto tpl2 = std::make_tuple(args...);

    // vector with any
    const std::vector&lt;std::any&gt; vec{args...};

}

int main() {
    func(1, 2, 3, 4, 5);
    func(1, 5);
    func(1);

    func2(1);
    func2(1, 2.2f);
    func2(1, 2.3f, "hakan gedek");
}


</code></pre>
<blockquote>
<p>extending the expansion and storing the result of call (std::cout &lt;&lt; arg) in an array</p>
</blockquote>
<pre><code class="language-c++">
template &lt;class...Ts&gt;
void func(Ts...args)
{
    const size_t size = sizeof...(args) + 2;
    int res[size] = {1, args..., 2};
    int dummy[sizeof...(Ts)] = {(std::cout &lt;&lt; args, 0)...};

    for (auto x: dummy)
        std::cout &lt;&lt; x &lt;&lt; " ";
}
</code></pre>
<pre><code class="language-c++">
template &lt;class ...Ts&gt;
void foo(Ts...args)
{
    const int size = sizeof...(Ts) + 2;
    int list[size] = {1, args..., 2};
    for (auto item : list)
        std::cout &lt;&lt; item &lt;&lt; " ";
    std::cout &lt;&lt; '\n';

    for (auto item : {args...})
        std::cout &lt;&lt; item &lt;&lt; " ";
}

int main() {
    foo(1,2,3,4,5);

    return 0;
}

</code></pre>
<p>variadic formatted printing...</p>
<pre><code class="language-c++">#include &lt;print&gt;

void tprintf(const char *format) { std::print("{}", format); }

template &lt;typename T, typename... TArgs&gt;
void tprintf(const char *format, T value, TArgs... args) {

    for (; *format != '\0'; format++) {
        if (*format == '%') {
            std::print("{}", value);
            tprintf(format + 1, args...);

            return;
        }
        std::print("{}", *format);
    }
}

int main() { tprintf("% world % %\n", "hello", '!', 10); }

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-constexpr"><a class="header" href="#use-constexpr">use constexpr</a></h1>
<p>used to create compilation time constants which are useful in template params, array sizes etc. <code>true constants</code></p>
<p>a variable or a function can be defined as a constexpr and their values will be set at compilation time if possible or they can't be used as true constants.</p>
<blockquote>
<p>constexpr =&gt; const + expr =&gt; an adjective</p>
</blockquote>
<p><strong>what's expr?</strong></p>
<blockquote>
<p>expression means something yields a result !</p>
</blockquote>
<pre><code class="language-c++">
// arithmetic ops
auto result = 5 + 4;

// logical ops
bool isEqual = (5 == 5);

// assignment ops
int x = 10;

// function calls
int sum = call(1,2);

</code></pre>
<pre><code class="language-c++">constexpr auto result = 5 + 4;
static_assert(result == 9);

constexpr auto eq = (5 == 5);
static_assert(eq);

constexpr int x = 10;
static_assert( x == 10);

constexpr auto call(int x, int y) { return x + y; }
constexpr auto sum = call(1, 4);
static_assert( sum == 5);

</code></pre>
<blockquote>
<p>using constexpr doesn't guarantee that your expression will be evaluated at compilation time</p>
</blockquote>
<blockquote>
<p>heap types are invalid for constexpr like heap-pointers, std::string, std::vector etc...</p>
</blockquote>
<blockquote>
<p>{std::string, std::vector} has some specific cases (if size &lt; N then use stack mem) which allows constexpr</p>
</blockquote>
<pre><code class="language-c++">
constexpr std::vector&lt;std::string_view&gt; split_sv(std::string_view strv, std::string_view delims = " ") {
    std::vector&lt;std::string_view&gt; output;
    size_t first = 0;

    while (frist &lt; strv.size()) {
        const auto second = strv.find_first_of(delims, first);
        if (first != second) {
            output.emplace_back(strv.substr(first, second - first));
        }
        if (second == std::string_view::npos) brea;
        first = second + 1;
    }

    return output;
}

constexpr const char* brk(const char* ptr, const char* delims) {
    while (*ptr != '\0') {
        const char* it = delims;
        while (*it != '\0') {
            if (*it == *ptr) return ++ptr;
            it++;
        }

        ptr++;
    }

    return ptr;
}

constexpr size_t num_of_words(const char* ptr, const char* delims = " ") {
    size_t count = 0;
    do {
        ptr = brk(ptr, delims);
        if (*ptr != '\0') count++;
    } while(*ptr != '\0');

    return ++count;
}

constexpr size_t num_of_words(std::string_view str) {
    const auto words = split_sv(str);
    return words.size();
}

</code></pre>
<blockquote>
<p>more examples...</p>
</blockquote>
<pre><code class="language-c++">
constexpr auto calc(const std::array&lt;int, 10&gt;&amp; data) {
    auto total = 0;
    for (auto v : data) total += v;
    return total;
}
int main() {
    constexpr std::array&lt;int, 10&gt; arr = {1, 2, 3, 4, 5};
    constexpr auto total = calc(arr);
    static_assert(total == 15);
    return 0;
}
</code></pre>
<blockquote>
<p>more examples...</p>
</blockquote>
<pre><code class="language-c++">
struct S {
    constexpr S(int value): m_value(value) {} // normal
    constexpr int getValue() const noexcept { return 100 * m_value; }
    void setValue(int value) { m_value = value; } // extra and not included in constexprs...
    int m_value;
};

int main() {
    S s{100}; // =&gt; can call all
    constexpr S s {100}; // =&gt; cannot call getValue() =&gt; breaks the rule of compilation time calculations
    return 0;
}

</code></pre>
<blockquote>
<p>more examples...</p>
</blockquote>
<pre><code class="language-c++">
template &lt;typename T&gt;
constexpr auto absolute(T arg) {
    return arg &lt; 0 ? -arg : arg;
}
template &lt;typename T&gt;
constexpr auto epsilon = T(0.000001);
template &lt;typename T&gt;
constexpr auto close_enough(T a, T b) {
    if constexpr (std::is_floating_point_v&lt;T&gt;)
        return absolute(a - b) &lt; epsilon&lt;T&gt;;
    else
        return a == b;
}

int main() {
    constexpr auto same = close_enough(1, 2);
    static_assert(!same);
}
</code></pre>
<blockquote>
<p>more examples...</p>
</blockquote>
<pre><code class="language-c++">
template &lt;typename T&gt;
constexpr auto absolute(T arg) {
    return arg &lt; 0 ? -arg : arg;
}
template &lt;typename T&gt;
constexpr auto precision = T(0.00001);
template &lt;typename T&gt;
    requires std::is_floating_point_v&lt;T&gt;
constexpr auto close_enough(T a, T b) {
    return absolute(a - b) &lt; precision&lt;T&gt;;
}
constexpr auto close_enough(auto a, auto b) { return a == b; }

int main() {
    constexpr auto r1 = close_enough(1, 2);
    constexpr auto r2 = close_enough(1.2f, 2.3f);
}
</code></pre>
<h2 id="constexpr-vs-macro"><a class="header" href="#constexpr-vs-macro">constexpr vs macro</a></h2>
<blockquote>
<p>Don't use macros for creating variables or doing some simple logical ops</p>
</blockquote>
<blockquote>
<p>Macro is good for boiler plating... but other cases can be handled with constexpr easily</p>
</blockquote>
<pre><code class="language-c++">
#define M(X) (X * X)
constexpr auto MX(size_t N) { return N * N; }
template &lt;size_t N&gt;
constexpr auto MXV = N * N;
int main() {
    constexpr auto x = M(10);
    static_assert(x == 100);
    constexpr auto x2 = MX(10);
    static_assert(x2 == 100);
    constexpr auto x3 = MXV&lt;10&gt;;
    static_assert(x3 == 100);
}

</code></pre>
<blockquote>
<p>more examples...</p>
</blockquote>
<pre><code class="language-c++">
constexpr auto cala(std::size_t value) { return value * 10; }
constexpr auto calb(bool value) { return value ? "hakan" : "gedek"; }
constexpr auto calc(const char* name) {
    if (name == "hakan")
        return name;
    else if (name == "gedek")
        return name;
    else
        return "unknown";
}
constexpr auto cald(std::initializer_list&lt;int&gt; l) {
    auto total = 0;
    for (auto item : l) total += item;
    return total;
}
constexpr auto cale(const size_t param) {
    if (param == 100)
        return param;
    else
        return size_t(0);
}

int main() {
    constexpr auto r1 = cala(1);
    static_assert(r1 == 10);
    constexpr auto r2 = calb(false);
    static_assert(r2 == "gedek");
    constexpr auto r3 = calc("gedek");
    static_assert(r3 == "gedek");
    constexpr auto r4 = cald({1, 2, 3});
    static_assert(r4 == 6);
    const size_t p1 = 100;
    constexpr auto r5 = cale(p1);
    static_assert(r5 == p1);
}

</code></pre>
<blockquote>
<p>more examples...</p>
</blockquote>
<pre><code class="language-c++">// normal constexpr function
constexpr auto calc(int p1, int p2) { return p1 + p2; }
constexpr auto calc(std::initializer_list&lt;int&gt; l) {
    return std::accumulate(l.begin(), l.end(), 0);
}
int main() {
    const auto r = calc(1, 2);
    const auto r2 = calc({1, 2, 3});
    constexpr std::initializer_list&lt;int&gt; l {1, 2, 3}; // this fails
    constexpr auto r3 = calc(l);
    static_assert(r == 3);
    static_assert(r2 == 6);
    static_assert(r3 == 6);  // This fails
}
</code></pre>
<blockquote>
<p>more examples...</p>
</blockquote>
<pre><code class="language-c++">
// normal template constexpr variable
template &lt;size_t N&gt;
constexpr auto calc2(int p1, int p2) {
    return N * p1 + N * p2;
}
template &lt;typename Cont = std::vector&lt;int&gt;&gt;
constexpr auto calc2(Cont&amp;&amp; cont) {
    return std::accumulate(cont.begin(), cont.end(), 0);
}
int main() {
    const auto r = calc2&lt;10&gt;(1, 2);
    static_assert(r == 30);
    const auto r2 = calc2({1, 2, 3});
    static_assert(r2 == 6);

// Not works =. constexpr will show that this ctor call will trigger new operator so it fails
    constexpr std::vector&lt;int&gt; v = {1, 2, 3};
    const auto r3 = calc2(v);
    static_assert(r3 == 6);
}
</code></pre>
<blockquote>
<p>variables...</p>
</blockquote>
<pre><code class="language-c++">template &lt;size_t N&gt;
constexpr auto Fib = Fib&lt;N - 1&gt; + Fib&lt;N - 2&gt;;
template &lt;&gt;
constexpr auto Fib&lt;0&gt; = 0;
template &lt;&gt;
constexpr auto Fib&lt;1&gt; = 1;
</code></pre>
<pre><code class="language-c++">// normal template constexpr variable
template &lt;size_t N&gt;
constexpr auto X2 = N * N;
template &lt;size_t N&gt;
constexpr auto X3 = N * N * N;
template &lt;size_t N&gt;
constexpr auto X2Div10 = N * N / 10;

int main() {
    static_assert(X2&lt;10&gt; == 100);
    static_assert(X3&lt;3&gt; == 27);
    static_assert(X2Div10&lt;10&gt; == 10);
}
</code></pre>
<blockquote>
<p>a custom type</p>
</blockquote>
<pre><code class="language-c++">
template &lt;class T, class E&gt;
struct expected {
    std::variant&lt;T, E&gt; data;

    constexpr expected(T value): data{std::move(value)} {}
    constexpr expected(E err): data{std::move(err)} {}

    constexpr bool is_ok() const { return std::holds_alternative&lt;T&gt;(data); }
    constexpr bool is_err() const { return std::holds_alternative&lt;E&gt;(data); }

    constexpr std::optional&lt;T&gt; ok() const {
        if(is_ok()) return std::get&lt;T&gt;(data);
        return std::nullopt;
    }
    constexpr std::optional&lt;E&gt; err() const {
        if (is_err()) return std::get&lt;E&gt;(data);
        return std::nullopt;
    }

    constexpr operator bool() const { return is_ok() ? true : false; }
};

auto parse_number(std::string_view value) -&gt; expected&lt;double, err&gt; {
    char const* begin = std.data();
    char const* end = nullptr;

    double retval = std::strtod(begin, &amp;end);

    if (begin == end)
        return err::invalid_input;
    else if (std::isinf(retval))
        return err::overflow;

    value.remove_prefix(end - begin);
    return retval;
}

int main() {
    for (auto src: {"31"sv, "123hakan"sv, "hakan"sv})
    {
        auto result = parse_number(src);
        std::println("{}", result.ok().or_else([]{ return std::optional&lt;double&gt;{-1}}). value());
    }
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-placement-new"><a class="header" href="#use-placement-new">use placement new</a></h1>
<p>useful for managing a dedicated memory area. it allows us to control memory usage.</p>
<pre><code class="language-c++">
#include &lt;cstring&gt;
#include &lt;iostream&gt;

int main() {
    uint8_t buffer[100];

    int* p1 = new (buffer) int(101);
    int* p2 = new (buffer + sizeof(int)) int(102);
    int* p3 = new (buffer + 2 * sizeof(int)) int(103);

    int k = 0;
    memcpy(&amp;k, p1, sizeof(int));
    std::cout &lt;&lt; k &lt;&lt; std::endl;
    memcpy(&amp;k, p2, sizeof(int));
    std::cout &lt;&lt; k &lt;&lt; std::endl;
    memcpy(&amp;k, p3, sizeof(int));
    std::cout &lt;&lt; k &lt;&lt; std::endl;
}

</code></pre>
<pre><code class="language-c++">
struct MyS {
    MyS() { std::cout &lt;&lt; "MyS" &lt;&lt; std::endl; }

    ~MyS() { std::cout &lt;&lt; "~MyS" &lt;&lt; std::endl; }
};

int main() {
    uint8_t buffer[100];

    MyS* myS = new (buffer) MyS();
    myS-&gt;~MyS();

    return 0;

</code></pre>
<blockquote>
<p>don't call delete for p1,p2,p3... it will try to delete buffer mem. and crash.</p>
</blockquote>
<blockquote>
<p>at the end we used stack like heap - defined pointers on it but without delete.</p>
</blockquote>
<pre><code class="language-c++">
struct Pair {
    int x{};
    int y{};

    constexpr auto operator&lt;=&gt;(const Pair&amp;) const noexcept = default;
};

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Pair&amp; p) {
    return out &lt;&lt; p.x &lt;&lt; ' ' &lt;&lt; p.y &lt;&lt; '\0';
}

std::istream&amp; operator&gt;&gt;(std::istream&amp; in, Pair&amp; p) { return in &gt;&gt; p.x &gt;&gt; p.y; }


void placement_new() {
    constexpr size_t NUM_OF_PAIRS = 1;
    alignas(Pair) uint8_t buffer[NUM_OF_PAIRS * sizeof(Pair)];
    auto pair_ptr = new (&amp;buffer[0]) Pair{.x = 101, .y = 202};
    std::cout &lt;&lt; *pair_ptr &lt;&lt; std::endl;
    pair_ptr-&gt;~Pair();
}

void others() {
    constexpr size_t NUM_OF_PAIRS = 2;
    alignas(Pair) std::byte buffer[NUM_OF_PAIRS * sizeof(Pair)];
    Pair* pairs[NUM_OF_PAIRS];

    for (auto i = 0; i &lt; NUM_OF_PAIRS; ++i) {
        pairs[i] = std::construct_at(
            reinterpret_cast&lt;Pair*&gt;(&amp;buffer[i * sizeof(Pair)]), (1001 + i),
            (1001 + i));
    }

    for (auto i = 0; i &lt; NUM_OF_PAIRS; ++i) {
        std::cout &lt;&lt; *pairs[i] &lt;&lt; std::endl;
    }

    for (auto i = 0; i &lt; NUM_OF_PAIRS; ++i) std::destroy_at(pairs[i]);
}

int main() {
    placement_new();
    others();
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="define-custom-new-and-delete-for-type"><a class="header" href="#define-custom-new-and-delete-for-type">define custom new and delete for type</a></h1>
<p>use cases:</p>
<ul>
<li>profiling: you may want to track memory ops of a type</li>
<li>alignment: you may want to change alignment</li>
</ul>
<pre><code class="language-c++">
struct MyS {
    static void* operator new(size_t size) {
        std::cout &lt;&lt; "operator new" &lt;&lt; std::endl;
        return ::operator new(size); // forwarding to std::new but you can use calloc, malloc etc...
    }
    static void operator delete(void* ptr) {
        std::cout &lt;&lt; "operator delete" &lt;&lt; std::endl;
        return ::operator delete(ptr); // same here...you can use free etc.
    }

    MyS() { std::cout &lt;&lt; "ctor" &lt;&lt; std::endl; }
    ~MyS() { std::cout &lt;&lt; "dtor" &lt;&lt; std::endl; }
};
int main() {
    auto ptr = new MyS;
    delete ptr;
}


</code></pre>
<pre><code class="language-c++">operator new
ctor
dtor
operator delete
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-template-header-like-function-call"><a class="header" href="#use-template-header-like-function-call">use template header like function call</a></h1>
<p><code>template &lt;&gt;</code> : template header</p>
<blockquote>
<p>anything passed into template headers must be known at compilation time</p>
</blockquote>
<pre><code class="language-c++">
class T: type place holder

typename T: type place holder

non-type-params: not type info

</code></pre>
<p><code>template &lt;&gt;</code> is similar <code>func()</code> in a manner. main difference you capture type_info in <code>template&lt;&gt;</code> but if we think about literal types (compiler time executable types), we can use this similarity.</p>
<pre><code class="language-c++">template &lt;int i, int j&gt;
constexpr auto t_add() {
    return i + j;
}

constexpr auto f_add(int i, int j) { return i + j; }

template &lt;const char* ptr&gt;
constexpr auto t_len() {
    auto len = 0;
    while (*(ptr + len) != '\0') {
        len++;
    }

    return len;
}

constexpr auto f_len(const char* ptr) {
    auto len = 0;
    while (*(ptr + len) != '\0') len++;
    return len;
}

template &lt;int const&amp; x&gt;
constexpr auto t_is_even() {
    return x % 2 == 0;
}

constexpr auto f_is_even(int const&amp; x) { return x % 2 == 0; }

int main() {
    static_assert(t_add&lt;2, 2&gt;() == 4);
    static_assert(f_add(2, 2) == 4);

    // needs it's adress decieded before compilation; only for template&lt;&gt; but not for func
    static constexpr char name[] = "hakan";
    static_assert(t_len&lt;name&gt;() == 5);
    static_assert(f_len(name) == 5);

    // needs it's adress deciededbefore compilation; only for template but not for func
    static constexpr int x = 2;
    static_assert(t_is_even&lt;x&gt;());
    static_assert(f_is_even(x));

    return 0;
}

</code></pre>
<p>non-type template params:</p>
<ul>
<li>integral constants: int, long...{concept has std::integral&lt;&gt;}</li>
<li>pointers: at the end pointer is a uint64_t value</li>
<li>references: like <code>const int&amp;</code></li>
<li>pointers to member functions or functions</li>
<li>enums: at the end; enums are integral constants</li>
</ul>
<p>if you use <code>const char*</code> or <code>int const&amp;</code> etc. you need to fixed the mem of the variables before compilation so you have to use static so using <code>constexpr function</code> is more flexible but still you can try <code>template&lt;args&gt;</code> too for compilation time computations.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-typeid"><a class="header" href="#use-typeid">use typeid</a></h1>
<ul>
<li>used to get type_info data for types</li>
<li>usable with polymorphic types and looks like dynamic_cast without casting ( getting real type info)</li>
<li>use with base&amp; to access inner types data</li>
</ul>
<pre><code class="language-c++">
struct base {
    virtual ~base() = default;
    virtual void foo() = 0;
};

struct derived : base {
    void foo() override { std::cout &lt;&lt; "hello foo" &lt;&lt; std::endl; }
};

int main() {
    derived d;
    base&amp; br = d; // best
    base* bp = &amp;d;

    std::cout &lt;&lt; (typeid(bp) == typeid(new derived)) &lt;&lt; std::endl; // false
    std::cout &lt;&lt; (typeid(br) == typeid(derived)) &lt;&lt; std::endl; // true

    std::cout &lt;&lt; typeid(d).name() &lt;&lt; std::endl;
    std::cout &lt;&lt; typeid(br).name() &lt;&lt; std::endl;
    std::cout &lt;&lt; typeid(bp).name() &lt;&lt; std::endl;
    std::cout &lt;&lt; typeid(new derived).name() &lt;&lt; std::endl;

    // let's see if we can still access inner type correctly
    br.foo();
    bp-&gt;foo();
    (new derived)-&gt;foo();
}

</code></pre>
<pre><code class="language-c++">0
1
7derived
7derived
P4base
P7derived
hello foo
hello foo
hello foo

</code></pre>
<blockquote>
<p>use type_index to keep typeinfo ( typeid result) in collections</p>
</blockquote>
<pre><code class="language-c++">
struct custom {};

int main() {
    std::unordered_map&lt;std::type_index, std::string&gt; type_names;

    type_names[std::type_index{typeid(int)}] = "int";
    type_names[std::type_index{typeid(float)}] = "float";
    type_names[std::type_index{typeid(custom)}] = "custom";

    int i = 0;
    float f = 0.0f;
    custom c{};

    std::cout
    &lt;&lt; type_names[std::type_index{typeid(i)}] &lt;&lt;
    type_names[std::type_index{typeid(f)}] &lt;&lt;
    type_names[std::type_index{typeid(c)}] &lt;&lt; std::endl;


}
</code></pre>
<blockquote>
<p>let's use it to keep id of the T in template type...</p>
</blockquote>
<pre><code class="language-c++">template &lt;class T&gt;
struct wrapper {
    static inline std::type_index type_id{typeid(T)};

    template &lt;class U&gt;
    constexpr operator U() const {
        if (std::type_index(typeid(U)) != type_id) throw std::bad_cast{};

        return U{};
    }
};

int(){
    wrapper&lt;int&gt; wi;
    wrapper&lt;float&gt; wf;
    wrapper&lt;const char*&gt; wl;

    int i = wi;
    try {
        float f = wi;
    } catch (const std::bad_cast&amp;) {
        std::cout &lt;&lt; "failed int to float" &lt;&lt; std::endl;
    }
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hide-definitionlogic-from-users"><a class="header" href="#hide-definitionlogic-from-users">hide definition/logic from users</a></h1>
<p>c++ has two file formats - default</p>
<ul>
<li>.h : contains declearations and used to share them with other modules, libs</li>
<li>.cpp: contains definitions ( called translation unit or module)</li>
</ul>
<p>one of the rules of programming; when you need to change something; not breaking existing code - supporting legacy.</p>
<blockquote>
<p>whenever you change something in a .h file; all linked .h and .cpp files will need to be built again</p>
</blockquote>
<blockquote>
<p>to hide the logic from 3rd party users; always keep them in .cpp files</p>
</blockquote>
<p>methods:</p>
<ul>
<li>using pimpl idiom</li>
<li>using public methods + private methods combination</li>
<li>using private inheritance to implement logic once and sharing it with classes with not allowing them to be accessed by users</li>
</ul>
<p>you can find pimpl idiom in it's own page.</p>
<h2 id="public-methods--private-methods"><a class="header" href="#public-methods--private-methods">public methods + private methods</a></h2>
<p>this is pimpl version of functions - redirecting the function to hidden functions</p>
<blockquote>
<p>I call this swiss knife pattern. you create public non-virtual functions in base type and redirect them to private virtual functions</p>
</blockquote>
<blockquote>
<p>you hide derived types implementations in cpp and no-body knows what's there</p>
</blockquote>
<pre><code class="language-c++">struct base {
    void foo(int id, const char* name) { _foo(id, name); }

   private:
    virtual void _foo(int id, const char* name) noexcept = 0;
};

struct derived : base {
   private:
    void _foo(int id,
              const char* name) noexcept override;  // define this in cpp file
};

// .cpp file
void derived::_foo(int id, const char* name) noexcept {
    std::cout &lt;&lt; "id: " &lt;&lt; id &lt;&lt; " name: " &lt;&lt; name &lt;&lt; std::endl;
}

int main() {
    derived d;
    d.foo(0, "hakan gedek");
}

</code></pre>
<blockquote>
<p>another help of swiss knife pattern is if you need to add new function overloads you can redirect them without changing deriveds</p>
</blockquote>
<pre><code class="language-c++">struct data {
    int _id;
    std::string _name;
};

struct base {
    void foo(int id, const char* name) { _foo(id, name); }
    void foo(int id, std::string const&amp; name) {
        _foo(id, name.c_str());
    }
    void foo(data const&amp; d) {
        _foo(d._id, d._name);
    }

   private:
    virtual void _foo(int id, const char* name) noexcept = 0;
};

struct derived : base {
   private:
    void _foo(int id,
              const char* name) noexcept override;  // define this in cpp file
};

// .cpp file
void derived::_foo(int id, const char* name) noexcept {
    std::cout &lt;&lt; "id: " &lt;&lt; id &lt;&lt; " name: " &lt;&lt; name &lt;&lt; std::endl;
}

int main() {
    derived d;
    d.foo(0, "hakan gedek");
}

</code></pre>
<h2 id="private-inheritance"><a class="header" href="#private-inheritance">private inheritance</a></h2>
<blockquote>
<p>this is a <code>has-a</code> relationship</p>
</blockquote>
<blockquote>
<p>implement the logic/algorithm once in the ability or data class and share them in others</p>
</blockquote>
<pre><code class="language-c++">
struct io_manager {
protected:
    io_manager() = default;

    void _write(std::string const&amp; path, const char* bytes, size_t size);
    std::string _read(std::string const&amp; path);
};

struct json_manager: private io_manager {
public:
    void write(std::string const&amp; dest, const char* bytes, size_t size);
    std::string read(std::string const&amp; path);
};

struct xml_manager: private io_manager {
    ...
};

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="define-pimpl-idiom"><a class="header" href="#define-pimpl-idiom">define pimpl idiom</a></h1>
<blockquote>
<p>hiding implementation in cpp while supporting a public interface to users to access them</p>
</blockquote>
<blockquote>
<p>qt framework uses this almost everywhere !</p>
</blockquote>
<pre><code class="language-c++">
// .h
class queue
{
public:
    queue();
    ~queue() = default;

    void push(int value);
    int pop();

private:
    class impl;

    std::unique_ptr&lt;Impl&gt; m_Impl;
};

// cpp

class queue::impl {
public:
    void push(int) {}
    int pop() {}
};


queue::queue(): m_Impl(std::make_unique&lt;queue::impl&gt;()) {}

void queue::push(int val) { m_Impl-&gt;push(val); }
int queue::pop() { return m_Impl-&gt;pop(); }
</code></pre>
<p>why use pimpl ?</p>
<ul>
<li>losely coupling: you will be more relaxed with updating the code - it's hidden in one translation unit (module - cpp)</li>
<li>you move most of stuff from headers to cpps so in total header size is less</li>
<li>build time is faster because updates will not trigger other cpps builds</li>
</ul>
<p>by hiding outer class implemantations in cpp file we would achieve same encapsulation but pimpl provides more for us. adding new functions to outer, overloading them etc will not create an issue at the end. we have 2 layers - 1.outer 2.inner... so anything updated with outer will not effect always the inner - like overloads, type changings etc... we can handle them at first layer and continue to use second layer as it's.</p>
<blockquote>
<p>generally, std::unique_ptr asks for custom deletor for forward decl types so you may need to impl a dummy deletor for it</p>
</blockquote>
<blockquote>
<p>it's good to call inner class as impl or outer-classimpl or outer-class_impl ( outer-class: name of the outer class)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="define-crtp-pattern"><a class="header" href="#define-crtp-pattern">define crtp pattern</a></h1>
<p>one of the best examples of static polymorphism</p>
<blockquote>
<p>designing swiss knife pattern with templates this time...we will route all from base class again. derived types will be hidden behind of the base type instance</p>
</blockquote>
<blockquote>
<p>please read about <code>how to protect inner type in inheritance</code> to understand why slicing the derived parts not happens</p>
</blockquote>
<blockquote>
<p>after creation of the instance; derived type will be ignored and only template base type will be used around</p>
</blockquote>
<pre><code class="language-c++">template &lt;class T&gt;
struct base {
    void foo(int arg) { static_cast&lt;T*&gt;(this)-&gt;foo_impl(arg); }
    void bar(char const* arg) { static_cast&lt;T*&gt;(this)-&gt;bar_impl(arg); }
    void foo(int arg) const { static_cast&lt;const T*&gt;(this)-&gt;foo_impl(arg); }
    void bar(char const* arg) const {
        static_cast&lt;const T*&gt;(this)-&gt;bar_impl(arg);
    }
};

struct derived : base&lt;derived&gt; {
    friend base&lt;derived&gt;;

   private:
    void foo_impl(int arg) const {
        std::cout &lt;&lt; "derived::foo_impl " &lt;&lt; arg &lt;&lt; std::endl;
    }
    void bar_impl(char const* arg) const {
        std::cout &lt;&lt; "derived::bar_impl " &lt;&lt; arg &lt;&lt; std::endl;
    }
    void foo_impl(int arg) {
        std::cout &lt;&lt; "derived::foo_impl " &lt;&lt; arg &lt;&lt; std::endl;
    }
    void bar_impl(char const* arg) {
        std::cout &lt;&lt; "derived::bar_impl " &lt;&lt; arg &lt;&lt; std::endl;
    }
};

// use base&lt;T&gt;&amp;
template &lt;class T&gt;
void call_foo(base&lt;T&gt; const&amp; inst) {
    int x = 0;
    inst.foo(x);
}

template &lt;class T&gt;
void call_bar(base&lt;T&gt;&amp; inst) {
    char const* name = "hakan gedek";
    inst.bar(name);
}

int main() {
    derived d;

    call_foo(d);
    call_bar(d);
}

</code></pre>
<blockquote>
<p>&amp;: important to stop slicing</p>
</blockquote>
<blockquote>
<p>template header plays critical role to store inner type in T</p>
</blockquote>
<blockquote>
<p>by friendship; we can hide the impl behind the private and encapsulation works greately</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-static-polymoprhism"><a class="header" href="#use-static-polymoprhism">use static polymoprhism</a></h1>
<blockquote>
<p>polymorphism: being in many forms</p>
</blockquote>
<p>generally we use this term for dynamic polymorphism which is as you know inheritance with virtual functions. this allows us to hide types in base type and let it to be decided at runtime by using virtual tables (vtable).</p>
<p>but we can also achieve simple poly-morphism at compilation time !!!</p>
<blockquote>
<p>Q: are there any multi forms at compilation time ?</p>
</blockquote>
<ul>
<li>overloaded functions</li>
<li>templates</li>
</ul>
<blockquote>
<p>static_cast is part of the static polymorphism</p>
</blockquote>
<blockquote>
<p>if static_cast fails then it means compiler cannot decide the type info at compilation time so it's not a compilation time work</p>
</blockquote>
<pre><code class="language-c++">
int i = 0;
float f = static_cast&lt;float&gt;(i); // one form to another

struct S {
    // 3 forms
    void foo(int) {}
    void foo(float) {}
    void foo(char const*) {}
};

S s;
s.foo(int{});
s.foo(float{});
s.foo("hakan gedek");


</code></pre>
<blockquote>
<p>template means that preparing a form and allowing compiler to use it to generate new forms using it</p>
</blockquote>
<pre><code class="language-c++">
template &lt;class T&gt;
struct wrapper {
    T value;
};

wrapper&lt;int&gt; wi;

// compiler generates

template&lt;&gt;
struct wrapper&lt;int&gt; { int value; };

wrapper&lt;float&gt; wf;

template &lt;&gt;
struct wrapper&lt;float&gt; { float value; };
...

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-dynamic-polymorphism"><a class="header" href="#use-dynamic-polymorphism">use dynamic polymorphism</a></h1>
<p>you can achieve it by virtual functions. this allows you to access derived class over pointer or reference types at runtime.</p>
<p>how ?</p>
<p>a vtable ( virtual table) is implemented for each class which keeps function pointers to virtual functions. each class has a pointer to own vtable and it's size is fixed (8 bytes on 64bit system) but size of vtable is not - it depends on the virtual function count.</p>
<pre><code class="language-c++">class no_virtual {};
class one_virtual {
    virtual void foo() {}
};
class two_virtual {
    virtual void foo() {}
    virtual void bar() {}
};
class two_inherited_virtual : public one_virtual {
    virtual void bar() {}
};

int main() {
    std::cout &lt;&lt; sizeof(no_virtual) &lt;&lt; '\n'
              &lt;&lt; sizeof(one_virtual) &lt;&lt; '\n'
              &lt;&lt; sizeof(two_virtual) &lt;&lt; '\n'
              &lt;&lt; sizeof(two_inherited_virtual) &lt;&lt; '\n';

}

</code></pre>
<pre><code class="language-c++">1
8
8
8
</code></pre>
<blockquote>
<p>pointer and reference keeps inner type correctly - vtable is alive :)</p>
</blockquote>
<pre><code class="language-c++">
class base {
   public:
    virtual ~base() = default;

    virtual void print() { std::cout &lt;&lt; "base::print" &lt;&lt; std::endl; }
};

class derived : public base {
   public:
    void print() override { std::cout &lt;&lt; "derived::print" &lt;&lt; std::endl; }
};

// support vtable
void pass_by_pointer(base* ptr) { ptr-&gt;print(); }

// support vtable
void pass_by_ref(base&amp; ptr) { ptr.print(); }

// lost the correct type
void pass_by_value(base ptr) { ptr.print(); }

int main() {
    derived d;

    pass_by_pointer(&amp;d);
    pass_by_ref(d);
    pass_by_value(d);
}

</code></pre>
<pre><code class="language-c++">derived::print
derived::print
base::print
</code></pre>
<p>a beatiful clone solution</p>
<pre><code class="language-c++">
class base {
    virtual base* create() const {
        std::cout &lt;&lt; "base::create" &lt;&lt; std::endl;
        return new base;
    }

   public:
    base* clone() { return create(); }
};

class derived : public base {
    derived* create() const override {
        std::cout &lt;&lt; "derived::create" &lt;&lt; std::endl;
        return new derived;
    };
};

int main() {
    base b;
    b.clone();

    derived d;
    d.clone();
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="protect-inner-type-in-inheritance"><a class="header" href="#protect-inner-type-in-inheritance">protect inner type in inheritance</a></h1>
<p>inheritance is a method that allows us to extend the types. each derived type will own the bases' memory blocks too so derived type will be extended with added fields.</p>
<p>c++ allows us to acces to exact memory addresses indirectly or directly. directly means using exact variables but indirectly means creating layers and step by step accessing the real mem.</p>
<p>by using pointers or reference type we create a new layer. although pointer type (T*) has it's own memory address like any variable (8 bytes on 64bits), reference type (T&amp;) doesn't and it's just an alias.</p>
<pre><code class="language-c++">
struct base {
    int id{};
    std::string name{};
};

struct derived : base {
    // comes from base - it applied before own fields
    // int id{};
    // std::string name{};
    int tel{};
    std::string address{};
};

void print(base&amp; arg) {
    std::cout &lt;&lt; "id: " &lt;&lt; arg.id &lt;&lt; "\nname: " &lt;&lt; arg.name &lt;&lt; std::endl;
}

void print(derived&amp; arg) {
    print(static_cast&lt;base&amp;&gt;(arg));
    std::cout &lt;&lt; "tel: " &lt;&lt; arg.tel &lt;&lt; "\naddress: " &lt;&lt; arg.address
              &lt;&lt; std::endl;
}

int main() {
    derived d0{101, "hakan", 111222333, "coventry"};

    base sliced_base = d0;  // we sliced the derived memory part
    derived sliced_derived = static_cast&lt;derived&gt;(sliced_base);

    print(sliced_derived);
    std::cout &lt;&lt; '\n';

    base&amp; non_sliced_ref = d0;
    base* non_sliced_ptr = &amp;d0;

    derived non_sliced_ref_derived = static_cast&lt;derived&amp;&gt;(non_sliced_ref);
    derived non_sliced_ptr_derived = *static_cast&lt;derived*&gt;(non_sliced_ptr);

    print(non_sliced_ptr_derived);
    std::cout &lt;&lt; '\n';
    print(non_sliced_ref_derived);
}


</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-c-memory-methods"><a class="header" href="#use-c-memory-methods">use c memory methods</a></h1>
<p>they work on void* - raw memory - and always think about in bytes.</p>
<pre><code class="language-c++">
char data[4];
int i = 100;

memcpy(data, &amp;i, sizeof(int));

assert(data[0] == 'd');

</code></pre>
<p>POD to memory and reading according to location:</p>
<pre><code class="language-c++">
struct S {
        int i = 100;
        float f = 3.4f;
        char name[10] = "hakan";
} s;

char buffer[20];

memset(buffer, 0, sizeof(buffer));
memcpy(buffer, &amp;s, sizeof(S));

char ci = buffer[0];
char fl = buffer[sizeof(int) + sizeof(float)];

assert(ci == 'd');
assert(fl == 'h')

</code></pre>
<p>placement new:</p>
<pre><code class="language-c++">
struct S {
    int i = 100;
    float f = 3.4f;
    char name[10] = "hakan";
} s;

char buffer[20];
S* ptr = new (buffer) S;

memcpy(ptr, &amp;s, sizeof(S));

char ci = buffer[0];
char fl = buffer[sizeof(int) + sizeof(float)];

assert(ci == 'd');
assert(fl == 'h');

</code></pre>
<p>copying int to byte array:</p>
<pre><code class="language-c++">int data = 100;
char buffer[sizeof(data)];

memset(buffer, 0, sizeof(buffer));
memcpy(buffer, &amp;data, sizeof(buffer));

std::println("{}", buffer[0]);

int data = 100;
char buffer[sizeof(data)];
char* ptr = &amp;buffer[0];
ptr = reinterpret_cast&lt;char*&gt;(&amp;data);

std::println("{}", *ptr)

</code></pre>
<p>byte array to int</p>
<pre><code class="language-c++">    char data[4] = {'d', 0, 0, 0};
    int* ptr = nullptr;
    int i = 0;

    memcpy(&amp;i, data, sizeof(int));

    ptr = reinterpret_cast&lt;int*&gt;(data);
    std::println("{} {}", i, *ptr);
</code></pre>
<p>byte array to struct type:</p>
<pre><code class="language-c++">char buffer[50] = {0};

{
    struct A {
        int id = 35;
        float value = 3.4f;
        char data[10] = "hakan";
    };
    A a;
    memcpy(buffer, &amp;a, sizeof(A));
}
{
    // same order of the data
    struct B {
        int id;
        float value;
        char data[10];
    };

    B b;

    memcpy(&amp;b, buffer, sizeof(B));

    assert(b.id == 35);
    assert(b.value == 3.4f);

    assert(memcmp(b.data, "hakan", 5) == 0);
}
</code></pre>
<p>or using std::array</p>
<pre><code class="language-c++">
char buffer[100] = {0};
{
    struct A {
        int id = 35;
        float value = 3.4f;
        std::array&lt;char, 10&gt; data = {
            'h', 'a', 'k', 'a','n'};  
    };
    A a;
    memcpy(buffer, &amp;a, sizeof(A));
}
{
    struct B {
        int id;
        float value;
        std::array&lt;char, 10&gt; data;
    };
    B b;
    memcpy(&amp;b, buffer, sizeof(B));
    assert(b.id == 35);
    assert(b.value == 3.4f);
    std::println("{}", b.data.data());
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-template-types-in-templates"><a class="header" href="#use-template-types-in-templates">use template types in templates</a></h1>
<p>multi layered templates is an interesting topic of meta programming but firstly let me share my any impl. I did years ago after asked in a luxoft interview</p>
<pre><code class="language-c++">
#include &lt;typeindex&gt;
#include &lt;typeinfo&gt;
#include &lt;cassert&gt;
#include &lt;vector&gt;

struct S {
    template &lt;typename T&gt;
    S(T&amp;&amp; param) : dPtr(new Data(std::forward&lt;T&gt;(param))), type(typeid(T)) {}
    S(S const&amp;) = delete;
    S(S&amp;&amp; o) : type(std::move(o.type)) {
        dPtr = std::exchange(o.dPtr, nullptr);
    }
    S&amp; operator=(S const&amp;) = delete;
    S&amp; operator=(S&amp;&amp; o) {
        dPtr = std::exchange(o.dPtr, nullptr);
        type = std::move(o.type);
        return *this;
    }
    template &lt;typename T&gt;
    struct Data {
        Data() = delete;
        Data(T&amp;&amp; value) : data(std::move(value)) {}
        Data(Data const&amp;) = delete;
        Data(Data&amp;&amp; o) : data(std::move(o.data)) {}
        Data&amp; operator=(const Data&amp;) = delete;
        Data&amp; operator=(Data&amp;&amp; o) {
            data = std::move(o.data);
            return this;
        }
        T data;  // owner of the data
    };
    void* dPtr;
    std::type_index type;
    template &lt;typename T&gt;
    static const T&amp; As(S const&amp; src) {
        if (typeid(T) == src.type)
            return *static_cast&lt;T*&gt;(src.dPtr);
        else
            throw std::runtime_error("type error");
    }
};
int main() {
    S s = 10;
    int value = S::As&lt;int&gt;(s);
    assert(value == 10);
    float fvalue = S::As&lt;float&gt;(s);
    assert(value == 10);
}

</code></pre>
<p>if you want to pass template type in template header you can pick one of two options...lets pass std::vector</p>
<blockquote>
<p>you can apply all to class methods too - I will use a normal function</p>
</blockquote>
<pre><code class="language-c++">
// only supports a template type as Cont and also generic to accept it's type as T
template &lt;template &lt;class&gt; class Cont, class T&gt;
void print(Cont&lt;T&gt; const&amp; cont) {
    for (auto&amp;&amp; item : cont) {
        std::print("{} ", item);
    }
}

// or with a fixed inner type...only supports a template type as Cont

template &lt;template &lt;class&gt; class Cont&gt;
void print(Cont&lt;int&gt; const&amp; cont) {
    std::for_each(cont.begin(), cont.end(), [](auto&amp;&amp; item) { std::print("{} " , item);});
}

// or without template of it .. this will support any type with begin:end methods.. they don't need to be a template container
template &lt;class Cont&gt;
void print(Cont cont&amp; cont) {
    std::for_each(cont.begin(), cont.end(), [](auto&amp;&amp; item) { std::print("{} " , item);});
}


</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-union"><a class="header" href="#use-union">use union</a></h1>
<p>c type like struct...</p>
<p>use case: sharing memory for different types - accessing to same memory via different options</p>
<pre><code class="language-c++">

union MyU {
    uint16_t s;
    uint8_t c[2];
};
int main() {
    MyU mu;
    mu.s = (0xB &lt;&lt; 8) | 0xB;

    std::println("{} {}", mu.c[0], mu.c[1]);

    return 0;
}

</code></pre>
<p>check also <code>anonymous struct and union</code> page.</p>
<p>c++ has <code>variant</code> type that does a better job but if you are interested you can develop your own variant type too.</p>
<pre><code class="language-c++">
#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include &lt;print&gt;
#include &lt;typeindex&gt;
#include &lt;typeinfo&gt;
#include &lt;unordered_map&gt;

struct variant {
   private:
    enum type { Byte, Short, Int, Float, Double, Long, String } _type;

    union {
        int8_t _c;
        int16_t _s;
        int32_t _i;
        float _f;
        double _d;
        int64_t _l;
        const char *_st;
    } _data;

    static inline std::unordered_map&lt;std::type_index, type&gt; tbl = {
        {std::type_index(typeid(char)), type::Byte},
        {std::type_index(typeid(int8_t)), type::Byte},
        {std::type_index(typeid(int16_t)), type::Short},
        {std::type_index(typeid(int32_t)), type::Int},
        {std::type_index(typeid(float)), type::Float},
        {std::type_index(typeid(double)), type::Double},
        {std::type_index(typeid(int64_t)), type::Long},
        {std::type_index(typeid(std::string)), type::String},
        {std::type_index(typeid(const char *)), type::String}};
    template &lt;class T&gt;
    constexpr T get_value() const {
        using type = std::remove_cvref_t&lt;T&gt;;

        if constexpr (std::same_as&lt;type, int8_t&gt; || std::same_as&lt;type, char&gt;) {
            return _data._c;
        } else if constexpr (std::same_as&lt;type, int16_t&gt;) {
            return _data._s;
        } else if constexpr (std::same_as&lt;type, int32_t&gt;) {
            return _data._i;
        } else if constexpr (std::same_as&lt;type, int64_t&gt;) {
            return _data._l;
        } else if constexpr (std::same_as&lt;type, float&gt;) {
            return _data._f;
        } else if constexpr (std::same_as&lt;type, double&gt;) {
            return _data._d;
        } else if constexpr (std::same_as&lt;type, std::string&gt; ||
                             std::same_as&lt;type, const char *&gt;) {
            return _data._st;
        } else
            throw std::invalid_argument("unknown type int get");
    }

    template &lt;class T&gt;
    constexpr void set_value(T &amp;&amp;val) {
        using type = std::remove_cvref_t&lt;T&gt;;

        if constexpr (std::same_as&lt;type, int8_t&gt; || std::same_as&lt;type, char&gt;) {
            _data._c = val;
        } else if constexpr (std::same_as&lt;type, int16_t&gt;) {
            _data._s = val;
        } else if constexpr (std::same_as&lt;type, int32_t&gt;) {
            _data._i = val;
        } else if constexpr (std::same_as&lt;type, int64_t&gt;) {
            _data._l = val;
        } else if constexpr (std::same_as&lt;type, float&gt;) {
            _data._f = val;
        } else if constexpr (std::same_as&lt;type, double&gt;) {
            _data._d = val;
        } else if constexpr (std::same_as&lt;type, std::string&gt;) {
            // i will not take ownership but you can impl it if you want
            // create a new byte[] and memcpy it but dont forget to release it
            _data._st = val.data();
        } else {
            throw std::invalid_argument("unknown type in set");
        }
    }

    template &lt;size_t N&gt;
    constexpr void set_value(const char (&amp;arr)[N]) {
        _data._st = arr;
    }

   public:
    template &lt;class T&gt;
    constexpr variant(T &amp;&amp;arg)
        : _type(tbl[std::type_index(typeid(std::remove_cvref_t&lt;T&gt;))]) {
        set_value(std::forward&lt;T&gt;(arg));
    }

    template &lt;class T&gt;
    constexpr operator T() const {
        if (tbl[std::type_index(typeid(std::remove_cvref_t&lt;T&gt;))] != _type)
            throw std::invalid_argument("invalid type casting");

        return get_value&lt;T&gt;();
    }

    constexpr operator char const *() const {
        return get_value&lt;char const *&gt;();
    }
};

int main() {
    variant v{10};

    const int i = v;
    assert(i == 10);

    variant str{"hakan gedek"};
    const char *sptr = str;

    assert("hakan gedek" == sptr);

    std::string name = "hakan gedek";
    variant str2{name};

    std::string name2 = str2;
    assert(name2 == name);

}

</code></pre>
<p>another example...</p>
<pre><code class="language-c++">
  union Data
    {
        int d_first;
        double d_second;
        std::string *d_third;
    };
                        // initialize the union's d_third field:
    Data data{ .d_third = new string{ "hello" } };
</code></pre>
<p>an ugly example :)</p>
<pre><code class="language-c++">
struct Address {
    union {
        long __data;
        struct { short __s1, __s2; } __first;
        struct { int __s3, __s4; } __second;
    } __un;
#define data __un.__data
#define first __un.__first
#define s1 first.__s1
#define s2 first.__s2
#define second __un.__second
#define s3 second.__s3
#define s4 second.__s4
};
void print(auto&amp;&amp;...args) {
    (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; std::endl;
}
int main() {
    Address addr;

    addr.data = 0xFFAAFF00CC00;
    print(std::hex,addr.s1);
    print(std::hex, addr.s2);
    print(std::hex, addr.s3);
    print(std::hex, addr.s4);
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-namespaces"><a class="header" href="#use-namespaces">use namespaces</a></h1>
<blockquote>
<p>anonymous namespace ?</p>
</blockquote>
<p>Anonymous namespace is called closed namespace also static - namespace... whatever you put into it - it becomes belongs to that source file / translation unit so multiple definition problem solved...</p>
<p>you can access it in source file without any problem - without using ns name etc.</p>
<p>SO, whatever you have in your .cpp source file but not in .h; put all into anonymous namespace !</p>
<blockquote>
<p>bad usages of namespaces</p>
</blockquote>
<ol>
<li>Never use "using namespace ***" in source file = this may result ambiguity</li>
<li>Never use "using namespace ***" in declaration...it will fail but its really stupid</li>
<li>Never use "using namespace ***" in header files... this is completely wrong.</li>
</ol>
<blockquote>
<p>access to outer ns ?</p>
</blockquote>
<p>scope operator.. using this you can access outer namespace world / global and call global types</p>
<pre><code class="language-c++">
void cos(auto value) {
::cos(value);
}
</code></pre>
<blockquote>
<p>can we directly call things from namespace to locals and access directly them</p>
</blockquote>
<p>Yes. We can open the types and extract them from namespaces and we can do that locally...so if you call them inside of {} ... out side of it we can't access them.</p>
<pre><code class="language-c++">
using std::vector;
using std::cout;
using std::deque;
using std::sort;
using std::cin;
using std::string;

...

vector&lt;..&gt;
cout &lt;&lt;
cin &gt;&gt;
string...


</code></pre>
<blockquote>
<p>what is Koening lookup ?</p>
</blockquote>
<p>let's say that you called a function but didn't use it's namespace... then using it's params namespaces that function searched under that namespaces...if any of them has it it's used...</p>
<pre><code class="language-c++">
namespace NS {
    enum Enum {
        A,
        B,
        C
    };
    const char* toStr(Enum E) {
        switch(E) {
            case A: return "A";
            case B: return "B";
            case C: return "C";
        }
        return "None";
    }
}
int main() {
    print(toStr(NS::Enum::A)); // not using ns in front of function but still can access it =&gt; Koening lookup
    return 0;
}

If function takes different ns variables and they have same function name =&gt; ambiguity happens so we need to directly give the ns of the function.

</code></pre>
<blockquote>
<p>how should use long namespaces - inner namespaces</p>
</blockquote>
<ol>
<li>You can export them with using keyword... using ns::inner::Type;</li>
<li>You can use alias... namespace inner = outer::inner;</li>
</ol>
<pre><code class="language-c++">
namespace X {
    namespace Y {
        namespace Z {
            enum Enum {
                A,
                B,
                C
            };

            const char* toStr(Enum E) {
                switch(E) {
                    case A: return "A";
                    case B: return "B";
                    case C: return "C";
                }

                return "None";
            }
        }
    }
}
int main() {
    namespace XYZ = X::Y::Z;
    print(XYZ::toStr(XYZ::Enum::A));
    {
        using X::Y::Z::toStr;
        using X::Y::Z::Enum;
        print(toStr(Enum::A));
    }

    return 0;

}

</code></pre>
<blockquote>
<p>what is aliasing ?</p>
</blockquote>
<p>if namespace has a long name or inner namespaces there re we can shortcut them with aliasing.</p>
<pre><code class="language-c++">namespace X {
    namespace Y {
        namespace Z {
            enum Enum {
                A,
                B,
                C
            };

            const char* toStr(Enum E) {
                switch(E) {
                    case A: return "A";
                    case B: return "B";
                    case C: return "C";
                }

                return "None";
            }
        }
    }
}
int main() {
    namespace XYZ = X::Y::Z;
    print(XYZ::toStr(XYZ::Enum::A));

    // or

    return 0;
}
</code></pre>
<blockquote>
<p>Methods to define nested namespaces ?</p>
</blockquote>
<p>use one of these:</p>
<pre><code class="language-c++">
namespace X {
    int x = 1;
    const char* foo() { return "X::foo"; }
    namespace Y {
        int y = 2;
        const char* foo() { return "Y::foo"; }
        namespace Z {
            int z = 3;
            const char* foo() { return "Z::foo"; }
        }
    }
}
namespace A {
    int a = 1;
    const char* foo() { return "A::foo"; }
}
namespace A::B {
    int b = 2;
    const char* foo() { return "B::foo"; }
}
namespace A::B::C {
    int c = 3;
    const char* foo() { return "C::foo"; }
}
int main() {
    print(A::a, " ", A::foo());
    print(A::B::b, " ", A::B::foo());
    print(A::B::C::c, " ", A::B::C::foo());
    print(X::x, " ", X::foo());
    print(X::Y::y, " ", X::Y::foo());
    print(X::Y::Z::z, " ", X::Y::Z::foo());
    return 0;

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-addressof"><a class="header" href="#use-addressof">use addressof</a></h1>
<p>getting the address of the object bypassing the overloaded operator&amp;.</p>
<p>use case: target class may implemented the operator&amp; and it does something else instead of giving back real memory address...</p>
<pre><code class="language-c++">
struct S {
    S* operator&amp;() { throw; }
};
void foo(S* s) {}
int main() {
    S s;
    foo(std::addressof(s));
    foo(&amp;s); // =&gt; crashes
}

</code></pre>
<p>useful with placement new</p>
<pre><code class="language-c++">
template &lt;class T&gt;
struct Allocator {
    T* allocate(size_t n) {
        return static_cast&lt;T*&gt;(::operator new(n * sizeof(T)));
    }

    void deallocate(T* p, size_t n) {
        ::operator delete(p);
    }

    template &lt;class...Args&gt;
    void construct(T* p, Args&amp;&amp;...args) {
        new(std::addressof(*p)) T(std::forward&lt;Args&gt;(args)...);
    }

    void destroy(T* p) {
        p-&gt;~T();
    }
};

</code></pre>
<pre><code class="language-c++">
#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include &lt;new&gt;

template &lt;class T&gt;
struct Alloc {
    T* allocate(size_t n) {
        return static_cast&lt;T*&gt;(::operator new(n * sizeof(T)));
    }

    void deallocate(T*&amp; p) {
        ::operator delete(p);
        p = nullptr;
    }

    template &lt;class... Args&gt;
    void construct(T* p, Args&amp;&amp;... args) {
        new (std::addressof(*p)) T(std::forward&lt;Args&gt;(args)...);
    }

    void destroy(T* p) { p-&gt;~T(); }
};

struct MyS {
    int value;

    MyS() = default;
    ~MyS() = default;
    MyS(int val) : value(val) {}

    // stop accessing to this
    MyS* operator&amp;() { throw; }
};

int main() {
    Alloc&lt;MyS&gt; alc;

    auto mys_ptr = alc.allocate(1);
    assert(mys_ptr != nullptr);

    alc.deallocate(mys_ptr);
    assert(mys_ptr == nullptr);

    auto mys_ptr2 = alc.allocate(1);
    assert(mys_ptr2 != nullptr);

    alc.construct(mys_ptr2, 101);
    assert(mys_ptr2-&gt;value == 101);
    alc.deallocate(mys_ptr2);
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="define-custom-types-using-enums"><a class="header" href="#define-custom-types-using-enums">define custom types using enums</a></h1>
<p><code>enum type</code> is called a real constant. an enum value is set compilation time so they are very useful for meta-programming.</p>
<blockquote>
<p>enum types use integral types as base</p>
</blockquote>
<p>std::byte is an enum type which has <code>unsigned char</code> as base.</p>
<pre><code class="language-c++">int main() {
    static_assert(sizeof(std::byte) == sizeof(unsigned char));
}

</code></pre>
<blockquote>
<p>std::is_integral_v will fail for std::byte. at the it's a new type - enum class</p>
</blockquote>
<pre><code class="language-c++">
enum class my_int: int32_t {};

enum class my_uint: uint32_t {};

enum class my_long: int64_t {};

enum class my_ulong: uint64_t{};

int main() {
    static_assert(sizeof(my_int) == sizeof(int32_t));
    static_assert(sizeof(my_uint) == sizeof(uint32_t));
    static_assert(sizeof(my_long) == sizeof(int64_t));
    static_assert(sizeof(my_ulong) == sizeof(uint64_t));
}

</code></pre>
<p>let's leave the enum scope...generally enum types have predefined values - constants and they are set at compilation - very useful. instances of enum types don't leave this predefined constants area - but what if we leave ?</p>
<pre><code class="language-c++">
enum class Color : int { Red = 0x0000ff, Green = 0x00ff00, Blue = 0xff0000 };

void foo(Color color) {
    switch (color) {
        case Color::Red:
            std::cout &lt;&lt; "red" &lt;&lt; std::endl;
            break;
        case Color::Green:
            std::cout &lt;&lt; "green" &lt;&lt; std::endl;
            break;
        case Color::Blue:
            std::cout &lt;&lt; "blue" &lt;&lt; std::endl;
            break;
        default:
            std::cout &lt;&lt; "unknown" &lt;&lt; std::endl;
            break;
    }
}

int main() {
    // all predefined possibilities
    Color r = Color::Red, g = Color::Green, b = Color::Blue;
    std::cout &lt;&lt; std::hex &lt;&lt; (int)r &lt;&lt; ":" &lt;&lt; (int)g &lt;&lt; ":" &lt;&lt; (int)b
              &lt;&lt; std::endl;

    Color w = Color((int)r | (int)g | (int)b);
    Color y = Color((int)r | (int)g);

    // have any equivalent in enum definiton ? NO and they are useless in switch
    // also static_cast works because compiler knows the underlying type which there is also another tool for it
    Color c1 = static_cast&lt;Color&gt;(0x000011);
    Color c2 = static_cast&lt;Color&gt;(0x001100);
    Color c3 = static_cast&lt;Color&gt;(0x110011);

    // all: unknown then why ?
    foo(c1);
    foo(c2);
    foo(c3);

</code></pre>
<p>depending on the underlying type we can assign values which are out of predefined constant enum values to enum instances and they can be used in bitwise operations or just aliasing the built-in integrals (like std::byte)... there are other use cases too but for now this is all.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-stdinteger_sequence-and-stdindex_sequence"><a class="header" href="#use-stdinteger_sequence-and-stdindex_sequence">use std::integer_sequence and std::index_sequence</a></h1>
<blockquote>
<p>they use integer constants in template header but not types.</p>
</blockquote>
<blockquote>
<p>need a sequence of integers in your template impl which is generally variadic then use this.</p>
</blockquote>
<p>rule: let make_index_sequence method to create an index_sequence&lt;ints...&gt; instance and provide it to another wrapper which will capture it's INTs in its own header and then you can unpack it.</p>
<blockquote>
<p>index_sequence is template alias of integer_sequence and both supports makers.</p>
</blockquote>
<pre><code class="language-c++">#include &lt;print&gt;

// capture  Ints here
template &lt;size_t... Ints&gt;
constexpr auto get_total(std::index_sequence&lt;Ints...&gt;) {
    return (0 + ... + Ints);
}

// let make_index_sequence to generate a wrapper of Ints with given param
template &lt;size_t N, typename Indices = std::make_index_sequence&lt;N + 1&gt;&gt;
constexpr auto total = get_total(Indices{}); // pass it another variadic helper to capture Ints  and unpack it

int main() {
    std::print("{}\n", total&lt;3&gt;);
    std::print("{}\n", total&lt;4&gt;);
    std::print("{}\n", total&lt;5&gt;);
    return 0;
}

</code></pre>
<p>or integer_sequence:</p>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;utility&gt;

// Function to print elements of an integer sequence
template &lt;typename T, T... Ints&gt;
void print_sequence(std::integer_sequence&lt;T, Ints...&gt;) {
    ((std::cout &lt;&lt; Ints &lt;&lt; ' '), ...);
    std::cout &lt;&lt; '\n';
}

int main() {
    // Create an integer sequence of type int with values 0, 1, 2, 3, 4
    std::integer_sequence&lt;int, 0, 1, 2, 3, 4&gt; seq;
    print_sequence(seq); // Output: 0 1 2 3 4

}
</code></pre>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;utility&gt;

// Function to print elements of a tuple
template &lt;typename Tuple, std::size_t... Is&gt;
void print_tuple(const Tuple&amp; t, std::index_sequence&lt;Is...&gt;) {
    ((std::cout &lt;&lt; std::get&lt;Is&gt;(t) &lt;&lt; ' '), ...);
    std::cout &lt;&lt; '\n';
}

int main() {
    auto myTuple = std::make_tuple(1, 2.5, "Hello");

    // Create an index sequence for the tuple
    print_tuple(myTuple, std::index_sequence_for&lt;int, double, const char*&gt;{}); // Output: 1 2.5 Hello

    return 0;
}
</code></pre>
<p>definitions in std:</p>
<pre><code class="language-c++">template &lt;class...Ts&gt;
index_sequence_for = make_index_sequence&lt;sizeof...(Ts)&gt;;

template &lt;size_t N&gt;
make_index_sequence = make_integer_sequence&lt;size_t, N&gt;;

template &lt;class T, T N&gt;
make_integer_sequence = integer_sequence&lt;T, Ints...&gt;

template &lt;size_t...Ints&gt;
index_sequence = integer_sequence&lt;size_t, Ints...&gt;;

template &lt;class T, T...Ints&gt;
class integer_sequence;

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cast-stdshared_ptrs"><a class="header" href="#cast-stdshared_ptrs">cast std::shared_ptrs</a></h1>
<p>std library has necessary casting methods</p>
<ul>
<li>static_pointer_cast</li>
<li>dynamic_pointer_cast</li>
<li>const_pointer_cast</li>
<li>reinterpret_pointer_cast</li>
</ul>
<blockquote>
<p>the result will share ownership with arg. if casting fails dynamic_pointer_cast returns nullptr like dynamic_cast so ownership fails either.</p>
</blockquote>
<pre><code class="language-c++">
class base {
   public:
    base() = default;
    base(int x) : x(x) {}
    virtual ~base() = default;
    virtual void print() const {
        std::cout &lt;&lt; "base..." &lt;&lt; "x: " &lt;&lt; x &lt;&lt; std::endl;
    }
    int x = 0;
};

class derived : public base {
   public:
    derived() = default;
    ~derived() = default;
    derived(int x, int y) : base(x), y(y) {}
    void print() const override {
        std::cout &lt;&lt; "derived..." &lt;&lt; "x: " &lt;&lt; x &lt;&lt; " y: " &lt;&lt; y &lt;&lt; std::endl;
    }

    int y = 0;
};

int main() {
    using std::shared_ptr;

    {
        shared_ptr&lt;const derived&gt; csp = std::make_shared&lt;const derived&gt;(1, 2);
        shared_ptr&lt;derived&gt; sp = const_pointer_cast&lt;derived&gt;(csp);
        sp-&gt;print();
    }
    {
        {
            // origin: derived
            // results: derived
            shared_ptr&lt;base&gt; bp = std::make_shared&lt;derived&gt;(1, 2);
            bp-&gt;print();
            auto dp = static_pointer_cast&lt;derived&gt;(bp);
            dp-&gt;print();
        }
        {
            // origin: base
            // results: base
            shared_ptr&lt;base&gt; bp = std::make_shared&lt;base&gt;(1);
            bp-&gt;print();
            auto dp = static_pointer_cast&lt;derived&gt;(bp);
            dp-&gt;print();
        }
    }
    {
        {
            // origin: derived
            // results: ok &amp; derived
            shared_ptr&lt;base&gt; bp = std::make_shared&lt;derived&gt;(1, 2);
            bp-&gt;print();
            if (auto dp = dynamic_pointer_cast&lt;derived&gt;(bp); dp) {
                dp-&gt;print();
            }
        }
        {
            // origin: base
            // results: fail &amp; base
            shared_ptr&lt;base&gt; bp = std::make_shared&lt;base&gt;(1);
            bp-&gt;print();
            // fails
            if (auto dp = dynamic_pointer_cast&lt;derived&gt;(bp); dp) {
                dp-&gt;print();
            }
        }
    }
    {
        {
            // origin: derived
            // results: ok &amp; derived
            shared_ptr&lt;base&gt; bp = std::make_shared&lt;derived&gt;(1, 2);
            bp-&gt;print();
            if (auto dp = reinterpret_pointer_cast&lt;derived&gt;(bp); dp) {
                dp-&gt;print();
            }
        }
        {
            // origin: base
            // results: ok &amp; base
            shared_ptr&lt;base&gt; bp = std::make_shared&lt;base&gt;(1);
            bp-&gt;print();
            // fails =&gt; dp acts as base type and derived part sliced
            if (auto dp = reinterpret_pointer_cast&lt;derived&gt;(bp); dp) {
                dp-&gt;print();
            }
        }
    }
}

</code></pre>
<blockquote>
<p>shared_ptr has a special ctor for these casting calls. in cppreference page you can find how they are implemented but in short, they get the raw pointer and use static_cast, const_cast, dynamic_cast ar reinterpret_cast on it. then create another shared_ptr to share ownership and returns the result...important point here is you should never touch inner raw pointer like deleting etc... you have to keep alive it because shared_ptr will use it for value reading/writing</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-double-deletion-with-shared_ptr"><a class="header" href="#create-double-deletion-with-shared_ptr">create double deletion with shared_ptr</a></h1>
<p>shared_ptr and unique_ptr are smart pointers. they are owners of the heap memory and they must manage it themselves. somehow getting raw pointer handles from them and wrapping it with another smart pointer will create a mess.</p>
<pre><code class="language-c++">class base {
   public:
    base() = default;
    base(int x) : x(x) {}
    virtual ~base() = default;
    virtual void print() const {
        std::cout &lt;&lt; "base..." &lt;&lt; "x: " &lt;&lt; x &lt;&lt; std::endl;
    }
    int x = 0;
};

class derived : public base {
   public:
    derived() = default;
    ~derived() = default;
    derived(int x, int y) : base(x), y(y) {}
    void print() const override {
        std::cout &lt;&lt; "derived..." &lt;&lt; "x: " &lt;&lt; x &lt;&lt; " y: " &lt;&lt; y &lt;&lt; std::endl;
    }

    int y = 0;
};

int main() {
    using std::make_shared;
    using std::shared_ptr;

    {
        shared_ptr&lt;derived&gt; sp = make_shared&lt;derived&gt;(1, 2);
        shared_ptr&lt;base&gt; bp{static_cast&lt;base*&gt;(sp.get())};

        std::cout &lt;&lt; sp.use_count() &lt;&lt; ":" &lt;&lt; bp.use_count() &lt;&lt; std::endl;
    }
}


</code></pre>
<pre><code class="language-c++">1:1

stderr:
double free or corruption (out)
Program terminated with signal: SIGSEGV

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-streambuf-iterator"><a class="header" href="#use-streambuf-iterator">use streambuf iterator</a></h1>
<p>an iterator in c++ that allows to read or write to stream buffer.</p>
<ul>
<li>works with raw bytes</li>
<li>doesn't do formatted reading or writing</li>
<li>doesn't skip special characters like null, space etc</li>
<li>works on char / byte level</li>
<li>works with stream types</li>
<li>use streams rdbuf() to get core stream source which can be linked to streabuf_iterator</li>
</ul>
<pre><code class="language-c++">
// redirecting cin to cout

#include &lt;algorithm&gt;
#include &lt;iostream&gt;

int main() {
    using std::cin, std::cout;
    using std::copy;
    using std::istreambuf_iterator, std::ostreambuf_iterator;

    istreambuf_iterator&lt;char&gt; beg{cin}, end;
    ostreambuf_iterator&lt;char&gt; out{cout};

    // istreambuf_iterator&lt;char&gt; beg{cin.rdbuf()};
    // ostreambuf_iterator&lt;char&gt; out{cout.rdbuf()};

    copy(beg, end, out);

</code></pre>
<pre><code class="language-c++">int main() {
    char data[] = "hakan gedek";
    std::istringstream iss{data};

    std::istreambuf_iterator&lt;char&gt; beg{iss}, end{};

    std::string output{beg, end};

    std::cout &lt;&lt; output &lt;&lt; std::endl;
}
</code></pre>
<pre><code class="language-c++">int main() {
    char data[] = "hakan gedek";
    std::istringstream iss{data};
    std::ostringstream oss{};

    std::istreambuf_iterator&lt;char&gt; beg{iss}, end{};
    std::ostreambuf_iterator&lt;char&gt; out{oss};

    std::copy(beg, end, out);

    std::cout &lt;&lt; oss.str() &lt;&lt; std::endl;

    return 0;

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-std-streams"><a class="header" href="#use-std-streams">use std streams</a></h1>
<ul>
<li>stream types re wrapper types around some input / output devices which re called *buf objects
<ul>
<li>streambuf</li>
<li>filebuf</li>
<li>spanbuf</li>
<li>...</li>
</ul>
</li>
<li>you have 2 area
<ul>
<li>get</li>
<li>put</li>
</ul>
</li>
<li>each area has specific operation methods in stream and buf types
<ul>
<li>seekg</li>
<li>tellg</li>
<li>seekp</li>
<li>tellp</li>
</ul>
</li>
<li>these methods are not related...if you read your gptr of read moves on stream but that doesn't effect the write pointer so you should need sync them if you need
<ul>
<li>seekp(tellg()) ... bring writer to current pos of reader</li>
</ul>
</li>
<li>there re 2 group of operation
<ul>
<li>formatted
<ul>
<li>&lt;&lt;</li>
<li>&gt;&gt;</li>
</ul>
</li>
<li>unformatted
<ul>
<li>many methods
<ul>
<li>put</li>
<li>putback</li>
<li>get</li>
<li>getline</li>
<li>unget</li>
<li>read</li>
<li>write</li>
<li>readsome</li>
<li>gcount</li>
<li>peek</li>
<li>ignore</li>
</ul>
</li>
</ul>
</li>
<li>unformatted handles data as byte array so you will need to convert your target/src data to char* with sizeof it</li>
<li>unformatted allows you to control how to read / write data using delims or size etc...</li>
</ul>
</li>
<li>rdbuf allows you to access device lying under stream object</li>
<li>rdbuf allows you to share same device with in/out stream types like you can use cout device !</li>
<li>when you set rdbuf object it also returns original so keep it and set it back</li>
<li>a stream object can be
<ul>
<li>good
<ul>
<li>no problem</li>
</ul>
</li>
<li>fail
<ul>
<li>recover with clear and continue if you wish</li>
</ul>
</li>
<li>bad
<ul>
<li>not recoverable</li>
</ul>
</li>
<li>eof
<ul>
<li>stops</li>
</ul>
</li>
</ul>
</li>
<li>exceptions not enabled but using .exceptions(flag) we can enable it and if stream obj enters into that state it throws</li>
<li>tie: takes ostream type so you can tie in and out ostream objects...cin.tie(&amp;cout)...so when cin used it firstly flush to cout...</li>
<li>you can set flags either using setf or unsetf or you can use manipulators function pointers like &lt;&lt; std::skipws etc...
<ul>
<li>some of them belong to same mask group
<ul>
<li>dec</li>
<li>oct</li>
<li>hex
<ul>
<li>basedfield
<ul>
<li>setf(dec, basefield)</li>
</ul>
</li>
</ul>
</li>
<li>left</li>
<li>right</li>
<li>internal
<ul>
<li>adjustfield</li>
</ul>
</li>
<li>scientific</li>
<li>fixed
<ul>
<li>floatfield</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>iostate is a unsigned int which used as a mask to hold state data...you can bitwise bits
<ul>
<li>ios::goodbit</li>
<li>ios::failbit</li>
<li>ios::badbit</li>
<li>ios::eofbit</li>
</ul>
</li>
<li>seekdir manages positioning enums...
<ul>
<li>beg</li>
<li>cur</li>
<li>end
<ul>
<li>use to move related pointers over stream</li>
</ul>
</li>
</ul>
</li>
<li>streams re convertible to bool or void* so
<ul>
<li>if operations fails pointers stops at the pos and stream obj returns and if you check it in if () or while it will say it's state
<ul>
<li>good =&gt; true</li>
<li>others =&gt; false
<ul>
<li>while ((ss &gt;&gt; word)) {}</li>
<li>if ( ss &gt;&gt; ch)</li>
<li>if (ss.get(name, 10, 0)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>0 == '\0' : ascii table 0th item</li>
<li>opening modes
<ul>
<li>in
<ul>
<li>to read</li>
</ul>
</li>
<li>out
<ul>
<li>to write</li>
</ul>
</li>
<li>ate
<ul>
<li>at start pointer moves to end but you can move around the pointers</li>
</ul>
</li>
<li>app
<ul>
<li>pointer moves to end of stream and it always stay there : not movable</li>
</ul>
</li>
<li>trunc
<ul>
<li>clear everything</li>
</ul>
</li>
<li>binary
<ul>
<li>not formatted</li>
</ul>
</li>
<li>you can open a file in multiple modes
<ul>
<li>in | out</li>
<li>in | out | ate</li>
<li>in | out | trunc</li>
<li>out | app</li>
<li>in | app</li>
<li>...
<ul>
<li>you can open input streams with out too🙂
<ul>
<li>ifstream index { "index", ios::in | ios::out | ios::trunc}
<ul>
<li>at the end you re opening a file</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>if you ve 2 area together like stringstream; when passing modes { read -&gt; write or write -&gt; read }
<ul>
<li>always use seekg / seekp otherwise it will not work</li>
</ul>
</li>
</ul>
<p>At the end almost all methods belong to buffers...</p>
<ul>
<li>streambuf</li>
<li>filebuf</li>
<li>stringbuf</li>
<li>spanbuf</li>
</ul>
<p>and they don't have a in/out type difference; there is only one type of buf... but stream types have 2 - in or out and this difference is for methos to access like read or write but at the end buf is same ( io device ) so you can share and use between...</p>
<pre><code class="language-c++">ifstream file{"file", ios::in | ios::trunc | ios::out };
ostream out (file.rdbuf()); // we set the buf as in and out ..so buf is allowed to use both in and out...i'm accessing in features over ifstream but out features on ostream
</code></pre>
<p>using get and getline with streams:</p>
<pre><code class="language-c++">#include &lt;sstream&gt;
#include &lt;iostream&gt;

using namespace std;

int main() {
    stringstream ss;

    char const name[] = "hakan";
    char const surname[] = "gedek";

    ss.write(name, sizeof name);
    ss.write(surname, sizeof surname);

    cout &lt;&lt; ss.tellp() &lt;&lt; endl;

    string sname(10, '\0'), ssurname(10, '\0');

    ss.getline(&amp;sname[0], 10, 0);

    cout &lt;&lt; ss.tellg() &lt;&lt; endl;

    ss.getline(&amp;ssurname[0], 10, 0);

    cout &lt;&lt; ss.tellg() &lt;&lt; endl;
    cout &lt;&lt; sname &lt;&lt; ":" &lt;&lt; ssurname &lt;&lt; endl;
}

</code></pre>
<p>formatted ops: &lt;&lt; and &gt;&gt;</p>
<p>unformatted:</p>
<ul>
<li>read</li>
<li>write</li>
<li>get</li>
<li>getline</li>
<li>put</li>
<li>ignore</li>
<li>putback</li>
<li>unget</li>
<li>gcount</li>
</ul>
<blockquote>
<p>at the end a stream has either get or put area or both... each has a current pointer and start and end pointer for stream... so you control them tellg seekg tellp seekp methods.. which they actually use streambuf operations that you can access over rdbuf</p>
</blockquote>
<h2 id="iostate"><a class="header" href="#iostate">iostate</a></h2>
<p>state flag of the stream</p>
<p>goodbit : no error
failbit : io failed but recoverable
badbit: failed and not recoverable
eofbit: input sequence reached to end</p>
<p>EOF =&gt; defined macro and value is -1</p>
<p>setstate(iostate)
rdstate() -&gt; iostate
clear() -&gt; clears</p>
<p>iostate =&gt; unsigned</p>
<h2 id="write-modes"><a class="header" href="#write-modes">write modes</a></h2>
<ul>
<li>app
<ul>
<li>always writes to end of the stream - pointer cant move</li>
</ul>
</li>
<li>out
<ul>
<li>pointer starts from 0th index to overwrite the stream</li>
</ul>
</li>
<li>trunc
<ul>
<li>clear contents</li>
</ul>
</li>
<li>ate
<ul>
<li>pointers moves to end of the stream at first</li>
<li>pointer is flexible to move anywhere so it's under dev control over stream</li>
</ul>
</li>
</ul>
<h2 id="file-modes"><a class="header" href="#file-modes">file modes</a></h2>
<div class="table-wrapper"><table><thead><tr><th>mode</th><th>openmode &amp; ~ate</th><th>Action if file already exists Action if file does not exist</th></tr></thead><tbody>
<tr><td>"r"</td><td>in</td><td>Read from start Failure to open</td></tr>
<tr><td>"w"</td><td>out, out|trunc</td><td>Destroy contents Create new</td></tr>
<tr><td>"a"</td><td>app, out|app</td><td>Append to file Create new</td></tr>
<tr><td>"r+"</td><td>out|in</td><td>Read from start Error</td></tr>
<tr><td>"w+"</td><td>out|in|trunc</td><td>Destroy contents Create new</td></tr>
<tr><td>"a+"</td><td>out|in|app, in|app</td><td>Write to end Create new</td></tr>
<tr><td>"wx"</td><td>out|noreplace, out|noreplace|trunc</td><td>Failure to open Create new</td></tr>
<tr><td>"w+x"</td><td>out|in|noreplace|trunc</td><td>Failure to open Create new</td></tr>
<tr><td>"rb"</td><td>binary|in Read from start</td><td>Failure to open</td></tr>
<tr><td>"wb"</td><td>binary|out, binary|out|trunc</td><td>Destroy contents Create new</td></tr>
<tr><td>"ab"</td><td>binary|app, binary|out|app</td><td>Write to end Create new</td></tr>
<tr><td>"r+b"</td><td>binary|out|in</td><td>Read from start Error</td></tr>
<tr><td>"w+b"</td><td>binary|out|in|trunc</td><td>Destroy contents Create new</td></tr>
<tr><td>"a+b"</td><td>binary|out|in|app, binary|in|app</td><td>Write to end Create new</td></tr>
<tr><td>"wbx"</td><td>binary|out|noreplace, binary|out|noreplace|trunc</td><td>Failure to open Create new</td></tr>
<tr><td>"w+bx"</td><td>binary|out|in|noreplace|trunc</td><td>Failure to open Create new</td></tr>
</tbody></table>
</div>
<h2 id="stream-positioning"><a class="header" href="#stream-positioning">stream positioning</a></h2>
<p>ostream</p>
<ul>
<li>tellp</li>
<li>seekp</li>
</ul>
<p>istream:</p>
<ul>
<li>tellg</li>
<li>seekg</li>
</ul>
<p>both uses :beg, :cur, :end as start pos for positioning
both uses tell* to identify the current positioning</p>
<h2 id="read--write---together"><a class="header" href="#read--write---together">read &amp; write - together</a></h2>
<p>to use read &amp; write in any order you need to use seekp &amp; seekg to activate correct stream...otherwise it fails.</p>
<pre><code class="language-c++">
fstream f("file", ios::in | ios::out);
string str;

f &gt;&gt; str; // extract first word

f.seekp(0, ios::cur); // activate writer at the cur pos
f &lt;&lt; "hakan";

f.seekg(0, ios::cur);
f &gt;&gt; str;

</code></pre>
<p>seekg : activate istream
seekp : activate ostream</p>
<p>when passing between istream / ostream use clear -&gt; otherwise failing...check snippet:</p>
<pre><code class="language-c++">    fstream f{"/tmp/file", ios::in | ios::out};

    if (not f) {
        f.clear();
        cerr &lt;&lt; "failed\n";
        f.open("/tmp/file", ios::in | ios::out | ios::trunc);
    }
    if (not f) {
        cerr &lt;&lt; "opening `/tmp/file` failed" &lt;&lt; '\n';
        return -1;
    }
    cerr &lt;&lt; "we are at:" &lt;&lt; f.tellp() &lt;&lt; '\n';

    f &lt;&lt; "hello hakan gedek";
    cerr &lt;&lt; "we are at:" &lt;&lt; f.tellp() &lt;&lt; '\n';

    f.seekg(0);
    string s;

    getline(f, s);

    cout &lt;&lt; s &lt;&lt; endl;
</code></pre>
<blockquote>
<p>if ios::fail is true =&gt; use clear to clear the stream</p>
</blockquote>
<blockquote>
<p>if position &lt; 0 =&gt; use clear to pos the cursor correctly</p>
</blockquote>
<pre><code class="language-c++">#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main() {

    fstream f{"/tmp/file", ios::in | ios::out | ios::trunc};

    f &lt;&lt; "hakan gedek";

    string s;
    cout.setf(ios::boolalpha);

    f.seekg(0);
    cout &lt;&lt; f.fail() &lt;&lt; ":" &lt;&lt; f.bad() &lt;&lt; '\n';

    getline(f, s);
    cout &lt;&lt; f.fail() &lt;&lt; ":" &lt;&lt; f.bad() &lt;&lt; '\n';

    f.clear();

    cout &lt;&lt; s &lt;&lt; '\n';

    f.seekp(0, ios::end);
    cout &lt;&lt; f.tellp() &lt;&lt; endl;

    f &lt;&lt; " aksaray";
    cout &lt;&lt; f.tellp() &lt;&lt; endl;

    f.clear();
    f.seekg(0);

    getline(f, s);
    cout &lt;&lt; s &lt;&lt; endl;

    return 0;
}
</code></pre>
<h2 id="extracting-from-stream-in-loop"><a class="header" href="#extracting-from-stream-in-loop">extracting from stream in loop</a></h2>
<p>&gt;&gt; and &lt;&lt; =&gt; moves forward the iterator</p>
<p>use sstream items</p>
<ul>
<li>istringstream</li>
<li>ostringstream</li>
<li>stringstream
for memory streams</li>
</ul>
<pre><code class="language-c++">istringstream iss{"123 455"};

while (not iss.eof() and not iss.bad())
{
    int x;
    iss &gt;&gt; x;
    cout &lt;&lt; x &lt;&lt; endl;
}
</code></pre>
<h2 id="ostream"><a class="header" href="#ostream">ostream</a></h2>
<ul>
<li>put(char)</li>
<li>write(buffer, len)</li>
</ul>
<p>opening</p>
<ul>
<li>app
<ul>
<li>append to existing</li>
<li>create if not exist</li>
<li>always writes to end of the file ..positioning doesnt work</li>
</ul>
</li>
<li>ate
<ul>
<li>append to existing</li>
<li>can wander inside the file using positioning</li>
<li>to keep the contents | with other flags like ::in for opening to write
<ul>
<li>ate | in</li>
</ul>
</li>
</ul>
</li>
<li>out
<ul>
<li>create if necessary</li>
<li>trunc</li>
</ul>
</li>
<li>trunc
<ul>
<li>existing opened and cleared</li>
</ul>
</li>
</ul>
<p>in | out =&gt; readable / writable but file should be exist
in | out | trunc =&gt; readable / writable but created empty first</p>
<h2 id="istream"><a class="header" href="#istream">istream</a></h2>
<p>get and getline</p>
<pre><code class="language-c++">get(buffer, len, delim)
getline(buffer, len, delim)

diff ?
- getline removes the delim from stream...get keeps

</code></pre>
<p>getline removes the delim from the stream and stops
get doesn't remove the delim but stops</p>
<ul>
<li>ignore()</li>
<li>ignore(len)</li>
<li>ignore(len, delim)</li>
<li>peek()
<ul>
<li>return the next char</li>
</ul>
</li>
<li>putback(char)
<ul>
<li>push back the char as next char</li>
</ul>
</li>
<li>read(buffer, len)</li>
<li>gcount
<ul>
<li>count of the character read</li>
</ul>
</li>
<li>readsome(buffer, len)
<ul>
<li>no flag setting for eof/fail
<ul>
<li>allows to track the file ?</li>
</ul>
</li>
</ul>
</li>
<li>unget
<ul>
<li>returns back the last read char to stream
<ul>
<li>auto putback</li>
</ul>
</li>
</ul>
</li>
<li>get
<ul>
<li>3 forms
<ul>
<li>int get() : returns the next char as int</li>
<li>istream&amp; get(char&amp;)
<ul>
<li>read the char to ch and keep state into istream</li>
</ul>
</li>
<li>istream&amp; get(buffer, len, delim)
<ul>
<li>getline style with keeping all in the stream</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>getline
<ul>
<li>get the line without keeping the delim</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-iterator-adaptors"><a class="header" href="#use-iterator-adaptors">use iterator adaptors</a></h1>
<p>c++ has <code>iterator</code> header which contains different iterator implementations. using iterator types we can access containers with isolating their types. different iterators work for different containers. also this headar support some adaptors to ease to create and use them.</p>
<ul>
<li>back_inserter</li>
<li>front_inserter</li>
<li>inserter</li>
<li>move_iterator</li>
<li>reverse_iterator</li>
</ul>
<blockquote>
<p>I used generate_n to create data but if you have a source of data like string, vector, deque, list...you can combine them with algorithms methods which take generic params ( iterators) and routes the results to target iterators which you can place iterator helpers/adaptors here.</p>
</blockquote>
<pre><code class="language-c++">int main() {
    // move_iterator: make_move_iterator
    {
        // moveable type
        std::deque&lt;std::string&gt; names{"hakan", "gedek", "turk"};
        std::vector&lt;std::string&gt; copy_of_names{names.begin(), names.end()};
        // original
        std::copy(names.begin(), names.end(),
                  std::ostream_iterator&lt;std::string&gt;(std::cout, " "));
        std::cout &lt;&lt; '\n';
        // copy list
        std::copy(copy_of_names.begin(), copy_of_names.end(),
                  std::ostream_iterator&lt;std::string&gt;(std::cout, " "));
        std::cout &lt;&lt; '\n';

        std::vector&lt;std::string&gt; move_of_names{
            std::make_move_iterator(names.begin()),
            std::make_move_iterator(names.end())};

        // it's empty here -&gt; memory contains only empty string because inner char* ptr is assigned to target's new string as data; moved.
        std::copy(names.begin(), names.end(),
                  std::ostream_iterator&lt;std::string&gt;(std::cout, " "));
        std::cout &lt;&lt; '\n';

        std::copy(move_of_names.begin(), move_of_names.end(),
                  std::ostream_iterator&lt;std::string&gt;(std::cout, " "));
        std::cout &lt;&lt; '\n';
    }
    // reverse_iterator: make_reverse_iterator
    {
        auto l = {1, 2, 3, 4, 5, 6};

        auto re = std::make_reverse_iterator(l.begin());
        auto rb = std::make_reverse_iterator(l.end());

        std::copy(rb, re, std::ostream_iterator&lt;int&gt;(std::cout, " "));
        std::cout &lt;&lt; '\n';

        std::vector&lt;int&gt; v(rb, re);
        std::copy(v.begin(), v.end(),
                  std::ostream_iterator&lt;int&gt;(std::cout, " "));
        std::cout &lt;&lt; '\n';
    }

    // back_inserter: back_insert_iterator
    {
        std::vector&lt;int&gt; v;
        v.reserve(10);

        std::generate_n(std::back_inserter(v), 10, [] {
            static int count = 0;
            return count++;
        });
        std::copy(v.begin(), v.end(),
                  std::ostream_iterator&lt;int&gt;(std::cout, " "));
        std::cout &lt;&lt; '\n';
    }

    // inserter: insert_iterator
    {
        std::vector&lt;int&gt; v;
        v.reserve(10);

        std::generate_n(std::inserter(v, v.end()), 10, [] {
            static int count = 0;
            return count++;
        });
        std::copy(v.begin(), v.end(),
                  std::ostream_iterator&lt;int&gt;(std::cout, " "));
        std::cout &lt;&lt; '\n';

        v.clear();

        std::generate_n(std::inserter(v, v.begin()), 10, [] {
            static int count = 0;
            return count++;
        });
        std::copy(v.begin(), v.end(),
                  std::ostream_iterator&lt;int&gt;(std::cout, " "));
        std::cout &lt;&lt; '\n';
    }

    // front_inserter: front_insert_iterator
    {
        std::deque&lt;int&gt; v;

        std::generate_n(std::front_inserter(v), 10, [] {
            static int count = 0;
            return count++;
        });
        std::copy(v.begin(), v.end(),
                  std::ostream_iterator&lt;int&gt;(std::cout, " "));
        std::cout &lt;&lt; '\n';
    }
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compare-iterator-with-reverse-iterator"><a class="header" href="#compare-iterator-with-reverse-iterator">compare iterator with reverse iterator</a></h1>
<p>reverse_iterator or make_reverse_iterator helpers create a reverse_iterator from iterators...to get opposite we can use <code>base</code> method of reverse_iterator</p>
<p><code>std::reverse_iterator(it).base() == it</code></p>
<pre><code class="language-c++">
int main() {
    {
        std::vector&lt;std::string&gt; names{"hakan", "gedek", "turk"};

        assert(std::make_reverse_iterator(names.begin()).base() ==
               names.begin());
    }

    {
        // swap the string
        std::string names[] = {"hakan", "turk"};

        // odd
        auto it = names[0].begin();
        auto rit = names[0].rbegin();

        while (it &lt; rit.base()) {
            std::swap(*it, *rit);
            it++;
            rit++;
        }
        std::cout &lt;&lt; names[0] &lt;&lt; '\n';

        // even
        it = names[1].begin();
        rit = names[1].rbegin();

        while (it &lt; rit.base()) {
            std::swap(*it, *rit);
            it++;
            rit++;
        }
        std::cout &lt;&lt; names[1] &lt;&lt; '\n';
    }

    return 0;
}
</code></pre>
<blockquote>
<p>dont forget; base() comes after reverse position in normal order.</p>
</blockquote>
<pre><code class="language-c++">// let's think this array
[1,2,3,4]

4's position is 3

rbegin() =&gt; shows 4
rbegin().base() =&gt; after 4 or end(). ??

rbegin() =&gt; reverse_iterator(end()) =&gt; end() - 1
rend() =&gt; reverse_iterator(begin()) =&gt; begin() + 1

rbegin().base() =&gt; pos + 1 =&gt; end()
rend().base() =&gt; pos - 1 =&gt; begin()

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-function-negator"><a class="header" href="#use-function-negator">use function negator</a></h1>
<p>std::not_fn: it's a functor to negate a another functor</p>
<pre><code class="language-c++">
// functor or functions which can be called in std::not_fn

// - function
// - operator() in class/struct
// - static method
// - lambda

bool cmp(int lhs, int rhs) { return lhs &lt; rhs; }

struct functor {
    bool operator()(int lhs, int rhs) { return lhs &lt; rhs; }
};

struct my_cmp {
    static bool cmp(int lhs, int rhs) { return lhs &lt; rhs; }
};

int main() {
    {
        std::vector v = {2, 3, 1, 5, 2, 4};
        std::sort(v.begin(), v.end(), std::less&lt;int&gt;{});
        std::copy(v.begin(), v.end(),
                  std::ostream_iterator&lt;int&gt;(std::cout, " "));

        std::cout &lt;&lt; "\n";

        // not_fn takes functor
        std::sort(v.begin(), v.end(), std::not_fn(std::less&lt;int&gt;{}));
        std::copy(v.begin(), v.end(),
                  std::ostream_iterator&lt;int&gt;(std::cout, " "));

        std::cout &lt;&lt; "\n";
        std::sort(v.begin(), v.end(), std::not_fn(cmp));
        std::copy(v.begin(), v.end(),
                  std::ostream_iterator&lt;int&gt;(std::cout, " "));

        std::cout &lt;&lt; "\n";
        std::sort(v.begin(), v.end(),
                  std::not_fn([](int lhs, int rhs) { return lhs &lt; rhs; }));
        std::copy(v.begin(), v.end(),
                  std::ostream_iterator&lt;int&gt;(std::cout, " "));

        std::cout &lt;&lt; "\n";
        std::sort(v.begin(), v.end(), std::not_fn(functor{}));
        std::copy(v.begin(), v.end(),
                  std::ostream_iterator&lt;int&gt;(std::cout, " "));

        std::cout &lt;&lt; "\n";
        std::sort(v.begin(), v.end(), std::not_fn(my_cmp::cmp));
        std::copy(v.begin(), v.end(),
                  std::ostream_iterator&lt;int&gt;(std::cout, " "));
    }

    return 0;
}


</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="split-a-string-with-different-methods"><a class="header" href="#split-a-string-with-different-methods">split a string with different methods</a></h1>
<h2 id="views-adaptor"><a class="header" href="#views-adaptor">views adaptor</a></h2>
<p>c++20, views has adaptor <strong>split</strong> to split ranges which include string, string_view too (both are containers of char)</p>
<pre><code class="language-c++">
#include &lt;ranges&gt;
#include &lt;iostream&gt;

namespace views = std::views;
namespace ranges = std::ranges;

int main() {
    std::string text = "hakan;gedek;turkey;uk";

    // doesn't copy but creates ref of them
    auto split_view = text | views::split(';');

    // so when accessing them; if you don't intend to copy them intentionaly
    // always prefer &amp;
    for (auto&amp;&amp; part : split_view) {
        std::cout &lt;&lt; std::string_view{part} &lt;&lt; std::endl; // just referring them
    }
}

</code></pre>
<h2 id="istream_iterator"><a class="header" href="#istream_iterator">istream_iterator</a></h2>
<p>using istream_iterator we can split but only uses whitespaces.</p>
<pre><code class="language-c++">#include &lt;iterator&gt;
#include &lt;sstream&gt;

int main() {
    std::string text = "hakan gedek coventry uk";
    std::istringstream iss{text};

    std::istream_iterator&lt;std::string&gt; beg{iss}, end{};

    while (beg != end) {
        std::cout &lt;&lt; *beg &lt;&lt; std::endl;
        beg++;
    }
}
</code></pre>
<h2 id="getline"><a class="header" href="#getline">getline</a></h2>
<p>works with streams and also accepts delims</p>
<pre><code class="language-c++">
#include &lt;iterator&gt;
#include &lt;sstream&gt;

int main() {
    {
        std::string text = "hakan gedek coventry uk";
        std::istringstream iss{text};
        std::string word;

        while (iss &gt;&gt; word) {
            std::cout &lt;&lt; '[' &lt;&lt; word &lt;&lt; ']';
        }

        std::cout &lt;&lt; std::endl;
    }
    {
        std::string text = "hakan gedek coventry uk";
        std::istringstream iss{text};
        std::string word;

        while (std::getline(iss, word, ' ')) {
            std::cout &lt;&lt; '[' &lt;&lt; word &lt;&lt; ']';
        }

        std::cout &lt;&lt; std::endl;
    }
    {
        std::string text = "hakan;gedek;coventry;uk";
        std::istringstream iss{text};
        std::string word;

        while (std::getline(iss, word, ';')) {
            std::cout &lt;&lt; '[' &lt;&lt; word &lt;&lt; ']';
        }
    }
}

</code></pre>
<h2 id="string-methods"><a class="header" href="#string-methods">string methods</a></h2>
<p>std::string has <code>find_first_of</code>, <code>find_first_not_of</code>, <code>first_last_of</code> and <code>first_last_of_not</code> methods which are useful if you are searching things from a collection of delims.</p>
<pre><code class="language-c++">auto npos = std::string::npos;

std::vector&lt;std::string&gt; split(std::string const&amp; str, const char* delims) {
    auto beg = 0, end = 0;

    std::vector&lt;std::string&gt; words;

    end = str.find_first_of(delims, beg);

    while (end != npos) {
        words.emplace_back(str.begin() + beg, str.begin() + end);
        beg = end + 1;
        end = str.find_first_of(delims, beg);
    }

    if (beg != 0) {
        words.emplace_back(str.begin() + beg, str.end());
    }

    return words;
}

int main() {
    {
        std::string text = "hakan gedek coventry uk";
        auto words = split(text, " ;:,");

        for (const auto&amp; word : words) {
            std::cout &lt;&lt; '[' &lt;&lt; word &lt;&lt; ']';
        }
        std::cout &lt;&lt; std::endl;
    }
    {
        std::string text = "hakan;gedek;coventry;uk";
        auto words = split(text, " ;:,");

        for (const auto&amp; word : words) {
            std::cout &lt;&lt; '[' &lt;&lt; word &lt;&lt; ']';
        }
        std::cout &lt;&lt; std::endl;
    }
}

</code></pre>
<h2 id="cstring-methods"><a class="header" href="#cstring-methods">cstring methods</a></h2>
<p>c has it's own methods like <code>strchr</code> and <code>strtok</code></p>
<pre><code class="language-c++">
int main() {
    // strtok
    {
        char data[] = "hakan;gedek;coventry;uk";
        char const* delims = " ;:,";
        char* token = strtok(data, delims);
        while (token != nullptr) {
            std::cout &lt;&lt; '[' &lt;&lt; token &lt;&lt; ']';
            token = strtok(nullptr, delims);  // arg0 == nullptr;
        }
        // but try original data
        std::cout &lt;&lt; std::endl;
        std::cout &lt;&lt; data &lt;&lt; std::endl;
        // it will print first word because it's manipulated with '\0'
        // nullptr is used as first param because it's not stateless but
        // keeps the sent char[] internally - static
    }
    // strchr
    {
        // not checking mixed delims but picking one of them
        char data[] = "hakan;gedek;coventry;uk";
        char delims[] = " ;:,";
        const char* beg = data;
        const char* end = data;

        while (end != nullptr &amp;&amp; *end != '\0') {
            for (auto ch : delims) {
                if (auto it = strchr(beg, ch); it) {
                    end = it;
                    std::cout &lt;&lt; '[' &lt;&lt; std::string_view{beg, end} &lt;&lt; ']';
                    beg = end + 1;
                    break;
                }
            }
            ++end;
        }
    }

</code></pre>
<h2 id="ranges-istream_view"><a class="header" href="#ranges-istream_view">ranges istream_view</a></h2>
<pre><code class="language-c++">
#include &lt;ranges&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;

int main()
{
    auto words = std::istringstream{"today is yesterday’s tomorrow"};

    for (const auto&amp; s : std::views::istream&lt;std::string&gt;(words))
        std::cout &lt;&lt; std::quoted(s, '/') &lt;&lt; ' ';

    std::cout &lt;&lt; '\n';
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-function-pointers"><a class="header" href="#use-function-pointers">use function pointers</a></h1>
<p>using typedef we can create alias for functions but we can do it in 2 ways</p>
<p>function pointers is as fast as lambdas but faster than std::function objects.</p>
<pre><code class="language-c++">
#include &lt;print&gt;

// not common but function type - use it with *
typedef int Fn(char const*, char const*);
// classic
typedef int (*FN)(char const*, char const*);

// or

// using Fn = int(char const*, char const*);
// using FN = int (*)(char const*, char const*);
// using FnA = auto (*)(char const*, char const*) -&gt; int;

int cmp(char const* src, char const* dst) {
    if (src == nullptr &amp;&amp; dst == nullptr)
        return 0;
    else if (src == nullptr)
        return -1;
    else if (dst == nullptr)
        return 1;
    else {
        while (*src != '\0' &amp;&amp; *dst != '\0') {
            if (*src != *dst) {
                if (*src &gt; *dst)
                    return 1;
                else
                    return -1;
            }
            src++;
            dst++;
        }
        if (*src != '\0' &amp;&amp; *dst == '\0')
            return 1;
        else if (*src == '\0' &amp;&amp; *dst != '\0')
            return -1;
    }
    return 0;
}
int main() {
    Fn* fptr = cmp;
    Fn&amp; fn = cmp;
    FN fp = cmp;
    std::println("{} {} {}", fptr("hakan", "haka"), fp("hakan", "haka"),
                 fn("hakna", "haka"));
    return 0;
}

</code></pre>
<h2 id="unique_ptr-as-callables"><a class="header" href="#unique_ptr-as-callables">unique_ptr as callables</a></h2>
<p>let's try it by using unique_ptr</p>
<pre><code class="language-c++">#include &lt;functional&gt;
#include &lt;memory&gt;
#include &lt;print&gt;

using cb_t = void (*)(int, char const*);

void foo(int id, char const* name) { std::println("{} {}", id, name); }

// this is class template so ctor(T&amp;&amp;) means real rvalues - not extended to lvalue references
template &lt;class Fn&gt;
struct callback {
    callback(Fn&amp;&amp; fn)
        : _fptr{std::make_unique&lt;Fn&gt;(std::forward&lt;Fn&gt;(fn))} {
    }  // use forward with forwarded references always

    template &lt;class... Args&gt;
    void operator()(Args&amp;&amp;... args) {
        std::invoke(*_fptr, std::forward&lt;Args&gt;(args)...);
    }

    template &lt;class... Args&gt;
    void operator()(Args&amp;&amp;... args) const {
        std::invoke(*_fptr, std::forward&lt;Args&gt;(args)...);
    }

    std::unique_ptr&lt;Fn&gt; _fptr;
};

int main() {
    // without cb_t : it fails
    callback&lt;cb_t&gt; cb{foo};

    cb(0, "hakan gedek");

    return 0;
}

</code></pre>
<h2 id="c-style-callbacks"><a class="header" href="#c-style-callbacks">c-style callbacks</a></h2>
<pre><code class="language-c++">struct event_handler {
    typedef void (*start)(int, char const*);
    typedef void (*pause)(int, char const*);
    typedef void (*end)(char const*);
    start _start;
    pause _pause;
    end _end;
};

void start(int id, char const* name) {
    std::println("started {} {}", id, name);
}

void pause(int id, char const* name) { std::println("paused {} {}", id, name); }

void end(char const* name) { std::println("ended {}", name); }

int main() {
    event_handler handler;
    handler._start = start;
    handler._pause = pause;
    handler._end = end;
    handler._start(0, "hakan");
    handler._pause(0, "hakan");
    handler._end("hakan");

    std:println("{} {} {}", sizeof(handler._start), sizeof(handler._pause),
                 sizeof(handler._end));

}
</code></pre>
<pre><code class="language-c++">
started 0 hakan
paused 0 hakan
ended hakan
8 8 8
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-special-pointer-types"><a class="header" href="#use-special-pointer-types">use special pointer types</a></h1>
<p>aside standart pointer type <code>T*</code> there are some special signatures</p>
<h2 id="function-pointer-1"><a class="header" href="#function-pointer-1">function pointer</a></h2>
<p>this is explained in <strong>how to use function pointers</strong> note - check it.</p>
<h2 id="pointer-to-array"><a class="header" href="#pointer-to-array">pointer to array</a></h2>
<p>format: <code>Type (*Name)[Size]</code></p>
<pre><code class="language-c++">
int arr[5] = {1,2,3,4,5};
int (*ptr)[5] = &amp;arr; // valid
int* ptr = arr; // also valid

</code></pre>
<h2 id="array-of-pointers"><a class="header" href="#array-of-pointers">array of pointers</a></h2>
<p>format: <code>T* Name[Size]</code></p>
<pre><code class="language-c++">
int x = 0;
int y = 0;
int z = 0;

int* ptrs[3] = {&amp;x, &amp;y, &amp;z};

// if * seems complicated ; you can prefer aliasing it

using int_ptr_t = int*;

int_ptr_t arr[3] = {&amp;x, &amp;y, &amp;z}; // liken int arr[3]

</code></pre>
<h2 id="pointer-to-member-function"><a class="header" href="#pointer-to-member-function">pointer to member function</a></h2>
<p>this is pointer to member functions (not static ones)</p>
<p>format: <code>Type (ClassName::*Name)(args)</code></p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;functional&gt;

class MyClass {
   public:
    void foo(int arg, const char* name) {
        std::cout &lt;&lt; "arg: " &lt;&lt; arg &lt;&lt; " name: " &lt;&lt; name &lt;&lt; std::endl;
    }
};

// variable but not type
void (MyClass::*fooPtr)(int, const char*);

// old typeing - aliasing
typedef void (MyClass::*fooPtrType)(int, const char*);

// new typeing - aliasing
using myclass_foo_t = void (MyClass::*)(int, const char*);

int main() {
    // init the `var`
    fooPtr = &amp;MyClass::foo;

    fooPtrType fptr = &amp;MyClass::foo;

    myclass_foo_t fptr1 = &amp;MyClass::foo;

    MyClass obj{};

    // call
    (obj.*fooPtr)(0, "hakan gedek");

    (obj.*fptr)(1, "hakan gedek");

    (obj.*fptr1)(3, "hakan gedek");

    // invoke-call
    std::invoke(fooPtr, obj, 0, "hakan gedek");

    std::invoke(fptr, obj, 1, "hakan gedek");

    std::invoke(fptr1, obj, 3, "hakan gedek");
}

</code></pre>
<h2 id="pointer-to-member-field"><a class="header" href="#pointer-to-member-field">pointer to member field</a></h2>
<p>this is pointer to fields of class/struct</p>
<p>format: <code>Type ClassName::*Name</code></p>
<pre><code class="language-c++">
#include &lt;functional&gt;
#include &lt;iostream&gt;

class MyClass {
   public:
    int id{};
};

int MyClass::* IdVar;

typedef int MyClass::* IdType;

using myclass_id_t = int MyClass::*;

int main() {
    IdVar = &amp;MyClass::id;

    IdType id1 = &amp;MyClass::id;

    myclass_id_t id2 = &amp;MyClass::id;

    MyClass obj{101};

    // call

    std::cout &lt;&lt; obj.*IdVar &lt;&lt; std::endl;

    std::cout &lt;&lt; obj.*id1 &lt;&lt; std::endl;

    std::cout &lt;&lt; obj.*id2 &lt;&lt; std::endl;

    // invoke

    std::cout &lt;&lt; std::invoke(IdVar, obj) &lt;&lt; std::endl;

    std::cout &lt;&lt; std::invoke(id1, obj) &lt;&lt; std::endl;

    std::cout &lt;&lt; std::invoke(id2, obj) &lt;&lt; std::endl;

}

</code></pre>
<h2 id="non-pointer-reference-to-array-extra"><a class="header" href="#non-pointer-reference-to-array-extra">non-pointer reference to array (extra)</a></h2>
<p>this is just something special too - let's note it here before forgetting.</p>
<p>format: <code>Type (&amp;name)[Size]</code></p>
<pre><code class="language-c++">
template &lt;class T, int N&gt;
constexpr auto get_size_of_array(T(&amp;)[N]) {
    return N;
}

void print_array(int(&amp;arr)[5]) {
    for (auto i = 0; i &lt; 5; i++) {
        std::cout &lt;&lt; arr[i] &lt;&lt; ' ';
    }
}

int main() {
    constexpr int arr[5] = {1,2,3,4,5};
    static_asssert(get_size_of_array(arr) == 5);

    int arr2[5] = {1,2,3,4,5};
    print_array(arr2);
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-static-factory-method"><a class="header" href="#use-static-factory-method">use static factory method</a></h1>
<p>when you called constructor of a class you might get exception and unfortunately destructor will not be called. you can wrap constructor with very ugly <code>try - catch</code> block but I wouldn't advice it.</p>
<p>then why not using a static factory method and hiding the constructors ? this will allow you to catch exceptions, validate input params etc...</p>
<blockquote>
<p>this is not about patterns - you can find many special website for pattern examples in c++ but this is a pre-validation for args solution</p>
</blockquote>
<pre><code class="language-c++">class MyClassEx {
   public:
    char* ptr;

    MyClassEx(int arg) {
        ptr = new char[1024];
        if (arg &lt; 0) throw std::invalid_argument("value must &gt; 0");
    }
    ~MyClassEx() {
        std::cout &lt;&lt; "dtor called" &lt;&lt; std::endl;
        delete[] ptr;
    }
};

class MyClass {
    char* ptr;

    MyClass(int arg) {
        ptr = new char[1024];
        if (arg &lt; 0) throw std::invalid_argument("value must &gt; 0");
    }

   public:
    ~MyClass() {
        std::cout &lt;&lt; "dtor called" &lt;&lt; std::endl;
        delete[] ptr;
    }
    static MyClass create(int arg) {
        if (arg &lt; 0) throw std::invalid_argument("value must &gt; 0");
        return MyClass{arg};
    }
};

int main() {
    try {
        // dtor not called so mem leaked
        auto ins = MyClassEx(-1);
    } catch (std::invalid_argument const&amp; ex) {
        std::cout &lt;&lt; ex.what() &lt;&lt; std::endl;
    }

    try {
        // didn't allocate memory
        auto ins = MyClass::create(-1);
    } catch (std::invalid_argument const&amp; ex) {
        std::cout &lt;&lt; ex.what() &lt;&lt; std::endl;
    }

}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-castings"><a class="header" href="#use-castings">use castings</a></h1>
<p>c++ casting <strong>functions</strong> : yes they're functions so anything is valid with any function is valid for them too !</p>
<ul>
<li>static_cast</li>
<li>dynamic_cast</li>
<li>reinterpret_cast</li>
<li>const_cast</li>
</ul>
<blockquote>
<p>these are special and they are not topic of this note</p>
</blockquote>
<ul>
<li><del>bit_cast</del></li>
<li><del>any_cast</del></li>
<li><del>saturate_cast</del></li>
<li><del>duration_cast</del></li>
</ul>
<blockquote>
<p>reference to reference casting is very different than reference to value or value to value casting. you don't create a new item when doing ref to ref casting</p>
</blockquote>
<blockquote>
<p>call calls are methods and they are not magical stuff</p>
</blockquote>
<p>what happens when you call static_cast with T, T&amp;... or assign it to T&amp; or T. well samethings happen when you call any function like:</p>
<pre><code class="language-c++">
struct base {};
struct derived: base {};

template &lt;typename To, typename From&gt;
To my_static_cast(From data) {
    //if To and From has &amp; data it won't call any ctor or cctor or ohter...
    // like any function if you use static_cast&lt;T&gt; then you will create a copy when returning
    // if you assign it to a T then you call for cctor or cop from returned value
    // but if you assign it to a T&amp; or cast to a &lt;T&amp;&gt; you will not call any special function = like you do with any function ! No magic !
}


int main() {

    derived d;
    base&amp; b = d; // upcasting
    derived&amp; d = static_cast&lt;derived&amp;&gt;(b); // downcasting : no call to cctor, cop

    derived d = static_cast&lt;derived&amp;&gt;(b); // called cop
    derived d = static_cast&lt;derived&gt;(b); // called ctor(base&amp;) and cop !!! you can try all...
    ...
}

</code></pre>
<h2 id="static_cast"><a class="header" href="#static_cast">static_cast</a></h2>
<blockquote>
<p>supports pointer &lt;T*&gt; and reference &lt;T&amp;&gt; casts</p>
</blockquote>
<blockquote>
<p>static_cast: doesn't use rtti and type checking is done at compilation - doesn't check it at runtime.</p>
</blockquote>
<blockquote>
<p>down-casting can be problematic if the inner type of the rvalue is not derived but a real base type which means you don't have derived type memory space and static_cast will ignore it and give you a derived type which will have <strong>undefined</strong> stuff in it so best be cautious with this</p>
</blockquote>
<p>a comprehensive example with all possibilities:</p>
<pre><code class="language-c++">
class base {
   public:
    virtual ~base() = default;
};
class derived : public base {
   public:
    void foo() {}
};

int main() {
    int ival = 3;
    // value type casting
    float fval = static_cast&lt;float&gt;(ival);

    derived dobj;
    base&amp; bobj = static_cast&lt;base&amp;&gt;(dobj);  // upcasting - works without static_cast too
    derived&amp; dref = static_cast&lt;derived&amp;&gt;(bobj);  // downcasting
    dref.foo();

    base* bptr = &amp;dobj;  // upcasting
    derived* dptr = static_cast&lt;derived*&gt;(bptr);
    dptr-&gt;foo();

    void* vptr = static_cast&lt;void*&gt;(dptr);
    dptr = static_cast&lt;derived*&gt;(vptr);
    dptr-&gt;foo();

    // undefined behaviour
    {
        base* b = new base{};
        derived* d = static_cast&lt;derived*&gt;(b);
        d-&gt;foo(); /// ? this doesn't exist  =&gt; UB
    }
}

</code></pre>
<h2 id="const_cast"><a class="header" href="#const_cast">const_cast</a></h2>
<blockquote>
<p>supports pointer &lt;T*&gt; and reference &lt;T&amp;&gt; casts</p>
</blockquote>
<blockquote>
<p>const_cast: can add or remove const from result.</p>
</blockquote>
<pre><code class="language-c++">void foo(int const&amp; x) {
    int&amp; y = const_cast&lt;int&amp;&gt;(x);
    y = 2;
}

int main() {
    int x = 0;
    foo(x);

    assert(x == 2);

    return 0;
</code></pre>
<h2 id="dynamic_cast"><a class="header" href="#dynamic_cast">dynamic_cast</a></h2>
<blockquote>
<p>supports pointer &lt;T*&gt; and reference &lt;T&amp;&gt; casts but ony for polymorphic (virtual implemented) types - not for normal inheritance which you can use static_cast instead</p>
</blockquote>
<blockquote>
<p>dynamic_cast: rtti based - runtime casting. it can success or fail. If it fails it returns nullptr if it's pointer casting or throws std::bad_cast exception if it's reference casting. <strong>be careful</strong></p>
</blockquote>
<pre><code class="language-c++">
struct base {
    virtual ~base() = default;
};
struct derived : base {};

struct unrelated {};

int main() {
    base* bptr = new derived();
    derived* dptr = dynamic_cast&lt;derived*&gt;(bptr);
    assert(dptr != nullptr);

    derived d;
    base&amp; b = d;
    derived&amp; dref = dynamic_cast&lt;derived&amp;&gt;(b);

    try {
        derived d;
        base&amp; b = d;
        unrelated&amp; u = dynamic_cast&lt;unrelated&amp;&gt;(b);
    } catch (std::exception const&amp; e) { // std::bad_cast
        std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
    }

    return 0;

</code></pre>
<h2 id="reinterpret_cast"><a class="header" href="#reinterpret_cast">reinterpret_cast</a></h2>
<blockquote>
<p>supports pointer &lt;T*&gt; and reference &lt;T&amp;&gt; casts</p>
</blockquote>
<blockquote>
<p>reinterpret_cast: I call this byte_cast. it casts low-level (bit level)- it's in your control and it's open to UB (undefined behaviour) so be sure types are compatible.</p>
</blockquote>
<pre><code class="language-c++">
using std::byte;

struct base {
    int x;
};

struct derived : base {
    int y;
};

int main() {
    // byteing
    {
        int x = 101;

        byte* bptr = reinterpret_cast&lt;byte*&gt;(&amp;x);

        for (auto i = 0; i &lt; 4; i++) {
            std::cout &lt;&lt; int(*(bptr + i)) &lt;&lt; ' ';
        }

        std::cout &lt;&lt; std::endl;
    }

    // static_cast job
    {
        derived d;
        d.x = 101;
        d.y = 102;
        base&amp; b = reinterpret_cast&lt;base&amp;&gt;(d);
        std::cout &lt;&lt; b.x &lt;&lt; std::endl;

        derived&amp; dref = reinterpret_cast&lt;derived&amp;&gt;(b);
        std::cout &lt;&lt; dref.x &lt;&lt; ":" &lt;&lt; dref.y &lt;&lt; std::endl;
    }

    // void*
    {
        char name[] = "hakan gedek";
        void* vptr = reinterpret_cast&lt;void*&gt;(name);
        std::cout &lt;&lt; "address: " &lt;&lt; vptr &lt;&lt; std::endl;
        const char* cptr = reinterpret_cast&lt;char const*&gt;(vptr);
        std::cout &lt;&lt; strlen(cptr) &lt;&lt; std::endl;
        std::cout &lt;&lt; cptr &lt;&lt; std::endl;
    }

</code></pre>
<p>check also <strong>how to use casting correctly</strong> note</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-casting-correctly"><a class="header" href="#use-casting-correctly">use casting correctly</a></h1>
<blockquote>
<p>casting calls are functions so passing params to functions are valid here too ( pass by ref and pass by value)</p>
</blockquote>
<blockquote>
<p>if you change static_cast&lt; derived&amp; &gt; to static_cast&lt; derived &gt; you will fail because you will be trying to create a new derived object with base&amp; so you need to implement it yourself.</p>
</blockquote>
<blockquote>
<p>if you delete copy consructor and copy assignment operators and try to casting:</p>
</blockquote>
<pre><code class="language-c++">
struct base {};
struct derived : base {
    derived() = default;
    ~derived() = default;

   private:
    derived(derived const&amp;) = default;
    derived(derived&amp;&amp;) = default;
    derived&amp; operator=(derived const&amp;) = default;
    derived&amp; operator=(derived&amp;&amp;) = default;
};

int main() {
    derived d;

    base&amp; b = static_cast&lt;derived&amp;&gt;(d);      // works
    derived&amp; d1 = static_cast&lt;derived&amp;&gt;(b);  // works

    // fails -&gt; cctor is not accessible ( deleted or hidden)
    // d = static_cast&lt;derived&amp;&gt;(b);

</code></pre>
<blockquote>
<p>reference casting with dynamic_cast will not return nullptr but throw std::bad_cast</p>
</blockquote>
<pre><code class="language-c++">
struct base { virtual ~base() = default; };
struct derived: base {};

struct whoami {};

int main() {
    derived d;
    base&amp; b = d;
    derived&amp; dr = dynamic_cast&lt;derived&amp;&gt;(b); // works

    try {
        whoami&amp; w = dynamic_cast&lt;whoami&amp;&gt;(b);
    }catch(std::bad_cast const&amp; e) {
        // you're here now
    }
}

</code></pre>
<blockquote>
<p>reinterpret_cast doesn't check anything but casts bit to bit / byte to byte so it will skip checks - you need to be sure with result</p>
</blockquote>
<blockquote>
<p>static_cast will do down_cast if from and to types are related but if the inner type of from is not to; then you will have half cooked result without correct data which is undefined behaviour</p>
</blockquote>
<pre><code class="language-c++">
struct base {};
struct derived: base {};

int main() {
    base* b = new base;
    derived* d = static_cast&lt;derived*&gt;(b); // works but half cooked result...inner type of the data is base, not derived so it has never have derived memory scope
}

</code></pre>
<blockquote>
<p>you can cast anything from/to <strong>void*</strong> via reinterpret_cast but be careful with the result.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-virtual-inheritance"><a class="header" href="#use-virtual-inheritance">use virtual inheritance</a></h1>
<p>used when you have diagonal inheritance...</p>
<pre><code class="language-c++">        A
      /   \
     B     C
      \   /
        D
</code></pre>
<p>why need ? constructor and destructor calls will break the hierarchy so you will face some serious problems like multiple creation, multiple deletion or leaks etc...</p>
<pre><code class="language-c++">
class A{
   public:
    A() {
        std::cout &lt;&lt; "default A" &lt;&lt; std::endl;
        throw;
    }
    A(int) { std::cout &lt;&lt; "A ctor" &lt;&lt; std::endl; }
    ~A() { std::cout &lt;&lt; "A dtor" &lt;&lt; std::endl; }
};

class B : virtual public A {
   public:
    B(int arg) : A(arg) { std::cout &lt;&lt; "B ctor" &lt;&lt; std::endl; }

    ~B() { std::cout &lt;&lt; "B dtor" &lt;&lt; std::endl; }
};

class C : virtual public A {
   public:
    C(int arg) : A(arg) { std::cout &lt;&lt; "C ctor" &lt;&lt; std::endl; }
    ~C() { std::cout &lt;&lt; "C dtor" &lt;&lt; std::endl; }
};

class D : public B, public C {
   public:
    D(int arg) : A(arg), B(arg), C(arg) { std::cout &lt;&lt; "D ctor" &lt;&lt; std::endl; }
    ~D() { std::cout &lt;&lt; "D dtor" &lt;&lt; std::endl; }
};

class E : public D {
   public:
    // E(int arg) : D(arg) {} =&gt; fails =&gt; this is problematic so best is using default
    E(int arg) : A(arg), D(arg) {}
};

int main() {
    {
        D d(0);
    }
    std::cout &lt;&lt; std::endl;
    {
        E e(0);
    }

    return 0;
}

</code></pre>
<p>Don't forget:</p>
<blockquote>
<p>the <code>D</code> has to call first <code>A(arg)</code> if it doesn't use default <code>A()</code> or it will never access top most base special ctor</p>
</blockquote>
<blockquote>
<p>try =&gt; remove A(arg) from the order and run it</p>
</blockquote>
<blockquote>
<p>from E; you can see that inheritance becames a headache so best is that if you have a diagonal hierachy then stop using special constructor in top most base and use default ctor with default fields</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-associative-containers"><a class="header" href="#use-associative-containers">use associative containers</a></h1>
<ul>
<li>
<p>set</p>
<ul>
<li>sorted</li>
<li>unique items</li>
</ul>
</li>
<li>
<p>multiset</p>
<ul>
<li>sorted</li>
<li>grouped =&gt; select primary keys and create a column of data</li>
</ul>
</li>
<li>
<p>map</p>
<ul>
<li>sorted by key</li>
<li>unique by key</li>
</ul>
</li>
<li>
<p>multimap</p>
<ul>
<li>sorted by key</li>
<li>grouped by key =&gt; select keys and crate a column of data</li>
</ul>
</li>
<li>
<p>unordered_set</p>
<ul>
<li>unique items</li>
</ul>
</li>
<li>
<p>unordered_multiset</p>
<ul>
<li>unique items</li>
<li>grouped =&gt; select primary keys and create a column of data</li>
</ul>
</li>
<li>
<p>unordered_map</p>
<ul>
<li>unique by key</li>
</ul>
</li>
<li>
<p>unordered_multipmap</p>
<ul>
<li>unique by key</li>
<li>grouped by key =&gt; select primary keys and create a column of data</li>
</ul>
</li>
</ul>
<p>set | unordered_set: good for keeping unique items list...if you need sorted as extra use std::set... key = value ! this is not map so there is not a distinction of key:value...I will give example for important functions only in set but in others; I will not impl all. which using AI tools or cppreference you can find all.</p>
<p>use case: want unique values in a list =&gt; set | unordered_set
use case: want unique keys - don't care value for uniquness =&gt; map | unordered_map
use case: want views like database::views -&gt; let me query based on <code>operator&lt;</code> which decides the key and group the data in columns =&gt; multiset | unordered_multiset
use case: want views like database::views -&gt; let me query based on <code>operator&lt;</code> which decides the key and group the data in columns =&gt; multimap | unordered_multimap (key : value)</p>
<p>when unordereds ?</p>
<p>if the value (set) or key(map) is easy to calculate hash (long, int ...) then use it...I hate implementing hash algorithms myself because finding a good one is difficult but std is good so if your type is in the ones that have hash impl then use <code>unordered</code>.</p>
<pre><code class="language-c++">
#include &lt;set&gt;
#include &lt;iostream&gt;

struct Node {
    int x{};
    int y{};
};

// key =&gt; total of the x and y and set only uses this operator; others are not for set
constexpr bool operator&lt;(Node const&amp; lhs, Node const&amp; rhs) {
    return (lhs.x + lhs.y) &lt; (rhs.x + rhs.y);
}

constexpr bool operator==(Node const&amp; lhs, Node const&amp; rhs) {
    return lhs.x == rhs.x &amp;&amp; lhs.y == rhs.y;
}

constexpr std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, Node const&amp; node) {
    out &lt;&lt; node.x &lt;&lt; ":" &lt;&lt; node.y;
    return out;
}

int main() {
    std::set&lt;Node&gt; nodes;
    {
        // size
        // emplace
        // emplace_hint
        // insert
        nodes.emplace(0, 0);
        nodes.emplace(1, 1);
        nodes.emplace_hint(nodes.end(), 2, 1);
        nodes.insert(Node{3, 3});
        nodes.insert(Node(0, 3));  // 3 already exists

        std::cout &lt;&lt; "size: " &lt;&lt; nodes.size() &lt;&lt; std::endl;

        for (auto&amp; node : nodes) std::cout &lt;&lt; '[' &lt;&lt; node &lt;&lt; ']';

        std::cout &lt;&lt; std::endl;
    }
    {
        // count
        // find
        // begin, end
        // rbegin, rend
        auto r = nodes.count(Node{0, 0});
        std::cout &lt;&lt; "count{0,0}: " &lt;&lt; r &lt;&lt; std::endl;

        if (auto it = nodes.find(Node{1, 1}); it != nodes.end()) {
            std::cout &lt;&lt; "fond: " &lt;&lt; *it &lt;&lt; std::endl;
        }

        for (auto it = nodes.rbegin(); it != nodes.rend(); ++it)
            std::cout &lt;&lt; '[' &lt;&lt; *it &lt;&lt; ']';
        std::cout &lt;&lt; std::endl;
    }
    {
        // extract
        // clear
        // erase
        std::cout &lt;&lt; "size: " &lt;&lt; nodes.size() &lt;&lt; std::endl;
        if (auto it = nodes.find(Node{1, 1}); it != nodes.end()) {
            nodes.erase(it);
        }
        std::cout &lt;&lt; "size: " &lt;&lt; nodes.size() &lt;&lt; std::endl;

        for (auto&amp; node : nodes) std::cout &lt;&lt; '[' &lt;&lt; node &lt;&lt; ']';

        if (auto it = nodes.find(Node{0, 0}); it != nodes.end()) {
            auto e_node = nodes.extract(it);

            for (auto&amp; node : nodes) std::cout &lt;&lt; '[' &lt;&lt; node &lt;&lt; ']';

            e_node.value().x = 100;
            e_node.value().y = 100;

            nodes.insert(std::move(e_node));
            for (auto&amp; node : nodes) std::cout &lt;&lt; '[' &lt;&lt; node &lt;&lt; ']';
        }

        std::cout &lt;&lt; std::endl;

        nodes.clear();
        std::cout &lt;&lt; "size: " &lt;&lt; nodes.size() &lt;&lt; std::endl;
    }
}

</code></pre>
<p>multiset: what if I don't want uniqueness but grouping them as sorted ? why need ? well if you think data as int, yes you don't need and it's useless... you can keep a map&lt;int,int&gt; and for keys you can count the values etc... but this is not the use case of multiset...</p>
<p>you have a complex data and key is only calculated by one of the fields but other parts are all different like ? well think you want to group of students according to their graduation year...year is shared by many students but other data is completely different.</p>
<ul>
<li>sorted</li>
<li>grouped =&gt; this is important</li>
</ul>
<p>in this example i will think Year and FullName as primary keys of the container so <code>operator&lt;</code> will be around them.</p>
<blockquote>
<p>set makes 2 comparision - find the location and find the balance... a little bit process consumption so your comp operator will be called at least twice...</p>
</blockquote>
<pre><code class="language-c++">
struct Student {
    int GPA;
    int Year;
    std::string FullName;
};

constexpr std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, Student const&amp; student) {
    out &lt;&lt; '{' &lt;&lt; "FullName: " &lt;&lt; student.FullName &lt;&lt; " Year: " &lt;&lt; student.Year
        &lt;&lt; " GPA: " &lt;&lt; student.GPA &lt;&lt; '}';
    return out;
}

// only uses &lt;operator so you need to define comparision based on your primary
// keys like db I decided to use  year and fullname as primary keys

struct Comp {
    bool operator()(const Student&amp; lhs, const Student&amp; rhs) const {
        // using &amp;&amp; =&gt; is not same with ||
        // if result is always false then all will be together
        if (lhs.Year != rhs.Year) return lhs.Year &lt; rhs.Year;
        return lhs.FullName &lt; rhs.FullName;
    }
};

std::multiset&lt;Student, Comp&gt;::iterator find_student(
    Student const&amp; key, std::multiset&lt;Student, Comp&gt; const&amp; students) {
    auto range = students.equal_range(key);
    for (auto it = range.first; it != range.second; it++) {
        if (it-&gt;Year == key.Year &amp;&amp; it-&gt;FullName == key.FullName) return it;
    }
    return students.end();
}

int main() {
    std::multiset&lt;Student, Comp&gt; students;

    std::cout &lt;&lt; "size: " &lt;&lt; students.size() &lt;&lt; std::endl;

    students.insert(Student{3, 2020, "hakan gedek"});
    students.insert(Student{4, 2020, "hakan gedek"});
    students.insert(Student{4, 2019, "hakan gedek"});
    students.insert(Student{4, 2018, "hakan gedek"});
    students.insert(Student{2, 2020, "hakan edek"});
    students.insert(Student{1, 2020, "hakan dek"});

    std::cout &lt;&lt; "size: " &lt;&lt; students.size() &lt;&lt; std::endl;

    const auto [beg, end] =
        students.equal_range(Student{0, 2020, "hakan gedek"});
    for (auto it = beg; it != end; it++) {
        std::cout &lt;&lt; '[' &lt;&lt; it-&gt;Year &lt;&lt; ":" &lt;&lt; it-&gt;FullName &lt;&lt; ":" &lt;&lt; it-&gt;GPA
                  &lt;&lt; ']' &lt;&lt; std::endl;
    }

    const auto key = Student{1, 2020, "hakan dek"};
    if (auto it = find_student(key, students); it != students.end()) {
        std::cout &lt;&lt; "found" &lt;&lt; std::endl;
        std::cout &lt;&lt; '[' &lt;&lt; it-&gt;FullName &lt;&lt; ":" &lt;&lt; it-&gt;Year &lt;&lt; ":" &lt;&lt; it-&gt;GPA
                  &lt;&lt; ']' &lt;&lt; std::endl;
    }
}
</code></pre>
<p>but if you change the comp to only Year then you will group bucket list only to Year as primary key</p>
<pre><code class="language-c++">
struct Comp {
    bool operator()(const Student&amp; lhs, const Student&amp; rhs) const {
        return lhs.Year &lt; rhs.Year;
    }
};

</code></pre>
<p>and your result will change accordingly - year based group or year + name based group =&gt; play with them</p>
<p>I will talk about map and multimap too... unordered_*** are in general same too but they depend on hash&lt;T&gt; so you need to implement it for your custom type which we talked about it in <code>how to define hashable types</code> - check it.</p>
<p>map example =&gt;</p>
<pre><code class="language-c++">
struct Student {
    int GPA;

    struct Key {
        int Year;
        std::string FullName;
    } key;
};

constexpr bool operator&lt;(const Student::Key&amp; lhs, const Student::Key&amp; rhs) {
    if (lhs.Year != rhs.Year) return lhs.Year &lt; rhs.Year;
    return lhs.FullName &lt; rhs.FullName;
}

constexpr std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Student::Key&amp; key) {
    out &lt;&lt; '[' &lt;&lt; key.Year &lt;&lt; ":" &lt;&lt; key.FullName &lt;&lt; ']';
    return out;
}

constexpr std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Student&amp; student) {
    out &lt;&lt; '[' &lt;&lt; student.key.Year &lt;&lt; ":" &lt;&lt; student.key.FullName &lt;&lt; ":"
        &lt;&lt; student.GPA &lt;&lt; ']';
    return out;
}

int main() {
    std::map&lt;Student::Key, Student&gt; students;

    students.emplace(Student::Key{2020, "hakan gedek"},
                     Student{4, 2020, "hakan gedek"});
    students.emplace(Student::Key{2020, "hakan gedek"},
                     Student{4, 2020, "hakan gedek"});
    students.emplace(Student::Key{2019, "hakan gedek"},
                     Student{3, 2019, "hakan gedek"});
    students.emplace(Student::Key{2019, "hakan ged"},
                     Student{3, 2019, "hakan ged"});
    students.emplace(Student::Key{2018, "hakan gd"},
                     Student{2, 2018, "hakan gd"});

    std::cout &lt;&lt; "size: " &lt;&lt; students.size() &lt;&lt; std::endl;

    if (auto it = students.find(Student::Key{2019, "hakan gedek"});
        it != students.end()) {
        std::cout &lt;&lt; it-&gt;first &lt;&lt; " = " &lt;&lt; it-&gt;second &lt;&lt; std::endl;
    }

    std::cout &lt;&lt; students[{2020, "hakan gedek"}] &lt;&lt; std::endl;
    std::cout &lt;&lt; students[{2019, "hakan gedek"}] &lt;&lt; std::endl;
    std::cout &lt;&lt; students[{2019, "hakan ged"}] &lt;&lt; std::endl;
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-mutex"><a class="header" href="#use-mutex">use mutex</a></h1>
<p>c++ has many different type mutexes - shared, timed, timed and shared and normal... I will use only normal one.</p>
<p>mutex is a tool to block threads via OS calls.</p>
<pre><code class="language-c++">
#include &lt;atomic&gt;
#include &lt;mutex&gt;
#include &lt;print&gt;
#include &lt;thread&gt;

struct Account {
    int balance{};
    std::mutex m{};
    int dummy{};
};

int main() {
    auto acc_from = Account{100};
    auto acc_to = Account{0};

    {
        auto transfer_money = [](Account&amp; from, Account&amp; to, int amount) {
            auto lck_from = std::unique_lock{from.m, std::defer_lock};
            auto lck_to = std::unique_lock{to.m, std::defer_lock};
            std::lock(lck_from, lck_to);

            {
                from.balance -= amount;
                to.balance += amount;
            }
        };

        auto do_dummy_stuff = [](Account&amp; acc, int value) {
            auto lck = std::scoped_lock{acc.m};
            {
                acc.dummy += value;
            }
        };

        std::jthread j0{do_dummy_stuff, std::ref(acc_from), 10},
            j1{transfer_money, std::ref(acc_from), std::ref(acc_to), 30},
            j2{do_dummy_stuff, std::ref(acc_to), 10};
    }

    std::println("{} {}", acc_to.balance, acc_from.balance);

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generate-data"><a class="header" href="#generate-data">generate data</a></h1>
<p>using some sources and random lib; we can generate data... sources can be static or fed by outside like file etc.</p>
<pre><code class="language-c++">
    const std::string ALLOWED_CHARS =
        "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    std::string guid;

    // Sample 5 characters from ALLOWED_CHARS.
    std::sample(ALLOWED_CHARS.begin(), ALLOWED_CHARS.end(),
                std::back_inserter(guid), 5,
                std::mt19937{std::random_device{}()});

</code></pre>
<p>std lib has sample, shuffle methods to randomize given data.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-forwarding-references-correctly"><a class="header" href="#use-forwarding-references-correctly">use forwarding references correctly</a></h1>
<p>c++11 define <code>template &lt;typename T&gt; void foo(T&amp;&amp;)</code> as universal references or forwarding references. Key feature is keeping correct type of the variable in template is possible so we can understand if T is lvalue or rvalue. only valid for function templates - not class templates.</p>
<blockquote>
<p>rule: whenever you are using T&amp;&amp; (forwarding reference); when you access that type; wrap it with forward&lt;T&gt;(t)...that's all...</p>
</blockquote>
<pre><code class="language-c++">
struct S {
    void foo()&amp; { std::cout &lt;&lt; "lvalue" &lt;&lt; std::endl; }
    void foo()&amp;&amp; { std::cout &lt;&lt; "rvalue" &lt;&lt; std::endl; }
};

template &lt;typename T&gt;
void bar(T&amp;&amp; t) {
    t.foo();
}

template &lt;typename T&gt;
void baz(T&amp;&amp; t) {
    std::forward&lt;T&gt;(t).foo();
}

int main() {
    S s;

    // both uses foo()&amp; so both is lvalue
    bar(s);
    bar(S{}); // t is treated as an lvalue, calling foo() &amp;.

    baz(s); // lvalue
    baz(S{}); // rvalue
}

</code></pre>
<pre><code class="language-c++">
struct S {
    S() = default;
    S(const S&amp;) = delete;
    S(S&amp;&amp;) = default;

    void foo() &amp;&amp; {}

    void bar() {}
};

template &lt;typename T&gt;
void foo(T&amp;&amp; item) {
    item.foo(); // this doesnt work
    forward&lt;T&gt;(item).foo(); // this works

    item.bar(); // works
    forward&lt;T&gt;(item).bar(); // works =&gt; no condition to access to function (lvalue or rvalue)
}



int main() { foo(S{});

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="define-the-pure-virtual-method-in-base-class"><a class="header" href="#define-the-pure-virtual-method-in-base-class">define the pure virtual method in base class</a></h1>
<p>having a pure virtual function doesn't allow the class to be initialized because it's abstract but this doesn't stop us to define the function.</p>
<p>we can access them via derived functions so we can share logic</p>
<pre><code class="language-c++">
struct base {
    virtual void foo() = 0;
};

void base::foo() { std::cout &lt;&lt; "base::foo" &lt;&lt; std::endl; }

struct derived : base {
    void foo() override {
        std::cout &lt;&lt; "derived::foo" &lt;&lt; std::endl;
        base::foo();
    }
};

int main() {
    base* b = new derived();  // because it's abstract
    b-&gt;foo(); // will call derived::foo

    derived d;
    base&amp; b2 = d;
    b2.foo(); // will call derived::foo

    return 0;
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-late-and-early-binding"><a class="header" href="#use-late-and-early-binding">use late and early binding</a></h1>
<p>early binding: compilation time decided inheritance</p>
<p>late binding: polymoprhism and run time decided inheritance</p>
<p>early binding: steps...</p>
<ul>
<li>derived d created</li>
<li>d called process as being derived</li>
<li>in process it lost its derived type to base so it's base now</li>
<li>it will call hello of base type</li>
</ul>
<pre><code class="language-c++">struct base {
    void process() { hello(); }

   private:
    void hello() { std::cout &lt;&lt; "base::hello" &lt;&lt; std::endl; }
};

struct derived : base {
   private:
    void hello() {
        std::cout &lt;&lt; "derived::hello" &lt;&lt; std::endl;

        base::hello(); // calling base hello directly
    }
};

int main() {
    derived d;
    d.process();
}

</code></pre>
<pre><code class="language-c++">
base::hello

</code></pre>
<p>2 methods to stop this</p>
<ul>
<li>crtp</li>
<li>polymorphism</li>
</ul>
<p>you can find more details about crtp and polymorphism in related pages</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-member-field-initialization-correctly"><a class="header" href="#use-member-field-initialization-correctly">use member field initialization correctly</a></h1>
<p>c++ has member initialization feature which is very important if you are obsessed with memory allocations.</p>
<p>// this works</p>
<pre><code class="language-c++">
struct my_struct {
    my_struct() = delete;
    my_struct(int) {}
    my_struct(my_struct const&amp;) = default;
    my_struct&amp; operator=(my_struct const&amp;) = default;
};

struct wrapper {
    my_struct _data;

    wrapper(int arg) :  // yes : =&gt; this is member initialization spot =&gt; any ctor has that feature ?
    _data { arg } {}
};

int main() { wrapper w(1); }

</code></pre>
<p>// this fails</p>
<pre><code class="language-c++">
struct my_struct {
    my_struct() = delete;
    my_struct(int) {}
    my_struct(my_struct const&amp;) = default;
    my_struct&amp; operator=(my_struct const&amp;) = default;
};

struct wrapper {
    my_struct _data;

    wrapper(int arg) { _data = my_struct{arg}; }
};

int main() { wrapper w(1); }

</code></pre>
<p>if you postpone initializing the fields to ctor inner; compiler will call first the default ctor and create your field member and it will be initialized again with copy assignment operator which makes <strong>double</strong> memory allocation so for your custom types or heap types; use member initialization as much as possible - it's damn important feature, use it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="access-unaccessible-base-elements"><a class="header" href="#access-unaccessible-base-elements">access unaccessible base elements</a></h1>
<ul>
<li>
<p>delegation</p>
</li>
<li>
<p>impl own method and access it over scope operator</p>
</li>
</ul>
<pre><code class="language-c++">
// delegation
struct base {
   protected:
    void foo() { std::cout &lt;&lt; "foo" &lt;&lt; std::endl; }
    int x = 101;
};

struct derived : base {
    using base::foo;
    using base::x;
};

int main() {
    derived d;
    d.foo();
    std::cout &lt;&lt; d.x &lt;&lt; std::endl;

</code></pre>
<pre><code class="language-c++">
// wrapper or adapter
struct base {
protected:
    void foo() { std::cout &lt;&lt; "base::foo" &lt;&lt; std::endl; }
};

struct derived: base {
    void foo() {
        base::foo();
    }
};

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-using-declerations-to-skip-name-hidings"><a class="header" href="#use-using-declerations-to-skip-name-hidings">use using declerations to skip name hidings</a></h1>
<p>if a derived class declares a member with same name of base class member it hides it.</p>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;string&gt;

struct A {
    void setName(char const*) {}
};
struct B : A {
    void setName(char const*, int) {}
};
struct C : B {
    void setName(std::string name, float) {}
};
struct D : B {
    using A::setName;
    using B::setName;
    void setName(char (&amp;a)[10]) {}
};

using namespace std::string_literals;

int main() {
    C c;
    c.setName("hakan"s, 0.0f);  // works
    // c.setName("gedek"); // needs some help
    D d;
    d.setName("hakan");
    d.setName("hakan", 1);

    char name[10] = "hakan";
    d.setName(name);
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-using-declerations-to-borrow"><a class="header" href="#use-using-declerations-to-borrow">use using declerations to borrow</a></h1>
<p>very useful feature for multiple inheritance. you decorate your derived type with the selected stuff from parents.</p>
<pre><code class="language-c++">struct A {
    void foo() { std::cout &lt;&lt; "A" &lt;&lt; std::endl; }
};

struct B {
    void foo() { std::cout &lt;&lt; "B" &lt;&lt; std::endl; }
};

struct C: A, B {
    using B::foo;
};

int main() {
    C c;
    c.foo(); // prints =&gt; B =&gt; no collision
}

</code></pre>
<pre><code class="language-c++">struct base {
    base(int arg) { std::cout &lt;&lt; arg &lt;&lt; std::endl; }
};

struct derived : base {
    using base::base;
};

int main() { derived d{10}; }

</code></pre>
<p>this will generate:</p>
<pre><code class="language-c++">struct base
{
  inline base(int arg)
  {
    std::cout.operator&lt;&lt;(arg).operator&lt;&lt;(std::endl);
  }

};


struct derived : public base
{
  // inline derived() /* noexcept */ = delete;
  inline derived(int arg) noexcept(false)
  : base(arg)
  {
  }

};


int main()
{
  derived d = derived{10};
  return 0;
}

</code></pre>
<p>instead of coding we can borrow stuff from parents. especially if have multiple parent decl. we can pick them.</p>
<h2 id="borrowing-in-variadic-inheritance"><a class="header" href="#borrowing-in-variadic-inheritance">borrowing in variadic inheritance</a></h2>
<pre><code class="language-c++">
template &lt;typename ...Ts&gt;
struct X: Ts... {
  using Ts::foo...;
};


struct A {
  void foo() {}
};

struct B {
  void foo() {}
};

int main() {
  X&lt;A,B&gt; x;
}

</code></pre>
<p>generates:</p>
<pre><code class="language-c++">struct X: A, B {
  using A::foo, B::foo;
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-nested-classes"><a class="header" href="#use-nested-classes">use nested classes</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-lower_bound-and-upper_bound"><a class="header" href="#use-lower_bound-and-upper_bound">use lower_bound and upper_bound</a></h1>
<p>By default it's part of set and map associative containers but you can also use it on vector, list,... only requirement is target must be <strong>sorted</strong>.</p>
<pre><code class="language-c++">
int main() {
    multimap&lt;char const*, int&gt; months;
    months.emplace("january", 10);
    months.emplace("january", 21);
    months.emplace("april", 3);
    months.emplace("april", 33);
    months.emplace("april", 12);

    auto lower = months.lower_bound("april");
    auto upper = months.upper_bound("april");

    for (auto it = lower; it != upper; ++it) {
        std::cout &lt;&lt; '[' &lt;&lt; it-&gt;first &lt;&lt; ':' &lt;&lt; it-&gt;second &lt;&lt; ']';
    }

    std::cout &lt;&lt; std::endl;

</code></pre>
<p>use case: searching sub-range in <strong>sorted</strong> containers so it works well on set, multiset, map and multimap but if you sort others; you can use on them too but as you can guess; unsorted_* are not valid for them.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-operator-with-enums"><a class="header" href="#use-operator-with-enums">use operator| with enums</a></h1>
<p>implicit conversion will fail when enum is generated after some bitwise operations (&amp; , |). We can overload <code>operator|</code> to skip this problem. real problem is conversion from enum to underlying_type and back. so using static-cast we can achieve it. Here important point; enums are predefined constants so bitwise ops will generate values not exist in the enum values list.</p>
<pre><code class="language-c++">

enum FileAccess { READ = 1 &lt;&lt; 0, WRITE = 1 &lt;&lt; 1, EXEC = 1 &lt;&lt; 2 };

FileAccess operator|(FileAccess lhs, FileAccess rhs) {
    return static_cast&lt;FileAccess&gt;(
        static_cast&lt;std::underlying_type_t&lt;FileAccess&gt;&gt;(lhs) |
        static_cast&lt;std::underlying_type_t&lt;FileAccess&gt;&gt;(rhs));
}

void foo(FileAccess value) {
    std::cout &lt;&lt; std::underlying_type_t&lt;FileAccess&gt;(value) &lt;&lt; std::endl;
}

int main() {
    foo(READ | WRITE);  // fails without operator| overload : remove it and try
                        // - no implicit convertion

}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-explicit"><a class="header" href="#use-explicit">use explicit</a></h1>
<p>c++ is an implicit language - most of the stuff is done without our realizing... explicit can be used to stop it. you can place explicit to ctors, conversion operators etc... if you use it; your code will be more strict.</p>
<pre><code class="language-c++">
struct ExpMyS {
    int value;

    explicit ExpMyS(int val): value(val) {}
    explicit operator int() const { return value;}
};

struct MyS{
    int value;

    MyS(int val): value(val) {}
    operator int() const { return value;}
};

int main() {
    // explicit ops
    ExpMyS exs {10};
    int value = (int)exs;

    // implicit ops
    // ExpMyS exs2 = 10; // fails
    // int value2 = exs2; // fails;

    MyS ms = 10; // works
    int value3 =  ms;
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-conditional-noexcept"><a class="header" href="#use-conditional-noexcept">use conditional noexcept</a></h1>
<p>noexcept is a new feature of c++ to say: this function doesn't throw exception and allows for a better optimization but what if it throws ? UB</p>
<p>but it support conditional coding - you can validate passed func with noexcept(noexcept(func())) or you can put a condition directly like noexcept(condition)</p>
<pre><code class="language-c++">
void nothrow() noexcept {}

void maythrow() { throw std::runtime_error("crashed"); }

template &lt;typename T&gt;
void foo(T&amp;&amp; fn) noexcept(noexcept(fn())) {
    fn();
}

template &lt;typename T&gt;
void bar(T&amp;&amp; t) noexcept(sizeof(T) &lt;= 4) {
    if constexpr (sizeof(t) &lt;= 4) {
        std::cout &lt;&lt; "safe" &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; "not-safe" &lt;&lt; std::endl;
        throw std::runtime_error("crashed");
    }
}

int main() {
    foo(nothrow);
    try {
        foo(maythrow);
    } catch (std::exception const&amp; e) {
        std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
    }

    bar(10);

    try {
        bar(1.2);
    } catch (std::exception const&amp; e) {
        std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
    }


</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-copy-elision-and-rvo"><a class="header" href="#use-copy-elision-and-rvo">use copy elision and rvo</a></h1>
<p>new c++ features: copy elision and rvo ( return value optimization) | nrvo(named rvo - variable has local name). instead of creating a copy; it will move the source - by default - you don't need to call std::move for local.</p>
<p>rule is simple: only one of us can own the data - if it's shared you can use shared_ptr but it's still under control and will be de-allocated.</p>
<p>if I don't create a heap type it didn't trigger but from the example it can be seen that I will keep create::ob mem from local scope.</p>
<pre><code class="language-c++">
struct MyD {};

struct MyS {
    MyS() = default;
    MyS(const MyS&amp;) = delete;
    MyS&amp; operator=(const MyS&amp;) = delete;
    MyS(MyS&amp;&amp;) = default;
    MyS&amp; operator=(MyS&amp;&amp;) = default;

    // rvo test: create a heap type or it may not be triggered
    std::unique_ptr&lt;MyD&gt; _data = std::make_unique&lt;MyD&gt;();
};

// return value optimization: RVO
// local mem will be used again because here moves it back
MyS create() {
    MyS ob;
    std::cout &lt;&lt; (void*)(&amp;ob) &lt;&lt; std::endl;
    return ob;
}

void foo(MyS const&amp; ob) { std::cout &lt;&lt; (void*)(&amp;ob) &lt;&lt; std::endl; }
void bar(MyS&amp;&amp; ob) { std::cout &lt;&lt; (void*)(&amp;ob) &lt;&lt; std::endl; }
void baz(MyS ob) { std::cout &lt;&lt; (void*)(&amp;ob) &lt;&lt; std::endl; }

int main() {
    MyS ob = create();
    std::cout &lt;&lt; (void*)(&amp;ob) &lt;&lt; std::endl;

    foo(create());
    bar(create());
    bar(create());

    return 0;
}

</code></pre>
<pre><code class="language-c++">
0x7ffe53414e90
0x7ffe53414e90
0x7ffe53414e98
0x7ffe53414e98
0x7ffe53414ea0
0x7ffe53414ea0
0x7ffe53414ea8
0x7ffe53414ea8

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-stack-buffer-with-custom-newdelete"><a class="header" href="#use-stack-buffer-with-custom-newdelete">use stack buffer with custom new/delete</a></h1>
<p>as mentioned in custom new / delete operators for types; instead of using heap memory via new, malloc... we can prefer to use a stack buffer.</p>
<ul>
<li>
<p>new returns a void* pointer to position on buffer</p>
</li>
<li>
<p>ctor takes it and creates a MyClass over it - let the ctor does its job</p>
</li>
<li>
<p>delete is useless because it's stack not heap</p>
</li>
<li>
<p>dtor will be called to free it's own resources</p>
</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;new&gt;

class MyClass {
   public:
    // Overload new operator
    void* operator new(std::size_t size) {
        if (size &gt; bufferSize - bufferOffset) {
            throw std::bad_alloc();
        }
        void* ptr = buffer + bufferOffset;
        bufferOffset += size;
        std::cout &lt;&lt; "Custom new for MyClass, size: " &lt;&lt; size
                  &lt;&lt; ", address: " &lt;&lt; ptr &lt;&lt; std::endl;
        return ptr;
    }

    // Overload delete operator
    void operator delete(void* ptr) {
        std::cout &lt;&lt; "Custom delete for MyClass, address: " &lt;&lt; ptr &lt;&lt; std::endl;
        // No actual deallocation needed for stack buffer
    }

    MyClass() { std::cout &lt;&lt; "MyClass constructor" &lt;&lt; std::endl; }

    ~MyClass() { std::cout &lt;&lt; "MyClass destructor" &lt;&lt; std::endl; }

   private:
    static constexpr std::size_t bufferSize = 1024;
    static inline char buffer[bufferSize];
    static inline std::size_t bufferOffset = 0;
};

int main() {

    std::cout &lt;&lt; "sizeof MyClass: " &lt;&lt; sizeof(MyClass) &lt;&lt; std::endl;

    MyClass* obj1 = new MyClass();
    MyClass* obj2 = new MyClass();
    delete obj1;
    delete obj2;
    return 0;
}


</code></pre>
<pre><code class="language-c++">sizeof MyClass: 1
Custom new for MyClass, size: 1, address: 0x4041a0
MyClass constructor
Custom new for MyClass, size: 1, address: 0x4041a1
MyClass constructor
MyClass destructor
Custom delete for MyClass, address: 0x4041a0
MyClass destructor
Custom delete for MyClass, address: 0x4041a1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-newdelete-without-ctordtor"><a class="header" href="#use-newdelete-without-ctordtor">use new/delete without ctor/dtor</a></h1>
<p>let's use new/delete like malloc/free</p>
<p>we can use global new/delete operators</p>
<p>we can skip ctor/dtor for types - well useful for POD types etc.</p>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;new&gt;

struct MyS {
    MyS() { std::cout &lt;&lt; "MyS::ctor" &lt;&lt; std::endl; }
    ~MyS() { std::cout &lt;&lt; "MyS::dtor" &lt;&lt; std::endl; }
    int value;
};

int main() {
    MyS* p1 = new MyS();
    if (p1 != nullptr) {
        p1-&gt;value = 100;
        delete p1;
    }

    // instance
    MyS* p2 = static_cast&lt;MyS*&gt;(operator new(sizeof(MyS)));
    if (p2 != nullptr) {
        p2-&gt;value = 100;
        operator delete(p2);
    }

    // array
    MyS* p3 = static_cast&lt;MyS*&gt;(operator new(10 * sizeof(MyS)));
    if (p3 != nullptr) {
        for (auto i = 0; i &lt; 10; i++) {
            static_cast&lt;MyS*&gt;(p3 + i)-&gt;value = i * 100;
        }
        operator delete(p3);
    }

    // array
    MyS* p4 = static_cast&lt;MyS*&gt;(operator new[](10 * sizeof(MyS)));
    if (p4 != nullptr) {
        for (auto i = 0; i &lt; 10; i++) {
            p4[i].value = i * 100;
        }

        operator delete[](p4);
    }
}


</code></pre>
<blockquote>
<p>operator new() =&gt; a block of memory =&gt; using pointer arithmetics we can use block like array of T. use this only for one T not N * T ( prefer array)</p>
</blockquote>
<blockquote>
<p>operator new[]() =&gt; a memory of array =&gt; this is already an array of T...so best is using this for array of T</p>
</blockquote>
<ul>
<li>
<p>single T: T*</p>
</li>
<li>
<p>block memory of T: N x T*</p>
</li>
<li>
<p>array of objects: T[N]</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="initialize-enum-values-with-constexpr"><a class="header" href="#initialize-enum-values-with-constexpr">initialize enum values with constexpr</a></h1>
<p>enums are one of the true constant types and their values are set at compilation time so using other compilation time options we can set their values like constexprs.</p>
<pre><code class="language-c++">
struct CE {
    int _id;

    constexpr CE(int id) : _id(id) {}
    constexpr int Cid() const { return _id; }
};

constexpr CE ce{101};

constexpr int Gid() { return 10; }

enum Enum { X = ce.Cid(), Y = Gid(), Z = X + 10 };

int main() {
    std::cout &lt;&lt; int(Enum::X) &lt;&lt; ":" &lt;&lt; int(Enum::Y) &lt;&lt; ":" &lt;&lt; int(Enum::Z)
              &lt;&lt; std::endl;
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-true-constants"><a class="header" href="#use-true-constants">use true constants</a></h1>
<p>true constant types: at compilation time their values are known/calculated or executable so they are useful for compilation time coding.</p>
<ul>
<li>
<p>enum</p>
</li>
<li>
<p>constexpr</p>
</li>
<li>
<p>static consts</p>
</li>
</ul>
<pre><code class="language-c++">
// you can use one of these to define a max_count variable for compilation time
struct X {
    enum {
        max_count = 100
    };
};

struct Y {
    static constexpr auto max_count = 100;
};


struct Z {
    static const auto max_count = 100;
};

constexpr auto max_count() {
    return 100;
}

</code></pre>
<pre><code class="language-c++">
struct MyS {
    static const auto a = 100;
    static constexpr auto b = 100;
    enum { c = 100 };
};

int main() {
    static_assert(MyS::a == 100);
    static_assert(MyS::b == 100);
    static_assert(MyS::c == 100);
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="define-aggregate-types"><a class="header" href="#define-aggregate-types">define aggregate types</a></h1>
<ul>
<li>
<p>use struct</p>
</li>
<li>
<p>don't define ctor, dtor...</p>
</li>
<li>
<p>don't define private, protected stuff</p>
</li>
<li>
<p>no inheritance</p>
</li>
<li>
<p>no virtual</p>
</li>
</ul>
<pre><code class="language-c++">
struct Aggr {
    int x = 0;
    double y = 1.2;
    std::string z = "hakan";
};

int main() {
    Aggr _{
        0,
        1.5,
        "hakan gedek"
    };
}

</code></pre>
<p>POD: aggregate with trivial types { std::string is not trivial type}</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enable-exceptions-for-io"><a class="header" href="#enable-exceptions-for-io">enable exceptions for io</a></h1>
<p>by default it's not enabled so if it fails; just it sets the failbit...</p>
<pre><code class="language-c++">
ifstream in("text");
in &gt;&gt; value;

=&gt; in.fail() =&gt; 1 because text not exists... but it will not throw ...

ifstream in("text");
in.exceptions(in.failbit);
in &gt;&gt; value;

=&gt; throws... std::ios_base::failure&amp; =&gt; error type


</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="define-non-virtual-interface-idiom"><a class="header" href="#define-non-virtual-interface-idiom">define non-virtual interface idiom</a></h1>
<p>in my other posts; i was calling this swiss knife pattern :) well i like that naming more but you can call whatever you want !</p>
<p>used to define non virtual interface in base class and delegate to private virtual functions which are only defined by derived types.</p>
<ul>
<li>
<p>controls pre and post conditions before calling virtual functions which is good with validation requirements for functions</p>
</li>
<li>
<p>good for hiding derived types and all are controlled via base type</p>
</li>
</ul>
<pre><code class="language-c++">
class Base {
public:
    void foo() {
        // Pre-conditions or common code
        foo_impl();
        // Post-conditions or common code
    }

    void bar() {
        // Pre-conditions or common code
        bar_impl();
        // Post-conditions or common code
    }

    void baz() {
        // Pre-conditions or common code
        baz_impl();
        // Post-conditions or common code
    }

private:
    virtual void foo_impl() = 0;
    virtual void bar_impl() = 0;
    virtual void baz_impl() = 0;
};

class Derived : public Base {
private:
    void foo_impl() override {
        std::cout &lt;&lt; "Derived foo_impl" &lt;&lt; std::endl;
    }

    void bar_impl() override {
        std::cout &lt;&lt; "Derived bar_impl" &lt;&lt; std::endl;
    }

    void baz_impl() override {
        std::cout &lt;&lt; "Derived baz_impl" &lt;&lt; std::endl;
    }
};

void foo(Base&amp; b) {
    b.foo(); // Calls Derived::foo_impl
    b.bar(); // Calls Derived::bar_impl
    b.baz(); // Calls Derived::baz_impl
}

int main() {
    Derived d;
    foo(d);

    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-bit-fields"><a class="header" href="#use-bit-fields">use bit fields</a></h1>
<p>If we need a compound data which has bit sections which correspond to different values...</p>
<p>we can use bit-fields or we can use more complex solutions...</p>
<p>c++ has bit-fields which can easily solve this problem... compiler can detect wrong assignments too. it should have at most it's type maximum bits so x can be maximum 32 bits.</p>
<p>according to total bits wrapper type will have a 2n size.... for Version1 =&gt; 32 bits...</p>
<p>other solution is very classic...instead of bit-fields combining all into one variable but this time we need masks to set / get the data.</p>
<pre><code class="language-c++">
struct Version1 {
    uint32_t x : 4;
    uint32_t y : 4;
    uint32_t z : 12;
    uint32_t get_x() { return x; }
    uint32_t get_y() { return y; }
    uint32_t get_z() { return z; }
};
struct Version2 {
    uint32_t data;
    const uint32_t mask_x = 0x0F;
    const uint32_t mask_y = 0x0F;
    const uint32_t mask_z = 0x0FFF;
    uint32_t get_x() { return (data &gt;&gt; 16) &amp; mask_x; }
    uint32_t get_y() { return (data &gt;&gt; 12) &amp; mask_y; }
    uint32_t get_z() { return (data &gt;&gt; 0) &amp; mask_z; }
    void set_data(uint32_t x, uint32_t y, uint32_t z) {
        data = (x &lt;&lt; 16) | (y &lt;&lt; 12) | z;
    }
};
int main() {
    const uint32_t x = 13;
    const uint32_t y = 11;
    const uint32_t z = 777;
    Version1 v{.x = x, .y = y, .z = z};
    Version2 v2;
    v2.set_data(x, y, z);
    std::cout &lt;&lt; v.x &lt;&lt; ":" &lt;&lt; v.y &lt;&lt; ":" &lt;&lt; v.z &lt;&lt; std::endl;
    std::cout &lt;&lt; v2.get_x() &lt;&lt; ":" &lt;&lt; v2.get_y() &lt;&lt; ":" &lt;&lt; v2.get_z()
              &lt;&lt; std::endl;
    return 0;
}


</code></pre>
<pre><code class="language-c++">#include &lt;bitset&gt;
#include &lt;iostream&gt;

using namespace std;

union U {
    struct {
        int i : 4;
        int j : 4;
    } s_data;
    int arr;
};
int main() {
    U u{};
    u.s_data.i = 0b0011;
    u.s_data.j = 0b1100;
    bitset&lt;12&gt; bits = u.arr;
    cout &lt;&lt; bits &lt;&lt; endl;
    return 0;
}

</code></pre>
<p>another example...</p>
<p>Note: size of(FirstIP4word) can't be lower than field type ( maximum one) so in this example: minimum size of FirstIP4word == size of(uint32_t) .. ( 4 bytes) but if you use 32 bits for each...4 x 4 = 16 bytes will be used. in example 32 bits used so 4 bytes enough to store this data</p>
<p>Also when assigning you should be careful.</p>
<p>Always assign directly to bit fields.</p>
<pre><code class="language-c++">
 #include &lt;iostream&gt;

struct FirstIP4word {
    uint32_t version : 4;
    uint32_t header : 4;
    uint32_t tos : 8;
    uint32_t length : 16;
};

int main() { std::cout &lt;&lt; sizeof(FirstIP4word) &lt;&lt; std::endl; }

</code></pre>
<pre><code class="language-c++">4
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="define-conversion-operators"><a class="header" href="#define-conversion-operators">define conversion operators</a></h1>
<p>you can implement conversions as:</p>
<ul>
<li>to_type</li>
<li>operator type() const</li>
</ul>
<pre><code class="language-c++">
struct MyS
{
    operator std::string() const { return "hakan"; }
    std::string to_string() const { return "hakan";}

    // explicit is optional
    explicit operator int() const { return 0; }
    explicit operator double() const { return 0. 0};
    operator bool() const { return false; }
};

int main()
{
    std::string name = MyS{};
    std::cout &lt;&lt; name &lt;&lt; std::endl;

    return 0;
}

</code></pre>
<pre><code class="language-c++">#include &lt;iostream&gt;

struct X {};
struct Y {
    constexpr Y(X const&amp;) { std::cout &lt;&lt; "Y::ctor" &lt;&lt; std::endl; }
    constexpr Y&amp; operator=(X const&amp;) {
        std::cout &lt;&lt; "Y::=" &lt;&lt; std::endl;
        return *this;
    }
    constexpr operator X() const {
        std::cout &lt;&lt; "Y::X()" &lt;&lt; std::endl;
        return X{};
    }
};

int main() {
    X x;

    Y y{x};
    y = x;
    x = y;

    return 0;
}

</code></pre>
<p>if you use <code>explicit</code> conversions then either use c-style((target)) or c++ style(static_cast&lt;target&gt;).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="define-binary-enums"><a class="header" href="#define-binary-enums">define binary enums</a></h1>
<p>enums re called true constants or named values...but one of the use cases is using binary operations ... so or, and, xor needs to be supported... using strong enums make the problem more difficult but better...</p>
<pre><code class="language-c++">
namespace ns {
enum struct Flags {
    A = 0B000001,
    B = 0B000010,
    C = 0B000100,
    D = 0B001000,
    E = 0B010000,
    F = 0B100000
};
}
ns::Flags operator|(ns::Flags x, ns::Flags y) {
    return (ns::Flags)((uint32_t)x | (uint32_t)y);
}
int main() {
    using ns::Flags;
    [[maybe_unused]] auto ab_mask = Flags::A | Flags::B;
    [[maybe_unused]] auto bc_mask = Flags::B | Flags::C;
    [[maybe_unused]] auto cd_mask = Flags::C | Flags::D;
    [[maybe_unused]] auto de_mask = Flags::D | Flags::E;
    [[maybe_unused]] auto ef_mask = Flags::E | Flags::F;
    [[maybe_unused]] auto all_mask = 0B111111;
    std::println("{}", typeid(ab_mask).name());
    std::println("{}", typeid(std::underlying_type_t&lt;ns::Flags&gt;).name());
    std::println("{}", ab_mask == Flags::A);
    std::println("{}", ab_mask == Flags::B);
    std::println("{}", ab_mask == (Flags::A | Flags::B));

    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compare-ref-to-pointer"><a class="header" href="#compare-ref-to-pointer">compare ref to pointer</a></h1>
<ul>
<li>ref is an alias to variable; pointer is itself a variable</li>
<li>ref cannot exists without initial assignment; pointer can exist without being assigned to anything because it's variable</li>
<li>pointer has it's own memory size 4bytes or 8bytes</li>
<li>both dynamic so both can be used with polymorphism</li>
<li>&amp; is unique to c++</li>
<li>both can be used with reinterpret_cast, static_cast and dynamic_cast...when used none calls for copy constructor or move constructor so safe with memory</li>
<li>&amp; gives power to conversions, declval to access return type of a func without trigger ctors etc but ptr cannot do these.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="return-ref-to-local-variable-of-function"><a class="header" href="#return-ref-to-local-variable-of-function">return ref to local variable of function</a></h1>
<p>only way is defining that variable as static so it's memory will be kept in static section of the program file and will not disposed till program ends.</p>
<pre><code class="language-c++">
#include &lt;print&gt;

int&amp; foo() {
    static int i = 0;
    return ++i;
}

int main() {
    foo() += foo();
    std::println("{}", foo());

}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="define-guards-for-functions-and-classes"><a class="header" href="#define-guards-for-functions-and-classes">define guards for functions and classes</a></h1>
<p>c++ provides three methods to define guards for functions and two for classes based on type information.</p>
<ul>
<li>sfinae</li>
<li>concepts</li>
<li>if constexpr</li>
</ul>
<h2 id="sfinae-and-concepts"><a class="header" href="#sfinae-and-concepts">sfinae and concepts</a></h2>
<p>more details can be found in sfinae and concepts pages and also std::enable_if page.</p>
<h2 id="if-constexpr"><a class="header" href="#if-constexpr">if constexpr</a></h2>
<p>more details can be found in if constexpr page.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-stdenable_if"><a class="header" href="#use-stdenable_if">use std::enable_if</a></h1>
<p>c++ compiler is lazy. if you provide class or function prototype yourself, it will not generate it via template - it will use yours. std::enable_if is compilation time condition checker which can be used with type_traits or true constants. By using std::enable_if we can guard classes and functions against not-supported types.</p>
<p>you can use std::enable_if in different positions but don't forget that; it's second param is return type which you will use it with ::type or _t... so if you don't pass it; it will be void by default.</p>
<pre><code class="language-c++">
template &lt;typename T&gt;
std::enable_if_t&lt;std::is_same_v&lt;typename std::remove_cvref&lt;T&gt;::type, int&gt;, int&gt; // T == int
ret_type(T value) {
    return value;
}

template &lt;typename T&gt;
auto trait_type(T value) -&gt; std::enable_if_t&lt;
    std::is_same_v&lt;typename std::remove_cvref_t&lt;decltype(value)&gt;, int&gt;, int&gt; {
    return value;
}
template &lt;typename T,
          std::enable_if_t&lt;std::is_same_v&lt;typename std::remove_cvref_t&lt;T&gt;, int&gt;,
                           int&gt; = 0&gt; // &lt;typename T, int = 0&gt; if successful
int inner_type(T value) {
    return value;
}

</code></pre>
<p>another example</p>
<pre><code class="language-c++">
struct Header {
    template &lt;typename T, typename U,
              typename = std::enable_if_t&lt;
                  std::is_arithmetic_v&lt;T&gt; and std::is_arithmetic_v&lt;U&gt;, void&gt;&gt; // if successful, &lt;template typename T, typename U, typename = void&gt; {} will be generated
    static constexpr auto calc(T t, U u) -&gt; decltype(T{} + U{}) {
        return t * u;
    }
    template &lt;typename... Ts&gt;
    static constexpr auto calc(Ts... args) {
        return "undefined";
    }
};
int main() {
    constexpr auto r1 = Header::calc(10, 23);
    constexpr auto r2 = Header::calc("hakan", 100);
    static_assert(r1 == 230);
    static_assert(r2 == "undefined");
}

</code></pre>
<p>another example...</p>
<pre><code class="language-c++">
struct Header {
    template &lt;typename T, typename U,
              typename = std::enable_if_t&lt;
                  std::is_arithmetic_v&lt;T&gt; and std::is_arithmetic_v&lt;U&gt;, void&gt;&gt;
    static constexpr auto calc(T t, U u) -&gt; decltype(T{} + U{}) {
        return t * u;
    }
    template &lt;typename... Ts&gt;
    static constexpr auto calc(Ts... args) {
        return "undefined";
    }
};

struct Prefix {
    template &lt;typename T, typename U&gt;
    static constexpr std::enable_if_t&lt;std::is_arithmetic_v&lt;T&gt; and
                                          std::is_arithmetic_v&lt;U&gt;,
                                      decltype(T{} + U{})&gt;
    calc(T t, U u) {
        return t * u;
    }
    template &lt;typename... Ts&gt;
    static constexpr auto calc(Ts... args) {
        return "undefined";
    }
};

struct Trail {
    template &lt;typename T, typename U&gt;
    static constexpr auto calc(T t, U u) -&gt; typename std::enable_if_t&lt;
        std::is_arithmetic_v&lt;T&gt; and std::is_arithmetic_v&lt;U&gt;, T&gt; {
        return t * u;
    }
    template &lt;typename... Ts&gt;
    static constexpr auto calc(Ts...) {
        return "undefined";
    }
};

int main() {
    constexpr auto r1 = Header::calc(10, 23);
    constexpr auto r2 = Header::calc("hakan", 100);
    static_assert(r1 == 230);
    static_assert(r2 == "undefined");
    constexpr auto r3 = Prefix::calc(10, 23);
    constexpr auto r4 = Prefix::calc("hakan", 100);
    static_assert(r3 == 230.f);
    static_assert(r4 == "undefined");
    constexpr auto r5 = Trail::calc(10, 23);
    constexpr auto r6 = Trail::calc("hakan", 100);
    static_assert(r5 == 230.f);
    static_assert(r6 == "undefined");
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-shareable-only-type"><a class="header" href="#create-shareable-only-type">create shareable only type</a></h1>
<p>if your class is a manager of a resource which can be leak if not managed correctly and copying etc...is costly; we can create a shareable only type via std::enable_shared_from_this which returns a shared_ptr of this.</p>
<blockquote>
<p>an efficient method to return this to shared_this; managing heap resource correctly and escaping expensive copying</p>
</blockquote>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;memory&gt;

struct MyS : std::enable_shared_from_this&lt;MyS&gt; {
    // factory method
    template &lt;class... Args&gt;
    static std::shared_ptr&lt;MyS&gt; create(Args&amp;&amp;... args) {
        return std::shared_ptr&lt;MyS&gt;(new MyS(std::forward&lt;Args&gt;(args)...));
    }

    std::shared_ptr&lt;MyS&gt; instance() { return shared_from_this(); }

    void print() const {
        std::cout &lt;&lt; "buffer: " &lt;&lt; strlen(_buffer) &lt;&lt; std::endl;
    }

    template &lt;class T&gt;
    void push(T&amp;&amp; arg) {}

    MyS() = default;
    ~MyS() {
        if (_buffer != nullptr) {
            delete[] _buffer;
        }
    }

   private:
    template &lt;class... Args&gt;
    MyS(Args&amp;&amp;... args) {
        // do something with args..
        _buffer = new char[1024];
    }

   private:
    char* _buffer = nullptr;
};

void foo(std::shared_ptr&lt;MyS&gt;&amp; mutableObj) {
    mutableObj-&gt;push(101);
    mutableObj-&gt;print();
    std::cout &lt;&lt; "count: " &lt;&lt; mutableObj.use_count() &lt;&lt; std::endl;
}

void bar(std::shared_ptr&lt;MyS&gt; const&amp; immutableObj) {
    immutableObj-&gt;print();
    std::cout &lt;&lt; "count: " &lt;&lt; immutableObj.use_count() &lt;&lt; std::endl;
}

int main() {
    auto inst = MyS::create(1, "hakan gedek");
    inst-&gt;print();
    {
        // use_count =&gt; 2
        auto other = inst-&gt;instance();
        foo(other);
        // use_count =&gt; 1
    }
    // use_count =&gt; 2
    bar(inst-&gt;instance());
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pass-pointer-by-ref-to-functions"><a class="header" href="#pass-pointer-by-ref-to-functions">pass pointer by ref to functions</a></h1>
<p>pointer type is a reference type in c/c++. it means that like c#, java... this type referee the real address of the data - it's not sole owner it but only referee so if it's not readonly you can easily referee others.</p>
<blockquote>
<p>T* has same features of T. Never think it's too special and be afraid of it.</p>
</blockquote>
<p>all possible passings of a pointer to functions:</p>
<p>options:</p>
<ul>
<li>immutable data + immutable pointer</li>
<li>immutable data + mutable pointer</li>
<li>mutable data + immutable pointer</li>
<li>mutable data + mutable pointer</li>
</ul>
<pre><code class="language-c++">#include &lt;cassert&gt;
#include &lt;iostream&gt;

// value of a pointer is **addressof** the target

void pass_ptr_by_value(int* ptr) {
    // value is mutable so copy ptr will update the data
    *ptr = 101;

    int z = 0;
    // set a new value to pointer but it's a copy so it will not effect
    ptr = &amp;z;
}

void pass_ptr_to_const_value_by_value(const int* ptr) {
    // data is immutable so you cannot edit it
    // *ptr = value;

    // ptr is copy so this will not do anything
    int z = 0;
    ptr = &amp;z;
}

void pass_const_ptr_by_value(int* const ptr) {
    // data is mutable so updated
    *ptr = 11;

    int z = 0;
    // ptr is readonly so a new address cannot be assigned into it
    // it looks like =&gt; const int x = 0; you can't update it
    // ptr = &amp;z;
}

void pass_const_ptr_to_const_value_by_value(const int* const ptr) {
    // data is immutable
    // *ptr = 101;
    int z = 0;
    // pointer is immutable
    // ptr = &amp;z;
}

int a = 0;  // let's use global so no UB

void pass_ptr_by_ref(int*&amp; ptr) {
    // data is mutable - first updated existing data
    *ptr = 202;

    // ptr is original so we no longer track old mem
    // a new mem will be tracked.
    ptr = &amp;a;
}

int b = 99;

void pass_ptr_to_const_value_by_ref(const int*&amp; ptr) {
    // data is immutable
    // *ptr = 101;

    // ptr is mutable so we set a new address to it
    // it doesnt track `a` anymore
    ptr = &amp;b;
}

// pointer has own address like any variable
// pointers value's is address of variable
uintptr_t addressof(const int* const ptr) {
    return reinterpret_cast&lt;uintptr_t&gt;(ptr);
}

int main() {
    int x = 0;
    int y = 0;

    int* ptr = &amp;x;

    auto addr = addressof(ptr);
    // addr of pointer copied so a copy of ptr passed to func
    pass_ptr_by_value(ptr);
    // same addresses
    assert(addr == addressof(ptr));
    // data updated from 0 =&gt; 101
    assert(x == 101);

    pass_ptr_to_const_value_by_value(ptr);
    // same address
    assert(addr == addressof(ptr));
    // same data
    assert(x == 101);

    pass_const_ptr_by_value(ptr);
    // same address
    assert(addr == addressof(ptr));
    // data updated from 101 =&gt; 11
    assert(x == 11);

    pass_const_ptr_to_const_value_by_value(ptr);
    // same address
    assert(addr == addressof(ptr));
    // same data
    assert(x == 11);

    pass_ptr_by_ref(ptr);
    // pointer updated
    assert(addr != addressof(ptr));
    // data updated but it will not track it anymore so...
    assert(x == 202);
    // x is not tracked by ptr anymore
    x = 404;
    assert(*ptr != 404);

    // restore the address
    addr = addressof(ptr);
    pass_ptr_to_const_value_by_ref(const_cast&lt;const int*&amp;&gt;(ptr));
    // pointer updated
    assert(addr != addressof(ptr));

    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-forward-declarations-correctly"><a class="header" href="#use-forward-declarations-correctly">use forward declarations correctly</a></h1>
<p>forward declarations simplify coding in c++. it looks like before cooking; preparing the materials on the table...you generally don't start to cook asap but do a preparation.</p>
<p>you can forward decl anything which has a definition because in c++ like separating files in to .h/.cpp; stuff also split in two: decl + def</p>
<pre><code class="language-c++">
// .h

void foo(); // when included; others will know there's a foo but they will not know what it's
extern void bar(); // external explicitly but it's same

extern int Var; // ODR is followed
// int Var; doesn't work because this is internal linkage and ODR fails -&gt; inline usage etc

class MyC; // there is a MyC somewhere and it can have inheritance too - complexity doesn't interest me

template &lt;class T&gt;
class MyTC;


template &lt;class T&gt;
void foo(T&amp;&amp;);

//.cpp

</code></pre>
<p>why use forward decl ?</p>
<ul>
<li>prevents the cyclic dependency between classes</li>
<li>stops unnecessary includes
<ul>
<li>including a header file in cpp file only interests that file but including in the header file interests all other files including this header file - program size gets bigger and bigger</li>
</ul>
</li>
<li>helps designing better... like cooking; you see the materials first then start to cook / design</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-inline-correctly"><a class="header" href="#use-inline-correctly">use inline correctly</a></h1>
<p>copy the definition to used places and respect the ODR rule ( one definition rule)</p>
<ul>
<li>
<p>if you put definition of methods in header file; use inline with these methods.</p>
</li>
<li>
<p>if your functions are small in size in module; use inline with them. so frequently used small functions will perform better.</p>
</li>
<li>
<p>initialize and define static fields in classes.</p>
</li>
<li>
<p>if you need to define a variable in header file use it with inline not to break ODR</p>
</li>
</ul>
<pre><code class="language-c++">
struct MyS{

    static inline int count = 0; // defined here - no need to define in cpp anymore
    constexpr static auto value = 0; // implicitly inline

    inline void bar() {} // definition of the function is together with declaration
};

// instead of exporting directly you can use in ns
namespace ns {
    inline constexpr auto LEVEL = 0x10;
    inline void foo() {
}

</code></pre>
<h2 id="inline-namespaces"><a class="header" href="#inline-namespaces">inline namespaces</a></h2>
<p>nested namespaces can use inline keyword and inlined namespaces will export it's content to outer - useful for versioning - default and explicit callings.</p>
<pre><code class="language-c++">
namespace MyLib {
    inline namespace v1 {
        void func() { std::cout &lt;&lt; "v1::func" &lt;&lt; std::endl; }
    }

    namespace v2 {
        void func() { std::cout &lt;&lt; "v2::func" &lt;&lt; std::endl; }
    }
}

int main() {
    MyLib::func(); // Calls v1::func by default
    MyLib::v2::func(); // Calls v2::func explicitly
    return 0;
}

</code></pre>
<pre><code class="language-c++">// cpp file

inline int add(int a, int b) {
    return a + b;
}

int main() {
    int result = add(3, 4); // The call to add() may be inlined
    return 0;
}

</code></pre>
<p>you can do this instead of MACROs but best is creating a class of static constexpr variables which will provide better readability.</p>
<pre><code class="language-c++">// .header file

inline constexpr int MAX_VALUE = 100;

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-linkages-correctly"><a class="header" href="#use-linkages-correctly">use linkages correctly</a></h1>
<blockquote>
<p>what is translation unit ?</p>
</blockquote>
<p>cpp file fed to compiler after it has been pro-processed.</p>
<blockquote>
<p>what does linkage mean ?</p>
</blockquote>
<p>There may be multiple translation units ( compilation units) and they re related with each other - using each other... at linking step linker will search these parts and link memory addresses.</p>
<blockquote>
<p>types of linkages in c++ ?</p>
</blockquote>
<p>internal and external.</p>
<p>Firstly we need to understand =&gt; declaration and definition differences. In declaration we just need the signature of things like function or variables... In definition we define the memory size of these variables . Definition of things can be once because of ODR ( one definition rule) but we can repeat declaration many times around the code. At linkage phase compiler will try to link them to their definition and at this step we should follow ODR.</p>
<p>.hh is external</p>
<p>.cc is internal</p>
<p>external: globally defined items. linker can access them from other translation units.</p>
<pre><code class="language-c++">
// .h : declarations
extern int i; //
extern void func(int i); // functions implicitly external - you dont need to use

// .cpp : definitions
int i = 0;
void func(int i) {}

</code></pre>
<p>internal: belongs to only one translation unit.</p>
<p>External items use one memory resource =&gt; unique - memory saving
Internal items re copied =&gt; multiple copy means more memory usage</p>
<blockquote>
<p>how to define internal linkage items in a file ?</p>
</blockquote>
<p>Declare and define internal linkage items in source code (*.cpp) if possible.</p>
<ul>
<li>static</li>
<li>const</li>
<li>constexpr</li>
<li>typedef</li>
</ul>
<blockquote>
<p>how to define external linkage items in a file ?</p>
</blockquote>
<ul>
<li>extern</li>
<li>macros</li>
<li>non-const global items</li>
</ul>
<blockquote>
<p>how forward declaration used with linkage ?</p>
</blockquote>
<p>FD helps loosely coupling and late linking - if we change definition of functions of the FD items; sources will not compiled again.</p>
<blockquote>
<p>What does inline do ?</p>
</blockquote>
<p>It defines the variable.</p>
<pre><code class="language-c++">
struct MyS
{
static int i; // declaration
inline static int j; // decl + definition
static constexpr int k; // implicitly inline =&gt; decl + defines variable
};
</code></pre>
<blockquote>
<p>No linkage items ?</p>
</blockquote>
<p>Local variable in functions have no linkage info</p>
<blockquote>
<p>Global variables with internal linkage ?</p>
</blockquote>
<p>Define them in unnamed namespaces for ODR. but best is decl + define them in cpp not header.</p>
<blockquote>
<p>Inline linkage ?</p>
</blockquote>
<p>Inline functions and variables have external linkage - one definition multiple copy</p>
<blockquote>
<p>static functions and variables linkage ?</p>
</blockquote>
<p>Internal</p>
<blockquote>
<p>unnamed namespace linkage ?</p>
</blockquote>
<p>Internal</p>
<blockquote>
<p>named namespace linkage ?</p>
</blockquote>
<p>External</p>
<blockquote>
<p>static inline linkage ?</p>
</blockquote>
<p>Internal... static is more dominant than inline...or internal feature &gt; external feature</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-string-and-string_view-methods"><a class="header" href="#use-string-and-string_view-methods">use string and string_view methods</a></h1>
<p>examples for string and string_view methods.</p>
<blockquote>
<p>find_first_of</p>
</blockquote>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;string&gt;

void print(auto&amp;&amp;... args) { (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; std::endl;

int main() {
    const std::string target = "ha;ka!n g:ed,ek";
    const std::string keys = ";:,. !";
    auto beg = 0, end = 0;
    beg = target.find_first_of(keys);
    while (beg != std::string::npos) {
        std::swap(beg, end);
        print(target.substr(beg, end - beg));
        end++;
        beg = target.find_first_of(keys, end);
    }
    if (beg != end) {
        // final
        std::swap(beg, end);
        print(target.substr(beg, end-beg));
    }
    return 0;
}
</code></pre>
<blockquote>
<p>fill string with character N times.</p>
</blockquote>
<pre><code class="language-c++">
int main() {
    std::string s1 (10, 'c');
    print(s1);
    std::string s2;
    s2.assign(10, 'c');
    print(s2);

    return 0;
}
</code></pre>
<blockquote>
<p>reverse find</p>
</blockquote>
<pre><code class="language-c++">
  const std::string s = "0123456789";
  print(s.rfind("45", 3)); // fails...3 to 0 there is not this string
  print(s.rfind("45", s.length())) // finds... 10 to 0 there is that substr

  print(s.rfind("465", 4, 1)); // finds... an: 1 =&gt; argument size - checks only 1
  print(s.rfind("465", 4, 2)); // no result ... 2 =&gt; compare 2 from arguments

</code></pre>
<blockquote>
<p>erasing</p>
</blockquote>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;

void print(auto&amp;&amp;... args) { (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; std::endl; }

int main() {
    // erase(pos, len): delete substr
    {
        std::string text = "hakan gedek aksaray";
        const std::string key = "gedek";

        text.erase(text.find(key), key.length());  // successfull but ... there is problem :)
        print(text);

        try {
            text.erase(text.find("turkey"), std::string{"turkey"}.length());
            print(text);
        } catch (...) {
            print("npos: out_of_range... instead of using directly \"find\" in \"erase\"...lets do it =&gt; ");

            if ( auto pos = text.find("turkey"); pos != std::string::npos) {
                text.erase(pos, std::string{"turkey"}.length());
            }
        }
    }
    // itr = erase(itr-beg, itr-end);
    {
        // string::find =&gt; returns size_t pos
        // algorithm::search =&gt; returns itr

        std::string text = "hakan gedek aksaray";
        const std::string key = "gedek";
        auto itr = std::search(text.begin(), text.end(), key.begin(), key.end());
        if (itr != text.end()) {
            itr = text.erase(itr, itr + key.length());
            print(text);
            print("after deletion itr show =&gt; ", std::distance(text.begin(), itr), "th position...so if you continue to search ...\nso from this position to end you can erase duplications");
        }
    }
    return 0;
}

</code></pre>
<blockquote>
<p>compare</p>
</blockquote>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;string&gt;
void print(auto&amp;&amp;... args) { (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; std::endl; }
int main() {
    const std::string s1 = "hakan";
    const std::string s2 = "hakan";
    const std::string s3 = "akan";
    const std::string s4 = "gedek";
    print(std::boolalpha, "hakan == hakan =&gt; ", s1 == s2);
    print(std::boolalpha, "hakan != hakan =&gt; ", s1 != s2);
    print(std::boolalpha, "hakan == akan =&gt; ", s1 == s3);
    print(std::boolalpha, "hakan &lt; gedek =&gt; ", s1 &lt; s4);
    print(std::boolalpha, "hakan &gt; gedek =&gt; ", s1 &gt; s4);
    print(std::boolalpha, "hakan &gt; akan =&gt; ",  s2 &gt; s3);

    return 0;
}

</code></pre>
<blockquote>
<p>find substr</p>
</blockquote>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
void print(auto&amp;&amp;... args) { (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; std::endl; }
int main() {
    // substr
    const std::string text = "hakan gedek aksaray";
    const std::string key = "gedek";
    if (auto pos = text.find(key); pos != std::string::npos) {
        print(text, " has =&gt; " , key);
        auto substr = text.substr(pos, key.length());
        print("=&gt; ", substr);
    }
    // you can use std::search too !
    return 0;
}

</code></pre>
<blockquote>
<p>improve string creation perf</p>
</blockquote>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;chrono&gt;
void print(auto&amp;&amp;... args) { (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; std::endl; }
int main() {
    namespace ch = std::chrono;
    auto _time_p0 = ch::system_clock::now();
    std::string s1(1'000'000, 'c');
    auto _diff_t = ch::system_clock::now() - _time_p0;
    print(_diff_t.count(), " ns");
    _time_p0 = ch::system_clock::now();
    std::string s2;
    for (auto i = 0; i &lt; 1'000'000; ++i) {
        s2 += 'c';
    }
    _diff_t = ch::system_clock::now() - _time_p0;
    print(_diff_t.count(), " ns");
    return 0;
}

</code></pre>
<blockquote>
<p>swapping</p>
</blockquote>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
void print(auto&amp;&amp;... args) { (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; std::endl; }
int main() {
    std::string s1 = "hakan";
    std::string s2 = "gedek";
    std::swap(s1, s2);
    print(s1);
    print(s2);
    return 0;
}
</code></pre>
<blockquote>
<p>replacing</p>
</blockquote>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;string&gt;
void print(auto&amp;&amp;... args) { (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; std::endl; }
int main() {
    // replacing
    std::string text = "hakan gedek aksaray turkey";
    {
        // replace(offet, size, argument, offset, size)
        auto copy_text = text;
        copy_text.replace(0, 5, "nakah", 0, 5);
        print(text, " =&gt; replace() =&gt; ", copy_text);
        // replace(offet, size, argument, size)
        auto temp_text = copy_text;
        temp_text.replace(6, 5, "hakan", 5);
        print(copy_text, " =&gt; replace() =&gt; ", temp_text);
    }
    {
        // replace(offset, size, count, char)
        auto copy_text = text;
        copy_text.replace(6, 5, 5, 'x');
        print(text, " =&gt; replace() =&gt; ", copy_text);
    }
    {
        // replace(itr_beg, itr_end, arg)
        auto copy_text = text;
        auto itr_beg = copy_text.begin() + 6; // pos =&gt; start of "gedek"
        auto itr_end = itr_beg + 5; // count =&gt; 5
        copy_text.replace(itr_beg, itr_end, "WWWWWW");
        print(text, " =&gt; replace() =&gt; ", copy_text);
    }
    {
        // replace(itr_beg, itr_end, count, char)
        auto copy_text = text;
        auto itr_beg = copy_text.begin() + 6; // pos =&gt; start of "gedek"
        auto itr_end = itr_beg + 5; // count =&gt; 5
        copy_text.replace(itr_beg, itr_end, 5, 'Y');
        print(text, " =&gt; replace() =&gt; ", copy_text);
    }
    {
        // replace(itr_beg, itr_end, input_itr_beg, input_itr_end)
        auto copy_text = text;
        decltype(copy_text) key = "london";
        auto pos = copy_text.find("aksaray");
        auto itr_beg = copy_text.begin() + pos;
        auto itr_end = itr_beg + std::string{"aksaray"}.length();
        auto input_itr_beg = key.begin();
        auto input_itr_end = key.end();
        copy_text.replace(itr_beg, itr_end, input_itr_beg, input_itr_end);
        print(text, " =&gt; replace =&gt; ", copy_text);
    }
    return 0;
}

</code></pre>
<blockquote>
<p>convertions</p>
</blockquote>
<div class="table-wrapper"><table><thead><tr><th>type</th><th>method</th></tr></thead><tbody>
<tr><td>float</td><td>stof</td></tr>
<tr><td>short, int / unsigned</td><td>stoi / stoul</td></tr>
<tr><td>long / unsigned</td><td>stol / stoul</td></tr>
<tr><td>long long / unsigned</td><td>stoll / stoul - stoull</td></tr>
<tr><td>double</td><td>stod</td></tr>
<tr><td>long double</td><td>stold</td></tr>
<tr><td>unsigned long</td><td>stoul</td></tr>
<tr><td>numerics to string</td><td>to_string</td></tr>
<tr><td>numerics to wstring</td><td>to_wstring</td></tr>
</tbody></table>
</div>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;limits&gt;
void print(auto&amp;&amp;... args) { (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; std::endl; }
int main() {
    uint16_t _16_t = std::numeric_limits&lt;uint16_t&gt;::max();
    uint32_t _32_t = std::numeric_limits&lt;uint32_t&gt;::max();
    uint64_t _64_t = std::numeric_limits&lt;uint64_t&gt;::max();
    uintmax_t _max_t = std::numeric_limits&lt;uintmax_t&gt;::max();
    float _f_t = std::numeric_limits&lt;float&gt;::max();
    double _d_t = std::numeric_limits&lt;double&gt;::max();
    long double _ld_t = std::numeric_limits&lt;long double&gt;::max();

    auto s_16_t = std::to_string(_16_t);
    auto s_32_t = std::to_string(_32_t);
    auto s_64_t = std::to_string(_64_t);
    auto s_max_t = std::to_string(_max_t);
    auto s_f_t = std::to_string(_f_t);
    auto s_d_t = std::to_string(_d_t);
    auto s_ld_t = std::to_string(_ld_t);

    print(s_16_t, " = ", std::stoi(s_16_t));
    print(s_32_t, " = ", std::stoul(s_32_t));
    print(s_64_t, " = ", std::stoul(s_64_t));
    print(s_max_t, " = ", std::stoul(s_max_t));
    print(s_f_t, " = ", std::stof(s_f_t));
    print(s_d_t, " = ", std::stod(s_d_t));
    print(s_ld_t, " = ", std::stold(s_ld_t));

    return 0;
}
</code></pre>
<blockquote>
<p>pass string to functions</p>
</blockquote>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;string&gt;

void print(auto&amp;&amp;... args) { (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; std::endl; }

struct Owner {
    void foo(std::string&amp;&amp; data) {
        _data = std::move(data);
    }
    std::string&amp; data() { return _data; }
    const std::string&amp; data() const { return _data; }
private:
    std::string _data;
};

struct User {
    void foo(const std::string&amp; data) {
        print(data);
    }
};

int main() {
    Owner owner;
    User user;
    std::string data = "hakan gedek";
    user.foo(data); // const std::string
    // owner.foo(data); // failed
    owner.foo(std::move(data));
    print(data); // if move ctors defined correctly; this object doesnt contain data anymore
    print(owner.data());
}

</code></pre>
<blockquote>
<p>starts_with &amp;&amp; ends_with</p>
</blockquote>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;string_view&gt;

void print(auto&amp;&amp;... args) { (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; std::endl; }

int main() {
    const std::string text = "hakan gedek";

    auto ends_with = [&amp;text] (const std::string&amp; key) {
        auto end = text.end();
        auto beg = end - key.length();
        return std::string_view{beg,end} == key ? true : false;
    };

    auto starts_with = [&amp;text](const std::string&amp; key) {
        auto beg = text.begin();
        auto end = beg + key.length();
        return std::string_view{beg, end} == key;
    };

    print(std::boolalpha, text, " ends_with(ek) =&gt; ", ends_with("ek"));
    print(std::boolalpha, text, " ends_with(kek) =&gt; ", ends_with("kek"));
    print(std::boolalpha, text, " starts_with(ha) =&gt; ", starts_with("ha"));
    print(std::boolalpha, text, " starts_with(han) =&gt; ", starts_with("han"));
    return 0;
}

</code></pre>
<blockquote>
<p>using operator[] with unicodes</p>
</blockquote>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;string&gt;

auto print(auto&amp;&amp;...arg) {
    (std::cout &lt;&lt; ... &lt;&lt; arg);
}

auto wprint(auto&amp;&amp;...arg) {
    (std::wcout &lt;&lt; ... &lt;&lt; arg);
}

int main() {
    // sample text =&gt;  門地その他の地位又はこれに類するいかな
    {
        std::string japanese = "門地その他の地位又はこれに類するいかな";
        std::wstring wjapanese = L"門地その他の地位又はこれに類するいかな";
        // works
        print(japanese, '\n'); // utf-8
        // doesnt work
        wprint(wjapanese, '\n'); // ?
        // []
        print('h', ":", uint32_t('h'), '\n');
        print(japanese[0], ":", uint32_t(japanese[0]), '\n'); // ? doesnt work
        wprint(wjapanese[0], ":" , uint32_t(wjapanese[0]), '\n'); // ? doesnt work
    }
}

</code></pre>
<blockquote>
<p>splitting</p>
</blockquote>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;sstream&gt;
void print(auto&amp;&amp;...args) {
    (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; std::endl;
}
int main() {
    {
        // delim = ' '
        {
            // using istream_iterator
            const std::string text = "hakan gedek aksaray turkiye";
            std::istringstream iss{text};
            std::vector&lt;std::string&gt; strs;
            std::copy(std::istream_iterator&lt;std::string&gt;(iss), {}, std::back_inserter(strs));
            for (const auto&amp; str: strs)
                print(str);
            print('\n');
        }
        // delim = ' '
        {
            // using istringstream
            const std::string text = "hakan gedek aksaray turkiye";
            std::istringstream iss{text};
            std::string str;
            while (std::getline(iss, str, ' ')) {
                print(str);
            }
            print('\n');
        }
    }
    {
        // delim = [",.:; "] special chars array
        {
            // using string functions
            const std::string text = "hakan;gedek:aksaray,turkiye";
            const std::string delims = ";:,";
            std::vector&lt;std::string&gt; strs;
            auto beg = 0, end = 0;
            beg = text.find_first_of(delims, beg);
            while (beg != std::string::npos) {
                std::swap(beg, end);
                strs.emplace_back(text.substr(beg, end - beg));
                beg = text.find_first_of(delims, end+1);
                end++; // range always [) ... so move end +1
            }
            std::swap(beg, end);
            strs.emplace_back(text.substr(beg));
            for (const auto&amp; str : strs)
                print(str);

            print('\n');
        }
        // delim = ':'
        {
            // using istringstream
            const std::string text = "hakan:gedek:aksaray:turkiye";
            std::istringstream iss{text};
            std::string str;
            std::vector&lt;std::string&gt; strs;
            while (std::getline(iss, str, ':'))
                strs.emplace_back(std::move(str));
            for (const auto&amp; str : strs)
                print(str);

        }
    }
    return 0;
}
</code></pre>
<blockquote>
<p>address of bytes</p>
</blockquote>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
void print(auto&amp;&amp;...args) {
    (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; std::endl;
}
int main() {
    std::string s {"hakan"};
    std::vector v {1,2,3,4,5};
    print((int*)(&amp;s[0]));
    print((int*)(&amp;s[1]));
    print((int*)(&amp;s[2]));
    print((int*)(&amp;s[3]));
    print((int*)(&amp;s[4]));
    print(&amp;v[0]);
    print(&amp;v[1]);
    print(&amp;v[2]);
    print(&amp;v[3]);
    print(&amp;v[4]);
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-initialization-clauses"><a class="header" href="#use-initialization-clauses">use initialization clauses</a></h1>
<p>we can initialize variables etc in if/switch and use &amp; dispose them at that point.</p>
<pre><code class="language-c++">
if ( string var = foo(); !var.empty()) {}

if (bool result = foo(); result) {}

if (auto itr = find(); itr) {}

</code></pre>
<p>after this clause they re not accessible ... so you can think that:</p>
<pre><code class="language-c++">{
auto var...
if () ...
}
... // you re here

</code></pre>
<p>example:</p>
<pre><code class="language-c++">enum Index {
    Zero = 0,
    Ten = 10
};
int main() {
    std::string s = "hakan";
    switch(auto pos = s.find('k')) {
        case std::string::npos:
            throw;
        case Index::Zero...Index::Ten:
            print(pos);
    }
    return 0;
}

</code></pre>
<p>if and switch format:</p>
<pre><code class="language-c++">if ( init; cond) {}

switch( init;  var) {}
</code></pre>
<p>full example:</p>
<pre><code class="language-c++">enum Index {
    Zero = 0,
    Four = 4,
    Five = 5,
    Ten = 10
};
int main() {
    // initialization clause
    std::string_view view = "0123456789";
    if (auto pos = view.find('9'); pos != std::string_view::npos) {
        print("9 found at ", pos);
    }
    switch(auto pos = view.find('9'); pos) {
        case Index::Zero...Index::Four:
            print("9 found at ", pos);
            break;
        case Index::Five...Index::Ten:
            print("9 found at ", pos);
            break;
    }

    return 0;
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-raw-strings"><a class="header" href="#use-raw-strings">use raw strings</a></h1>
<p>when we think escape or special characters with multiline strings; creating it is very difficult...</p>
<p>raw string solves multiline string format</p>
<pre><code class="language-c++">
namespace {
    const char doPrompt[] =
    R"(
        if (d_debug__) {
            s_out__ &lt;&lt; "\n====================\n"
            " ? " &lt;&lt; d_flush__;
            std::string s;
            std::getline(std::cin, s);
        }
    )";
} // anonymous namespace
int main() {
    print(doPrompt);

    return 0;
}

</code></pre>
<p>Raw string solves special char and multi-line problem.</p>
<p>R"()"... just write the string as you wished inside of this block</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-auto"><a class="header" href="#use-auto">use auto</a></h1>
<p>modern keyword to box types or it's used like var, let ...in other languages. but in which forms ?</p>
<p>lets see it using int !</p>
<ul>
<li>int</li>
<li>const int</li>
<li>int*</li>
<li>const int*</li>
</ul>
<p>what about &amp; or &amp;&amp; ? no...you need to use them explicitly or you can even use const explicitly but basically auto will support T and T*.</p>
<blockquote>
<p>auto is perfect for T&amp;&amp;</p>
</blockquote>
<pre><code class="language-c++">#include &lt;iostream&gt;

template &lt;class T&gt;
void foo(T&amp;&amp; var) {}

void bar(auto&amp;&amp; var) {}

int main() {
    int x = 0;
    const int y = 0;
    foo(x);
    foo(y);
    foo(0);
    bar(x);
    bar(y);
    bar(0);

</code></pre>
<pre><code class="language-c++">
int main() {
    int x = 0;
    const int y = 0;
    const int&amp; z = y;

    auto xptr = &amp;x;
    const auto yptr = &amp;y;
    const auto&amp; zref = z;
}

</code></pre>
<blockquote>
<p>perfect return: protect the &amp; and &amp;&amp; when returning</p>
</blockquote>
<pre><code class="language-c++">
#include &lt;cassert&gt;
#include &lt;iostream&gt;

decltype(auto) foo(auto&amp; x) { return x; }

int main() {
    int x = 0;
    auto&amp; y = foo(x);

    y = 101;

    assert(x == 101);
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-designated-initialization"><a class="header" href="#use-designated-initialization">use designated initialization</a></h1>
<p>order of initialization is important... follow the order of them same in class/struct</p>
<pre><code class="language-c++">
struct S {
    int i;
    float f;
    double d;
};
int main() {
    S { 10, 10.3f, 10.2 }; // normal
    S { .i = 10, .f = 10.3f, .d = 10.2 };
    // S { .f = 10.3f, .i = 10, .d = 10.2 }; // failed... "S::i" does not match decleration order in S

    S { .d = 1.2 }; // float and int assigned
    S { .f = 1.2f, .d = 1.2 };
}

</code></pre>
<p>If you only assign one or two of them; others will be assigned to defaults.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-non-virtual-inheritance"><a class="header" href="#use-non-virtual-inheritance">use non-virtual inheritance</a></h1>
<p>This relationship is HAS relationship... put all shared members in base and create non-virtual inheritance...</p>
<pre><code class="language-c++">
struct base {
    int value;
    base() = default;
    base(int v): value(v) {}
};
struct derived: base {
    float value2;
    derived() = default;
    derived(float f): value2{f} {}
    derived(int i, float f): base(i), value2(f) {}
    derived(base const&amp; b) {
        value = b.value;
    }
};
int main() {
    derived d{10, 12.3f};
    std::cout &lt;&lt; d.value &lt;&lt; ":" &lt;&lt; d.value2 &lt;&lt; std::endl;
    base b = d;
    std::cout &lt;&lt; b.value &lt;&lt; ":" &lt;&lt; std::endl;
    derived d2 = b;
    std::cout &lt;&lt; d2.value &lt;&lt; ":" &lt;&lt; d2.value2 &lt;&lt; std::endl;
}

// d2 lost d1 value2 data. because base doesn't know it.
// if you had only value it would work

</code></pre>
<p>when to use non-virtual inheritance ?</p>
<p>you've shared properties with other types but you don't want virtual inheritance then put them under a common/shared base and create a private / protected inheritance so you can stop the cast to base.</p>
<p>so this relationship doesn't hide derived in base types/pointers correctly; you need to know correct inner type which crtp etc. supports this feature. but this can be used as has relationship so</p>
<ul>
<li>change base type to not be created from outside</li>
<li>change inheritance to protected</li>
</ul>
<p>so you can use base a shared area for derived types.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="evaluate-constness"><a class="header" href="#evaluate-constness">evaluate constness</a></h1>
<blockquote>
<p>using const in function interface helps ?</p>
</blockquote>
<p>Yes. You inform the compiler; this temp variable will not be updated</p>
<pre><code class="language-c++">
void foo(const int value) {} // only read

void bar(int value) {
    value++
} // read and write

</code></pre>
<blockquote>
<p>Can const be hidden in T in templates ?</p>
</blockquote>
<p>Yes. Always use decay_t to access correct T ( raw T) .</p>
<p>T can be:</p>
<pre><code class="language-c++">
int i = 0;
const int ci = 0;
int&amp; ri = i;
const int&amp; cri = ci;
0

void foo(T&amp;&amp;) [with T = int&amp;]
std::is_lvalue_reference_v&lt;T&gt;: 1
std::is_lvalue_reference_v&lt;decltype(param)&gt;: 1
std::is_rvalue_reference_v&lt;T&gt;: 0
std::is_rvalue_reference_v&lt;decltype(param)&gt;: 0

void foo(T&amp;&amp;) [with T = const int&amp;]
std::is_lvalue_reference_v&lt;T&gt;: 1
std::is_lvalue_reference_v&lt;decltype(param)&gt;: 1
std::is_rvalue_reference_v&lt;T&gt;: 0
std::is_rvalue_reference_v&lt;decltype(param)&gt;: 0

void foo(T&amp;&amp;) [with T = int&amp;]
std::is_lvalue_reference_v&lt;T&gt;: 1
std::is_lvalue_reference_v&lt;decltype(param)&gt;: 1
std::is_rvalue_reference_v&lt;T&gt;: 0
std::is_rvalue_reference_v&lt;decltype(param)&gt;: 0

void foo(T&amp;&amp;) [with T = const int&amp;]
std::is_lvalue_reference_v&lt;T&gt;: 1
std::is_lvalue_reference_v&lt;decltype(param)&gt;: 1
std::is_rvalue_reference_v&lt;T&gt;: 0
std::is_rvalue_reference_v&lt;decltype(param)&gt;: 0

void foo(T&amp;&amp;) [with T = int]
std::is_lvalue_reference_v&lt;T&gt;: 0
std::is_lvalue_reference_v&lt;decltype(param)&gt;: 0
std::is_rvalue_reference_v&lt;T&gt;: 0
std::is_rvalue_reference_v&lt;decltype(param)&gt;: 1

</code></pre>
<p>if you check T =&gt; you cannot access correct type alone...use std::forward&lt;T&amp;&amp;&gt; with it or you can use decltype(param) =&gt; this always carry correct type</p>
<pre><code class="language-c++">
void foo(const T&amp;) [with T = int]
std::is_lvalue_reference_v&lt;T&gt;: 0
std::is_lvalue_reference_v&lt;decltype(param)&gt;: 1
std::is_rvalue_reference_v&lt;T&gt;: 0
std::is_rvalue_reference_v&lt;decltype(param)&gt;: 0

void foo(const T&amp;) [with T = int]
std::is_lvalue_reference_v&lt;T&gt;: 0
std::is_lvalue_reference_v&lt;decltype(param)&gt;: 1
std::is_rvalue_reference_v&lt;T&gt;: 0
std::is_rvalue_reference_v&lt;decltype(param)&gt;: 0

void foo(const T&amp;) [with T = int]
std::is_lvalue_reference_v&lt;T&gt;: 0
std::is_lvalue_reference_v&lt;decltype(param)&gt;: 1
std::is_rvalue_reference_v&lt;T&gt;: 0
std::is_rvalue_reference_v&lt;decltype(param)&gt;: 0

void foo(const T&amp;) [with T = int]
std::is_lvalue_reference_v&lt;T&gt;: 0
std::is_lvalue_reference_v&lt;decltype(param)&gt;: 1
std::is_rvalue_reference_v&lt;T&gt;: 0
std::is_rvalue_reference_v&lt;decltype(param)&gt;: 0

void foo(const T&amp;) [with T = int]
std::is_lvalue_reference_v&lt;T&gt;: 0
std::is_lvalue_reference_v&lt;decltype(param)&gt;: 1
std::is_rvalue_reference_v&lt;T&gt;: 0
std::is_rvalue_reference_v&lt;decltype(param)&gt;: 0

</code></pre>
<blockquote>
<p>Can const be hidden in auto ?</p>
</blockquote>
<p>auto can be T or T* but adjectives like &amp; or const you need to use them separately.</p>
<p>auto =&gt; int
auto =&gt; int*
const auto =&gt; const int
const auto =&gt; const int*
auto&amp; =&gt; int &amp;
auto&amp; =&gt; int*&amp;
const auto&amp; =&gt; const int &amp;
const auto&amp; =&gt; const int*&amp;</p>
<p>auto&amp;&amp; =&gt; all upper ones or int&amp;&amp; ...</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="defined-ranged-enum"><a class="header" href="#defined-ranged-enum">defined ranged enum</a></h1>
<p>well i found this example in my notes</p>
<pre><code class="language-c++">
enum class Enums {
    A,
    B,
    C,
    D,
    E
};
void foo(Enums E) {
    switch(E) {
        case Enums::A...Enums::C:
            throw std::logic_error{"hakan"};
        case Enums::D...Enums::E:
            throw std::runtime_error{"gedek"};
    }
}
int main() {
    Enums A = Enums::A;
    Enums E = Enums::E;
    foo(E);
}
</code></pre>
<p>it's not valid but works :)</p>
<p>this is valid</p>
<pre><code class="language-c++">
enum class Enums {
    A,
    B,
    C,
    D,
    E
};

void foo(Enums E) {
    if (E &gt;= Enums::A &amp;&amp; E &lt;= Enums::C) {
        throw std::logic_error{"hakan"};
    } else if (E &gt;= Enums::D &amp;&amp; E &lt;= Enums::E) {
        throw std::runtime_error{"gedek"};
    }
}

int main() {
    Enums A = Enums::A;
    Enums E = Enums::E;
    foo(E);
}

</code></pre>
<blockquote>
<p>local enum because switch is more readable with enums than integers so local conversion done</p>
</blockquote>
<pre><code class="language-c++">
#include &lt;iostream&gt;

auto print(auto&amp;&amp;...arg) {
    (std::cout &lt;&lt; ... &lt;&lt; arg) &lt;&lt; std::endl;
}
void foo(int value) {
    enum Index: int {
        IN = 0,
        OUT,
        NONE
    };
    switch (value) {
        case Index::IN:
            print("Index::In"); break;
        case Index::OUT:
            print("Index::out"); break;
        default:
            print("Index::NONE"); break;
    }
}
int main() {
    foo(0);
    foo(1);
    foo(2);
    foo(3);
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="define-meta-functions"><a class="header" href="#define-meta-functions">define meta functions</a></h1>
<p>meta function: a template form which takes some params and used like functions. params passed through template header. check integral_constant for a good example.</p>
<p>useful for type_traits like true_type, false_type</p>
<pre><code class="language-c++">
template &lt;typename T&gt;
struct Is_Const {
    static constexpr auto value = false;
};
template &lt;typename T&gt;
struct Is_Const&lt;const T&gt; {
    static constexpr auto value = true;
};
template &lt;typename T&gt;
struct Is_Const&lt;const T&amp;&gt; {
    static constexpr auto value = true;
};
template &lt;typename T&gt;
struct Is_Const&lt;const T*&gt; {
    static constexpr auto value = true;
};
// variable
template &lt;typename T&gt;
constexpr auto Is_Const_v = Is_Const&lt;T&gt;::value;

</code></pre>
<p>in brief; struct template is used like a function call by template header so we pass usable params into template header and use it like function</p>
<pre><code class="language-c++">
template &lt;int N&gt;
struct Factorial {
    static const int value = N * Factorial&lt;N - 1&gt;::value;
};

// Base case specialization
template &lt;&gt;
struct Factorial&lt;0&gt; {
    static const int value = 1;
};

// Usage
int main() {
    int result = Factorial&lt;5&gt;::value; // result will be 120
    return 0;
}

</code></pre>
<p>check related page for using template header like function.</p>
<pre><code class="language-c++">
template &lt;typename T&gt;
struct S {
    enum { value = sizeof(test(T{} + T{}) == sizeof(T) };

    T test(const T&amp;);
    char test(...);
};


</code></pre>
<p>before enum was used... now static constexpr or static inline const.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-spanstream"><a class="header" href="#use-spanstream">use spanstream</a></h1>
<p>fixed buffer + input and output + no copying</p>
<ul>
<li>uses external buffer</li>
<li>performs input and output operations on this buffer</li>
<li>it doesn't copy the buffer data but works on it</li>
</ul>
<p>so it's like a toolkit to work on fixed buffer</p>
<pre><code class="language-c++">
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;memory_resource&gt;
#include &lt;print&gt;
#include &lt;ranges&gt;
#include &lt;spanstream&gt;

namespace ranges = std::ranges;
namespace views = std::ranges::views;
namespace pmr = std::pmr;


template &lt;class... Ts&gt;
constexpr auto range(Ts&amp;&amp;... args) {
    return views::iota(std::forward&lt;Ts&gt;(args)...);
}

struct Pair {
    int x{};
    int y{};

    constexpr auto operator&lt;=&gt;(const Pair&amp;) const noexcept = default;
};

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Pair&amp; p) {
    return out &lt;&lt; p.x &lt;&lt; ' ' &lt;&lt; p.y &lt;&lt; '\0';
}

std::istream&amp; operator&gt;&gt;(std::istream&amp; in, Pair&amp; p) { return in &gt;&gt; p.x &gt;&gt; p.y; }

void io_fixed_sized_buffer() {
    {
        {
            std::array&lt;char, 1024&gt; buffer;
            std::spanstream ss{buffer};
            ss &lt;&lt; "hello spanstream";
            std::println("{}", std::string_view{ss.span()});
        }
        {
            std::array&lt;char, 1024&gt; buffer;
            std::spanstream ss{buffer};

            ss &lt;&lt; "hello spanstream";
            std::string owner_of_data{std::string_view{ss.span()}};
            std::println("{}", owner_of_data);
        }
        {
            std::array&lt;char, 1024&gt; buffer;
            std::spanstream ss{buffer};

            int i = 101;
            float f = 2.34f;
            char _ = ' ';

            ss &lt;&lt; i &lt;&lt; _ &lt;&lt; f;
            std::println("{}", std ::string_view(ss.span()));

            ss &gt;&gt; i &gt;&gt; _ &gt;&gt; f;
            std::println("{} {}", i, f);
        }
        {
            std::array&lt;char, 1024&gt; buffer;
            std::spanstream ss{buffer};

            Pair p{.x = 101, .y = 202};
            ss &lt;&lt; p;

            std::println("{}", std::string_view{ss.span()});

            Pair p2;

            ss &gt;&gt; p2;
            std::cout &lt;&lt; p2 &lt;&lt; std::endl;
        }
    }
}

void pmr_ops() {
    char buffer[1024];
    pmr::monotonic_buffer_resource resource{
        buffer, sizeof buffer,
        pmr::null_memory_resource()  // don't allow to use heap for upstream
    };

    pmr::vector&lt;int&gt; v{&amp;resource};
    v.reserve(100);
    ranges::copy(views::iota(0, 100), std::back_inserter(v));
    ranges::copy(v, std::ostream_iterator&lt;int&gt;(std::cout, " "));
    std::println();
}

void placement_new() {
    constexpr size_t NUM_OF_PAIRS = 1;
    alignas(Pair) uint8_t buffer[NUM_OF_PAIRS * sizeof(Pair)];
    auto pair_ptr = new (&amp;buffer[0]) Pair{.x = 101, .y = 202};
    std::cout &lt;&lt; *pair_ptr &lt;&lt; std::endl;
    pair_ptr-&gt;~Pair();
}

void others() {
    constexpr size_t NUM_OF_PAIRS = 2;
    alignas(Pair) std::byte buffer[NUM_OF_PAIRS * sizeof(Pair)];
    Pair* pairs[NUM_OF_PAIRS];

    for (auto i = 0; i &lt; NUM_OF_PAIRS; ++i) {
        pairs[i] = std::construct_at(
            reinterpret_cast&lt;Pair*&gt;(&amp;buffer[i * sizeof(Pair)]), (1001 + i),
            (1001 + i));
    }

    for (auto i = 0; i &lt; NUM_OF_PAIRS; ++i) {
        std::cout &lt;&lt; *pairs[i] &lt;&lt; std::endl;
    }

    for (auto i = 0; i &lt; NUM_OF_PAIRS; ++i) std::destroy_at(pairs[i]);
}

int main() {
    io_fixed_sized_buffer();
    pmr_ops();
    placement_new();
    others();
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-disjunction-conjunction-negation"><a class="header" href="#use-disjunction-conjunction-negation">use disjunction, conjunction, negation</a></h1>
<p>these are called as evaluation methods for <code>types</code></p>
<p>disjunction: or the meta-functions + constants
conjunction: and the meta-functions + constants
negate: not the meta-functions + constants</p>
<p>they take boolean values - not types so you can use concepts, meta-functions, constexpr etc...as param in them.</p>
<blockquote>
<p>_v : these are not types but values. meta-functions use _t to define types and _v to define values so you can think them constexpr T or const T</p>
</blockquote>
<pre><code class="language-c++">
template &lt;typename... Ts&gt;
std::enable_if_t&lt;std::conjunction_v&lt;std::is_arithmetic&lt;Ts&gt;...&gt;&gt;
foo(Ts... numerics) {
    std::print("numerics\n");
}

template &lt;typename... Ts&gt;
std::enable_if_t&lt;!std::conjunction_v&lt;std::is_arithmetic&lt;Ts&gt;...&gt;&gt;
foo(Ts... non_numerics) {
    std::print("non-numerics\n");
}

int main() {
    foo(1, 2, 3, 4, 5);
    foo(1, 2, 'a', 3, 4, 5);
    foo(1, 2, "hakan", 3, 4, 5)
}

</code></pre>
<blockquote>
<p>disjunction (OR)</p>
</blockquote>
<pre><code class="language-c++">
template &lt;class T&gt;
using is_int_or_float_v = std::disjunction_v&lt;std::is_integral_v&lt;T&gt;, std::is_floating_point_v&lt;T&gt;&gt;;

int main() {
    std::cout &lt;&lt; is_int_or_float_v&lt;int&gt; &lt;&lt; std::endl;
    std::cout &lt;&lt; is_int_or_float_v&lt;char*&gt; &lt;&lt; std::endl;
}

</code></pre>
<blockquote>
<p>conjunction (AND)</p>
</blockquote>
<pre><code class="language-c++">
template &lt;class T&gt;
using is_int_and_const_v = std::conjunction_v&lt;std::is_integral_v&lt;T&gt;, std::is_const_v&lt;T&gt;&gt;;

int main() {
    std::cout &lt;&lt; is_int_and_const_v&lt;int const&gt; &lt;&lt; std::endl;
}

</code></pre>
<blockquote>
<p>negate (NOT)</p>
</blockquote>
<p>this may trigger suprise a little bit - if its content it true -&gt; false and if it's false -&gt; result: true ... when you naming the constant you should name it as not<em>of</em>(meta-func...or whatever you used)</p>
<p>is_not_int : negation&lt;is_integral_v&lt;T&gt;&gt;
is_not_floating_point: negation&lt;is_floating_point_v&lt;T&gt;&gt; : if it's floating point !(true) =&gt; false because we are looking for types which are not floating points</p>
<pre><code class="language-c++">
template &lt;class T&gt;
using is_not_int_v = std::negation_v&lt;std::is_integral_v&lt;T&gt;&gt;; // !(int) =&gt; is_not_int -&gt; good naming

int main() {
    std::cout  &lt;&lt; is_not_int_v&lt;float&gt; &lt;&lt; std::endl;
    std::cout  &lt;&lt; is_not_int_v&lt;int&gt; &lt;&lt; std::endl;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-c-variadics"><a class="header" href="#use-c-variadics">use c variadics</a></h1>
<p>c supports variadics. cstdarg.h has</p>
<ul>
<li>va_list : type holds the arg info</li>
<li>va_arg: retrieves the next arg in the list</li>
<li>va_start : initialize the va_list with the args</li>
<li>va_end : cleans the va_list</li>
</ul>
<p>macros. variadic arguments are fixed and pushed through stack mem.</p>
<blockquote>
<p>va_start takes 2 params. first va_list to initialize and second fixed param passed before ... into function to locate where the args starts in the memory</p>
</blockquote>
<pre><code class="language-c++">
#include &lt;cstdarg&gt;
#include &lt;iostream&gt;

int sum(int count, ...) {
    va_list args;

    va_start(args, count); // count is important

    int total = 0;

    for (auto i = 0; i &lt; count; ++i) {
        total += va_arg(args, int); //
    }

    va_end(args);

    return total;
}

int main() {
    std::cout &lt;&lt; "sum of 1,2,3: " &lt;&lt; sum(3, 1,2,3) &lt;&lt; std::endl;
}

</code></pre>
<p>formatting with variadics</p>
<pre><code class="language-c++">
#include &lt;cstdarg&gt;
#include &lt;iostream&gt;

void print_values(const char* format, ...) {
    va_list args;
    va_start(args, format);

    while (*format != '\0') {
        if (*format == 'd') {
            int i = va_arg(args, int);
            std::cout &lt;&lt; i &lt;&lt; std::endl;
        } else if (*format == 'c') {
            int c = va_arg(args, int);
            std::cout &lt;&lt; c &lt;&lt; std::endl;
        } else if (*format == 'f') {
            double d = va_arg(args, double);
            std::cout &lt;&lt; d &lt;&lt; std::endl;
        }

        ++format;
    }

    va_end(args);

    std::cout &lt;&lt; std::endl;
}

int main() { print_values("%d %c %f", 1, 'a', 3.12);
</code></pre>
<p>using with vprintf</p>
<pre><code class="language-c++">#include &lt;cstdarg&gt;
#include &lt;cstdio&gt;
#include &lt;iostream&gt;

void log_message(const char* level, const char* format, ...) {
    std::cout &lt;&lt; "[" &lt;&lt; level &lt;&lt; "]";

    va_list args;
    va_start(args, format);
    vprintf(format, args);
    va_end(args);

    std::cout &lt;&lt; std::endl;
}

int main() {
    log_message("INFO", "info: %s %d", "test", 102);
    log_message("ERROR", "error: invalid text: %s", "file.txt");
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implement-registry-pattern"><a class="header" href="#implement-registry-pattern">implement registry pattern</a></h1>
<p>service locator pattern. using keys or lookup identifications; locate service in the registry.</p>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;stdexcept&gt;
#include &lt;string&gt;
#include &lt;typeindex&gt;
#include &lt;typeinfo&gt;
#include &lt;unordered_map&gt;

class Service {
   public:
    virtual ~Service() = default;
    virtual void execute() = 0;
};

class ExampleService : public Service {
   public:
    void execute() override {
        std::cout &lt;&lt; "example service executing" &lt;&lt; std::endl;
    }
};

class Registry {
   public:
    template &lt;class T&gt;
        requires std::derived_from&lt;T, Service&gt;
    void registerService(const std::string&amp; name, std::shared_ptr&lt;T&gt; service) {
        services[name] = service;
    }

    template &lt;class T&gt;
    std::shared_ptr&lt;T&gt; getService(const std::string&amp; name) const {
        if (auto it = services.find(name); it != services.end()) {
            using ValueType =
                typename std::remove_pointer&lt;decltype(it-&gt;second.get())&gt;::type;

            if (not std::derived_from&lt;T, ValueType&gt;)
                throw std::runtime_error("not convertible");

            return std::static_pointer_cast&lt;T&gt;(it-&gt;second);
        }

        throw std::runtime_error("service not found");
    }

   private:
    std::unordered_map&lt;std::string, std::shared_ptr&lt;Service&gt;&gt; services;
};

int main() {
    Registry registry;

    std::shared_ptr&lt;ExampleService&gt; example =
        std::make_shared&lt;ExampleService&gt;();

    registry.registerService("example", example);

    try {
        auto service = registry.getService&lt;ExampleService&gt;("example");
        service-&gt;execute();
    } catch (std::runtime_error const&amp; e) {
        std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
    }


</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-macros"><a class="header" href="#use-macros">use macros</a></h1>
<p>which use cases valid for macros ?</p>
<ul>
<li>boilerplate coding
<ul>
<li>copy - paste / replacing style coding</li>
</ul>
</li>
<li>conditional coding
<ul>
<li>feature enabling / disabling depending on defined/not defined features in a globally accessible file
<ul>
<li>value based</li>
<li>state based</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>macros are not good for true constant or compile time constants because they don't have memory address.</p>
<p>ok.. time to share some how to handle boiler plate coding with macros...</p>
<blockquote>
<p>preprocessor can replace macro args with used areas so you can think them like placeholders or aliases or variables but without type - just values</p>
</blockquote>
<blockquote>
<p>wrapping macro args with () is a good habit because you cannot be sure what passed into macro so best is use () with args as much as possible</p>
</blockquote>
<pre><code class="language-c++">
#define PROPERTY(type, name)                     \
   private:                                      \
    type _##name;                                \
                                                 \
   public:                                       \
    const type&amp; name() const { return _##name; } \
    void set_##name(const type&amp; value) { _##name = value; }

struct MyS {
    PROPERTY(int, id);
    PROPERTY(std::string, name);
};

int main() {
    MyS ms;
    ms.set_id(101);
    ms.set_name("hakan gedek");

    std::cout &lt;&lt; ms.id() &lt;&lt; ":" &lt;&lt; ms.name() &lt;&lt; std::endl;
}

</code></pre>
<p>a long example which shows how to create a class with getter/setter impls, how to create an enum...</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;memory&gt;
#include &lt;cassert&gt;

// 1. Simple debug logging macro
#ifdef DEBUG
    #define LOG(message) std::cout &lt;&lt; "[DEBUG] " &lt;&lt; __FILE__ &lt;&lt; ":" &lt;&lt; __LINE__ &lt;&lt; " " &lt;&lt; message &lt;&lt; std::endl
#else
    #define LOG(message) // Defines to nothing in release builds
#endif

// 2. Assert macro with better error messages
#define ASSERT(condition, message) \
    do { \
        if (!(condition)) { \
            std::cerr &lt;&lt; "Assertion failed: " &lt;&lt; #condition &lt;&lt; "\n" \
                      &lt;&lt; "Message: " &lt;&lt; message &lt;&lt; "\n" \
                      &lt;&lt; "File: " &lt;&lt; __FILE__ &lt;&lt; "\n" \
                      &lt;&lt; "Line: " &lt;&lt; __LINE__ &lt;&lt; std::endl; \
            std::abort(); \
        } \
    } while (0)

// 3. Property accessors macro
#define PROPERTY(type, name) \
private: \
    type name##_; \
public: \
    const type&amp; name() const { return name##_; } \
    void set_##name(const type&amp; value) { name##_ = value; }

// 4. Singleton pattern macro
#define DECLARE_SINGLETON(className) \
public: \
    static className&amp; getInstance() { \
        static className instance; \
        return instance; \
    } \
private: \
    className() = default; \
    ~className() = default; \
    className(const className&amp;) = delete; \
    className&amp; operator=(const className&amp;) = delete; \
    className(className&amp;&amp;) = delete; \
    className&amp; operator=(className&amp;&amp;) = delete

// 5. Factory method registration macro
#define REGISTER_PRODUCT(productId, productClass) \
    static bool registeredProduct_##productClass = Factory::registerProduct(productId, \
        []() -&gt; std::unique_ptr&lt;Product&gt; { return std::make_unique&lt;productClass&gt;(); })

// 6. String switch macro (C++ doesn't have native string switches)
#define STRING_SWITCH(str) const std::string&amp; _switch_str = (str); if (false)
#define CASE(str) } else if (_switch_str == (str)) {
#define DEFAULT } else {

// 7. Automated class reflection-style macros
#define BEGIN_PROPERTIES(className) \
    static std::vector&lt;std::string&gt; getPropertyNames() { \
        std::vector&lt;std::string&gt; props;

#define PROPERTY_NAME(name) props.push_back(#name);

#define END_PROPERTIES \
        return props; \
    }

// 8. Enum-to-string conversion macro
#define ENUM_TO_STRING(enumType) \
    inline std::string enumToString(enumType value) { \
        switch (value) {

#define ENUM_VALUE(value) \
        case enumType::value: \
            return #value;

#define END_ENUM_TO_STRING \
        default: \
            return "Unknown"; \
        } \
    }

// Example usage of the macros

// Example with property macros
class Person {
    PROPERTY(std::string, name)
    PROPERTY(int, age)

public:
    Person(const std::string&amp; name, int age) : name_(name), age_(age) {}

    BEGIN_PROPERTIES(Person)
        PROPERTY_NAME(name)
        PROPERTY_NAME(age)
    END_PROPERTIES
};

// Example with enum-to-string macros
enum class Color { Red, Green, Blue, Yellow };

ENUM_TO_STRING(Color)
    ENUM_VALUE(Red)
    ENUM_VALUE(Green)
    ENUM_VALUE(Blue)
    ENUM_VALUE(Yellow)
END_ENUM_TO_STRING

// Example with singleton pattern
class Configuration {
    DECLARE_SINGLETON(Configuration);

public:
    std::string getDatabaseUrl() const { return "jdbc:mysql://localhost:3306/mydb"; }
};

// Example with factory pattern
class Product {
public:
    virtual ~Product() = default;
    virtual std::string getName() const = 0;
};

class ConcreteProductA : public Product {
public:
    std::string getName() const override { return "ProductA"; }
};

class ConcreteProductB : public Product {
public:
    std::string getName() const override { return "ProductB"; }
};

class Factory {
public:
    using Creator = std::function&lt;std::unique_ptr&lt;Product&gt;()&gt;;

    static bool registerProduct(const std::string&amp; id, Creator creator) {
        getRegistry()[id] = creator;
        return true;
    }

    static std::unique_ptr&lt;Product&gt; createProduct(const std::string&amp; id) {
        auto it = getRegistry().find(id);
        if (it != getRegistry().end()) {
            return it-&gt;second();
        }
        return nullptr;
    }

private:
    static std::map&lt;std::string, Creator&gt;&amp; getRegistry() {
        static std::map&lt;std::string, Creator&gt; registry;
        return registry;
    }
};

// Register products
REGISTER_PRODUCT("A", ConcreteProductA);
REGISTER_PRODUCT("B", ConcreteProductB);

int main() {
    // Using debug logging macro
    LOG("Application started");

    // Using assert macro
    int x = 5;
    ASSERT(x == 5, "x should be 5");

    // Using property macros
    Person person("John", 30);
    std::cout &lt;&lt; "Name: " &lt;&lt; person.name() &lt;&lt; ", Age: " &lt;&lt; person.age() &lt;&lt; std::endl;
    person.set_age(31);
    std::cout &lt;&lt; "Updated age: " &lt;&lt; person.age() &lt;&lt; std::endl;

    // Using reflection-style property listing
    std::cout &lt;&lt; "Person properties: ";
    for (const auto&amp; prop : Person::getPropertyNames()) {
        std::cout &lt;&lt; prop &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;

    // Using enum-to-string conversion
    Color color = Color::Blue;
    std::cout &lt;&lt; "Color: " &lt;&lt; enumToString(color) &lt;&lt; std::endl;

    // Using singleton pattern
    auto&amp; config = Configuration::getInstance();
    std::cout &lt;&lt; "DB URL: " &lt;&lt; config.getDatabaseUrl() &lt;&lt; std::endl;

    // Using factory pattern with registration macros
    auto productA = Factory::createProduct("A");
    std::cout &lt;&lt; "Created: " &lt;&lt; productA-&gt;getName() &lt;&lt; std::endl;

    // Using string switch macro
    std::string fruit = "apple";
    STRING_SWITCH(fruit) {
        CASE("apple")
            std::cout &lt;&lt; "It's an apple" &lt;&lt; std::endl;
        CASE("orange")
            std::cout &lt;&lt; "It's an orange" &lt;&lt; std::endl;
        DEFAULT
            std::cout &lt;&lt; "Unknown fruit" &lt;&lt; std::endl;
    }

    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-void_t"><a class="header" href="#use-void_t">use void_t</a></h1>
<p>c++ supports template variables and aliases.</p>
<pre><code class="language-c++">#include &lt;vector&gt;

template &lt;class T&gt;
using vector_t = std::vector&lt;T&gt;;


int main() {
    vector_t&lt;int&gt; v {1,2,3,4};
    return 0;
}
</code></pre>
<blockquote>
<p>variadic params is a useful method to create sink hole... by creating a meta-function etc. you can consume all and don't return anything ( yes we are talking about types like values which they are)</p>
</blockquote>
<blockquote>
<p>variadic params allow you to capture them like an initializer_list of types</p>
</blockquote>
<p>void_t : a special template void ... it's created to eat all and return void and it's part of sfinae.</p>
<blockquote>
<p>important point: you pass unlimited types into it but it gives back void but you pass TYPEs into it's args list &lt;&gt; not constants.</p>
</blockquote>
<blockquote>
<p>void_t generally works with decltype(declval<T>) or decltype(declval&lt;T&amp;&gt;) and both feeds it with some type info which is the result of tested logic.</p>
</blockquote>
<pre><code class="language-c++">

template &lt;class, class = void&gt;
struct has_pre_incr : std::false_type {};

template &lt;class T&gt;
struct has_pre_incr&lt;T, std::void_t&lt;decltype(++std::declval&lt;T&amp;&gt;())&gt;&gt;
    : std::true_type {};

struct MyS {};

int main() {
    std::cout &lt;&lt; has_pre_incr&lt;MyS&gt;::value &lt;&lt; std::endl;
    std::cout &lt;&lt; has_pre_incr&lt;int&gt;::value &lt;&lt; std::endl;

}
</code></pre>
<p>template variables are also part of meta-functions...</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;vector&gt;

template &lt;class, class = void&gt;
constexpr bool is_iterable = false;

template &lt;class T&gt;
constexpr bool is_iterable&lt;T, std::void_t&lt;decltype(std::declval&lt;T&gt;().begin()),
                                          decltype(std::declval&lt;T&gt;().end())&gt;&gt; =
    true;

int main() {
    std::cout &lt;&lt; is_iterable&lt;int&gt; &lt;&lt; std::endl;
    std::cout &lt;&lt; is_iterable&lt;std::vector&lt;int&gt;::iterator&gt; &lt;&lt; std::endl;
    std::cout &lt;&lt; is_iterable&lt;std::vector&lt;int&gt;&gt; &lt;&lt; std::endl;
}
</code></pre>
<p>and full testing: we can ask a type if it has a field or func like T::member, T::func =&gt; think the member pointers.</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;type_traits&gt;

template &lt;class, class = void&gt;
struct has_member : std::false_type {};

template &lt;class T&gt;
struct has_member&lt;T, std::void_t&lt;decltype(T::member)&gt;&gt; : std::true_type {};

template &lt;class T&gt;
constexpr auto has_member_v = has_member&lt;T&gt;::value;

struct MyS {
    int number;
};

struct MyOtherS {
    int member;
};

int main() {
    std::cout &lt;&lt; std::boolalpha;
    std::cout &lt;&lt; has_member_v&lt;MyS&gt; &lt;&lt; std::endl;
    std::cout &lt;&lt; has_member_v&lt;int&gt; &lt;&lt; std::endl;
    std::cout &lt;&lt; has_member_v&lt;MyOtherS&gt; &lt;&lt; std::endl;
}

</code></pre>
<p>a container test:</p>
<pre><code class="language-c++">
// Check if a type is a container-like type
template&lt;typename T, typename = void&gt;
struct is_container_like : std::false_type {};

template&lt;typename T&gt;
struct is_container_like&lt;T, std::void_t
    typename T::value_type,
    typename T::iterator,
    decltype(std::declval&lt;T&gt;().begin()),
    decltype(std::declval&lt;T&gt;().end()),
    decltype(std::declval&lt;T&gt;().size())
&gt;&gt; : std::true_type {};
</code></pre>
<p>it also can be used with sfinae to overload a function:</p>
<pre><code class="language-c++">// Call .reserve() on containers that support it
template&lt;typename Container&gt;
auto optimize_storage(Container&amp; c, size_t new_capacity)
    -&gt; std::void_t&lt;decltype(c.reserve(new_capacity))&gt; {
    c.reserve(new_capacity);
    // Other optimizations...
}

// Fallback for containers without .reserve()
template&lt;typename Container&gt;
void optimize_storage(Container&amp; c, size_t) {
    // Alternative optimizations...
}
</code></pre>
<p>check if a type has to_string method:</p>
<pre><code class="language-c++">// Detection idiom with void_t
template&lt;typename Default, typename AlwaysVoid, template&lt;typename...&gt; class Op, typename... Args&gt;
struct detector {
    using value_type = std::false_type;
    using type = Default;
};

template&lt;typename Default, template&lt;typename...&gt; class Op, typename... Args&gt;
struct detector&lt;Default, std::void_t&lt;Op&lt;Args...&gt;&gt;, Op, Args...&gt; {
    using value_type = std::true_type;
    using type = Op&lt;Args...&gt;;
};

// Usage
template&lt;typename T&gt;
using has_to_string_t = decltype(std::declval&lt;T&gt;().to_string());

template&lt;typename T&gt;
using has_to_string = detector&lt;void, void, has_to_string_t, T&gt;;

struct MyS {
    std::string to_string();
};

int main() {
    std::cout &lt;&lt; has_to_string&lt;MyS&gt;::value &lt;&lt; std::endl;
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-anonymous-struct-and-union"><a class="header" href="#use-anonymous-struct-and-union">use anonymous struct and union</a></h1>
<p>named and unnamed structs/unions; both exist in c++</p>
<p>if you will only keep them in class boundaries and never share outside like none will need to crate an object of these types then using them to group related fields is really good.</p>
<p>at the end; like inline namespace members; anonymous unions/structs fields will be belong to outer and will be accessed without any middle layer.</p>
<p>a simple struct example:</p>
<pre><code class="language-c++">
struct Outer {
    struct {
        int x;
        int y;
    };

    void print() {
        std::cout &lt;&lt; x &lt;&lt; ":" &lt;&lt; y &lt;&lt; std::endl;
    }
};

int main() {
    Outer o;
    o.x = 10;
    o.y = 20;
    o.print();
}
</code></pre>
<p>a simple union example:</p>
<pre><code class="language-c++">
struct Data {
private:
    enum {
        INT,
        FLOAT
    } type;

    union {
        int iVal;
        float fVal;
    };

public:
    void print() {
        if (type == INT)
            std::cout &lt;&lt; "value: " &lt;&lt; iVal &lt;&lt; std::endl;
        else
            std::cout &lt;&lt; "value: " &lt;&lt; fVal &lt;&lt; std::endl;
    }

    void set(int value) {
        type = INT;
        iVal = value;
    }
    void set(float value) {
        type = FLOAT;
        fVal = value;
    }
};

int main() {
    Data d;
    d.set(1012);
    d.print();
    d.set(2.34f);
    d.print();
}

</code></pre>
<p>or combined:</p>
<pre><code class="language-c++">
struct Complex {
    union {
        struct {
            int a;
            int b;
        };
        float c;
    };

    void print() {
        std::cout &lt;&lt; "a: " &lt;&lt; a &lt;&lt; ", b: " &lt;&lt; b &lt;&lt; ", c: " &lt;&lt; c &lt;&lt; std::endl;
    }
};

int main() {
    Complex comp;
    comp.a = 1;
    comp.b = 2;
    comp.print();
    comp.c = 3.14f;
    comp.print();
    return 0;
}
</code></pre>
<p>and more detailed structure: union wraps the memory and allows the contents to share it. max sized field will decide the mem size, others will use only the size they can.</p>
<pre><code class="language-c++">
struct PixelData {
    // 4 bytes
    enum ColorMode { RGB, HSV, CMYK } mode;

    // 12 bytes
    union {
        // 3 bytes
        struct {
            uint8_t r;
            uint8_t g;
            uint8_t b;
        };

        // 12 bytes
        struct {
            float h;
            float s;
            float v;
        };

        // size: 4 bytes
        struct {
            uint8_t c;
            uint8_t m;
            uint8_t y;
            uint8_t k;
        };
    };

    // Constructor for RGB
    PixelData(uint8_t red, uint8_t green, uint8_t blue) : mode(RGB), r(red), g(green), b(blue) {}

    // Constructor for HSV
    PixelData(float hue, float saturation, float value) : mode(HSV), h(hue), s(saturation), v(value) {}
}; // =&gt; 16 bytes

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-atomic-stdshared_ptr"><a class="header" href="#use-atomic-stdshared_ptr">use atomic std::shared_ptr</a></h1>
<p>std::shared_ptr is created to manage sharing ownership so a resource can be shared by different components of a program. but also we can use it in multiple threads too - if there is a shared resource in multi-threaded solution then there is race condition. how to solve it ?</p>
<p>basically:</p>
<ul>
<li>mutex : condition_variable, locks....</li>
<li>atomics: atomic, atomic_flag...</li>
<li>semaphores: binary_semaphore...</li>
</ul>
<p>fastest and safest of them is atomics... so now we can use shared_ptr with atomics like an atomic_bool or int.</p>
<pre><code class="language-c++">#include &lt;atomic&gt;
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;thread&gt;

using namespace std::chrono_literals;

struct Data {
    int value;

    Data(int val) : value(val) {}
};

std::atomic&lt;std::shared_ptr&lt;Data&gt;&gt; sPtr;

void reader() {
    for (auto i = 0; i &lt; 10; i++) {
        if (auto ptr = sPtr.load(); ptr) {
            std::cout &lt;&lt; "reader: " &lt;&lt; ptr-&gt;value &lt;&lt; std::endl;
        }
        std::this_thread::sleep_for(10ms);
    }
}

void writer() {
    for (auto i = 0; i &lt; 10; i++) {
        auto ptr = std::make_shared&lt;Data&gt;(i);
        sPtr.store(ptr);
        std::cout &lt;&lt; "writer: " &lt;&lt; ptr-&gt;value &lt;&lt; std::endl;
        std::this_thread::sleep_for(20ms);
    }
}

int main() {
    sPtr.store(std::make_shared&lt;Data&gt;(0));

    {
        std::jthread j0{reader}, j1{writer};
    }

    return 0;
}

</code></pre>
<pre><code class="language-c++">writer: 0
reader: 0
reader: 0
writer: 1
reader: 1
reader: 1
writer: 2
reader: 2
reader: 2
writer: 3
reader: 3
reader: 3
writer: 4
reader: 4
reader: 4
writer: 5
writer: 6
writer: 7
writer: 8
writer: 9
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-threeway-comparision"><a class="header" href="#use-threeway-comparision">use threeway comparision</a></h1>
<p>c++ added spaceship operator or three way comparison operator which results</p>
<ul>
<li>strong ordering</li>
<li>weak ordering</li>
<li>partial ordering</li>
</ul>
<p>strong_ordering:</p>
<ul>
<li>less &lt; 0</li>
<li>equal = 0</li>
<li>greater &gt;0</li>
</ul>
<p>weak_ordering:</p>
<ul>
<li>less &lt;0</li>
<li>equivalent = 0</li>
<li>greater &gt; 0</li>
</ul>
<p>partial_ordering:</p>
<ul>
<li>less</li>
<li>equivalent</li>
<li>greater</li>
<li>unordered ? invalid data like float::inf or nan</li>
</ul>
<p>these are good to have implementation. if your fields are known types like int, string..just set it to default and go on.</p>
<pre><code class="language-c++">
struct StrongType {
    int value;

    auto operator&lt;=&gt;(const StrongType&amp;) const = default;
};

int main() {
    StrongType t0{10}, t1{20};

    if (auto cmp = a &lt;=&gt; b; cmp &lt; 0) {
        std::cout &lt;&lt; "a is less then b" &lt;&lt; std::endl;
    } else if (cmp &gt; 0) {
        std::cout &lt;&lt; "a is less then b" &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; "a is equal to b" &lt;&lt; std::endl;
    }
}

</code></pre>
<pre><code class="language-c++">
struct Integer {
    int value;

    std::strong_ordering operator&lt;=&gt;(const Integer&amp; other) const {
        return value &lt;=&gt; other.value;
    }

    // implement this if only default is not enough - compiler generates this if &lt;=&gt; return strong_ordering
    // or to satisfy std::three_way_comparable_with
    // std::compare_three_way{}(a, b));
    // support both == and &lt;=&gt;
    // bool operator==(const Integer&amp; other) const {
    //     return value == other.value;
    // }
};


struct String {
    std::string text;

    std::weak_ordering operator&lt;=&gt;(const String&amp; other) const {
        auto s1 = toLower(text);
        auto s2 = toLower(other.text);

        return s1 &lt;=&gt; s2;
    }

    // implement this if only default is not enough - compiler generates this if &lt;=&gt; return strong_ordering
    // or to satisfy std::three_way_comparable_with
    // std::compare_three_way{}(a, b));
    // support both == and &lt;=&gt;
    // bool operator==(const String&amp; other) const {
    //     return text == other.text;
    // }
};


struct Float {
    float value;

    std::partial_ordering operator&lt;=&gt;(const Float&amp; other) const {
        return value &lt;=&gt;other.value;
    }

    // compiler doesn't generate this for partial_ordering so if need ? then impl.
    bool operator==(const Float&amp; other) const {
        return value == other.value;
    }
};

</code></pre>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;compare&gt; // c++20 header

struct Point {
    int x, y;

    std::strong_ordering operator&lt;=&gt;(const Point&amp; other) const {
        if (auto cmp = x &lt;=&gt; other.x; cmp != 0)
            return cmp;
        return y &lt;=&gt; other.y;
    }

    bool operator==(const Point&amp;) const = default;
};

int main() {
    Point p1{1, 2};
    Point p2{1, 3};
    Point p3{1, 2};

    if (p1 &lt; p2) std::cout &lt;&lt; "p1 &lt; p2" &lt;&lt; std::endl;
    if (p1 == p3) std::cout &lt;&lt; "p1 == p3" &lt;&lt; std::endl;

    auto result = p1 &lt;=&gt; p2;

    if (result == std::strong_ordering::less)
        std::cout &lt;&lt; "p1 is less than p2" &lt;&lt; std::endl;
}

</code></pre>
<blockquote>
<p>std::compare_three_way: a functor returns ordering enums - pick the result whatever you want</p>
</blockquote>
<p>std::compare_three_way{}(a ,b) =&gt; weak_ordering, strong_ordering, partial_ordering</p>
<blockquote>
<p>use partial with float, double for unordered type: result of a state which not comparable</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-template-vars-like-meta-functions"><a class="header" href="#use-template-vars-like-meta-functions">use template vars like meta-functions</a></h1>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;vector&gt;

template &lt;class, class = void&gt;
constexpr bool is_iterable = false;

template &lt;class T&gt;
constexpr bool is_iterable&lt;T, std::void_t&lt;decltype(std::declval&lt;T&gt;().begin()),
                                          decltype(std::declval&lt;T&gt;().end())&gt;&gt; =
    true;

int main() {
    std::cout &lt;&lt; is_iterable&lt;int&gt; &lt;&lt; std::endl;
    std::cout &lt;&lt; is_iterable&lt;std::vector&lt;int&gt;::iterator&gt; &lt;&lt; std::endl;
    std::cout &lt;&lt; is_iterable&lt;std::vector&lt;int&gt;&gt; &lt;&lt; std::endl;
}
</code></pre>
<p>a metafunction is a struct with static states like type or value;
a template variable is either of them - type or value...</p>
<pre><code class="language-c++">
template &lt;class T, class U&gt;
constexpr bool is_same_v = std::is_same&lt;T,U&gt;::value; // this is not a static variable but just const

template &lt;class, class = void&gt;
struct has_size_method: std::false_type{};

template&lt;class T&gt;
struct has_size_method_&lt;T, std::void_t&lt;decltype(std::declval&lt;T&gt;().size())&gt;&gt;: std::true_type{};

template &lt;class T&gt;
struct has_size_method_v = has_size_method&lt;T&gt;::value;

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-rangeviews-adaptors"><a class="header" href="#use-rangeviews-adaptors">use range::views adaptors</a></h1>
<p>ranges has view types and views has adaptors (makers or helpers) to create them. you can create them directly via ranges or using views adapters which I prefer - easier.</p>
<p>there are fundamental view types like ref_view, owning_view or common_view. each has own reasons to exist to play.</p>
<p>ref_view: allows us not to copy and just borrow which makes the difference.</p>
<p>owning_view: takes ownership so there is copy action here...but you should decide are you owner or user ?</p>
<blockquote>
<p>views are lazy...when you need it works</p>
</blockquote>
<blockquote>
<p>start the journey of the container with all. this adapter creates either ref_view or owning_view</p>
</blockquote>
<blockquote>
<p>common_view|common: convert a view to common_range which has same type iterator and sentinel</p>
</blockquote>
<p>sentinel ? this is very important here...it's new concept of end of the range...end(): standard and sentinel: new. it allows more flexible approach so using common_view/common will return something old stuff.</p>
<pre><code class="language-c++">
// ref_view


#include &lt;iostream&gt;
#include &lt;ranges&gt;
#include &lt;vector&gt;

struct MyS {
    MyS(int val) : value(val) {}
    MyS(const MyS&amp;) = delete;
    MyS&amp; operator=(const MyS&amp;) = delete;
    MyS(MyS&amp;&amp;) = default;
    MyS&amp; operator=(MyS&amp;&amp;) = default;

    int value;
};

int main() {
    std::vector&lt;MyS&gt; v;
    v.emplace_back(1);
    v.emplace_back(3);
    v.emplace_back(2);

    std::ranges::ref_view rv{v};

    for (auto&amp;&amp; ms : rv) std::cout &lt;&lt; ms.value &lt;&lt; std::endl;
}
</code></pre>
<p>common_view:</p>
<pre><code class="language-c++">
// common_view

#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;ranges&gt;

int main() {
    std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};
    auto commonView = std::ranges::common_view(vec);

    for (int n : commonView) {
        std::cout &lt;&lt; n &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<blockquote>
<p>how to convert a std container to view ?</p>
</blockquote>
<pre><code class="language-c++">
std::vector&lt;int&gt; v{0, 1, 2, 3, 4, 5};

// input is v =&gt; piped to all =&gt; get a ref_view =&gt; piped into take =&gt; take_view...
for (int n : std::views::all(v) | std::views::take(2))
    std::cout &lt;&lt; n &lt;&lt; ' ';

std::cout &lt;&lt; '\n';

</code></pre>
<h2 id="common-views-and-usages"><a class="header" href="#common-views-and-usages">common views and usages</a></h2>
<pre><code class="language-c++">auto even_numbers = numbers | views::filter([](int n) { return n % 2 == 0;});

auto squared = numbers | views::transform([](int n) { return n *  n; });

auto first_three = numbers | views::take(3);

auto skip_first_three = numbers | views::drop(3);

auto reversed = numbers | views::reverse;

std::vector&lt;std::vector&lt;int&gt;&gt; vv = {{1,2}, {2,3},{4,5}};
auto flattened = vv | views::join; // {1,2,2,3,4,5}

auto split = "hello,world,c++"s | views::split(',');


for (auto const [index, value] : numbers | views::enumerate) {
    std::cout &lt;&lt; index &lt;&lt; ":" &lt;&lt; value &lt;&lt; std::endl;
}

auto result = numbers
            | views::filter([](int value) { return value &gt; 0;}) // take positives
            | views::transform([](int value) { return value * 2}); // double
            | views::take(5);


</code></pre>
<pre><code class="language-c++">

#include &lt;iostream&gt;
#include &lt;ranges&gt;
#include &lt;vector&gt;

namespace views = std::ranges::views;

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5, 6};

    auto even_squares = numbers |
                        views::filter([](int val) { return val % 2 == 0; }) |
                        views::transform([](int val) { return val * val; });

    for (auto x : even_squares) {
        std::cout &lt;&lt; x &lt;&lt; std::endl;
    }

    std::vector&lt;std::string&gt; words = {"hakan", "gedek", "coventry", "c++"};

    auto capitilized =
        words |
        views::filter([](const std::string&amp; s) { return s.length() &gt; 3; }) |
        views::transform([](std::string&amp; s) {
            s[0] = std::toupper(s[0]);
            return s;
        });
    for (auto&amp; w : words) std::cout &lt;&lt; w &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';

    for (auto&amp;&amp; w : capitilized) std::cout &lt;&lt; w &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';

}

</code></pre>
<p>and a special tool: istream_view</p>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;ranges&gt;

int main() {
    std::cout &lt;&lt; "Enter some integers: ";

    auto input_view = std::ranges::istream_view&lt;int&gt;(std::cin);

    auto filtered_view =
        input_view | std::views::filter([](auto n) { return n % 2 != 0; });

    auto squared_view =
        filtered_view | std::views::transform([](auto n) { return n * n; });

    std::cout &lt;&lt; "Odd squares: ";

    for (int n : squared_view) {
        std::cout &lt;&lt; n &lt;&lt; " ";
    }

    std::cout &lt;&lt; std::endl;

    return 0;


</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-extern-keyword"><a class="header" href="#use-extern-keyword">use extern keyword</a></h1>
<p>it's used to declare a variable or function external so their definitions are in another translation unit (cpp). it's now linker's responsibility to find it and bind it.</p>
<pre><code class="language-c++">
// a.cpp

int sharedVariable = 42;
// Definition of the external const variable
const int sharedConstVariable = 100;


// main.cpp
#include &lt;iostream&gt;

// Declaration of the external variable
extern int sharedVariable;
// Declaration of the external const variable
extern const int sharedConstVariable;


int main() {
    std::cout &lt;&lt; "Shared variable: " &lt;&lt; sharedVariable &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<p>or functions =&gt; you can put extern function() into header file to so anyone includes that header file will be accessing it...</p>
<blockquote>
<p>function declarations in header files are implicitly external ( they already have it)</p>
</blockquote>
<blockquote>
<p>class and namespace are implicitly external too but putting this in front of functions makes things explicit.</p>
</blockquote>
<pre><code class="language-c++">
// a.cpp
#include &lt;iostream&gt;

// Definition of the external function
void printMessage() {
    std::cout &lt;&lt; "Hello from the shared function!" &lt;&lt; std::endl;
}

// main.cpp

#include &lt;iostream&gt;

// Declaration of the external function
extern void printMessage();

int main() {
    printMessage();
    return 0;
}

</code></pre>
<ul>
<li>Function Declarations: Implicitly external in header files.</li>
<li>Class Declarations: Implicitly external in header files.</li>
<li>Namespace Declarations: Implicitly external in header files.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-from_chars-and-to_chars"><a class="header" href="#use-from_chars-and-to_chars">use from_chars and to_chars</a></h1>
<p>high performance &amp; low-level conversion methods... safety of the operation belongs to you.</p>
<p>you can convert numerics =&gt; string and string =&gt; numerics via them.</p>
<blockquote>
<p>integer to string</p>
</blockquote>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;charconv&gt;

int main() {
    char buffer[20];
    int value = 12345;

    auto result = std::to_chars(buffer, buffer + sizeof(buffer), value);
    if (result.ec == std::errc()) {
        std::cout &lt;&lt; "Converted value: " &lt;&lt; std::string(buffer, result.ptr) &lt;&lt; std::endl;
    } else {
        std::cerr &lt;&lt; "Conversion failed" &lt;&lt; std::endl;
    }

    return 0;
}

</code></pre>
<blockquote>
<p>floating point to string</p>
</blockquote>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;charconv&gt;

int main() {
    char buffer[20];
    double value = 123.456;

    auto result = std::to_chars(buffer, buffer + sizeof(buffer), value, std::chars_format::fixed);
    if (result.ec == std::errc()) {
        std::cout &lt;&lt; "Converted value: " &lt;&lt; std::string(buffer, result.ptr) &lt;&lt; std::endl;
    } else {
        std::cerr &lt;&lt; "Conversion failed" &lt;&lt; std::endl;
    }

    return 0;
}
</code></pre>
<blockquote>
<p>string to int</p>
</blockquote>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;charconv&gt;
#include &lt;string&gt;

int main() {
    std::string str = "12345";
    int value;

    auto result = std::from_chars(str.data(), str.data() + str.size(), value);
    if (result.ec == std::errc()) {
        std::cout &lt;&lt; "Converted value: " &lt;&lt; value &lt;&lt; std::endl;
    } else {
        std::cerr &lt;&lt; "Conversion failed" &lt;&lt; std::endl;
    }

    return 0;
}
</code></pre>
<blockquote>
<p>string to float</p>
</blockquote>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;charconv&gt;
#include &lt;string&gt;

int main() {
    std::string str = "123.456";
    double value;

    auto result = std::from_chars(str.data(), str.data() + str.size(), value, std::chars_format::fixed);
    if (result.ec == std::errc()) {
        std::cout &lt;&lt; "Converted value: " &lt;&lt; value &lt;&lt; std::endl;
    } else {
        std::cerr &lt;&lt; "Conversion failed" &lt;&lt; std::endl;
    }

    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-stdexpected"><a class="header" href="#use-stdexpected">use std::expected</a></h1>
<p>rust has Option<T> and Result&lt;T,E&gt; and c++ decided to create something like them; it's std::expected. You can achieve same thing using std::variant etc ( you can find it's example somewhere in the site).</p>
<p>std::expected; like std::optional, supports some monadic operations and have observers.</p>
<blockquote>
<p>and_then is only usable if the value exists in the result</p>
</blockquote>
<pre><code class="language-c++">
std::expected&lt;int, std::string&gt; parse(const std::string&amp; str) { /* ... */ }
std::expected&lt;int, std::string&gt; validate(int value) { /* ... */ }

auto result = parse("123").and_then(validate);
</code></pre>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;expected&gt;

std::expected&lt;int, std::string&gt; incrementIfPositive(int value) {
    if (value &gt; 0) return value + 1;
    return std::unexpected("Value must be positive");
}

std::expected&lt;int, std::string&gt; getInput(int x) {
    if (x % 2 == 0) return x;
    return std::unexpected("Value not even!");
}

int main() {
    auto input = getInput(2);
    auto result = input.and_then(incrementIfPositive); // chaining another operation to successful return
    if (result) {
        std::cout &lt;&lt; *result &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; result.error() &lt;&lt; std::endl;
    }
    return 0;
}

</code></pre>
<blockquote>
<p>value exists in the result so we can manipulate it using transform</p>
</blockquote>
<pre><code class="language-c++">std::expected&lt;int, std::string&gt; result = /* ... */;
auto doubled = result.transform([](int value) {
    return value * 2;
});

</code></pre>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;expected&gt;

std::expected&lt;int, std::string&gt; doubleValue(int value) {
    return value * 2;
}

int main() {
    std::expected&lt;int, std::string&gt; value = 10;
    auto result = value.transform(doubleValue);
    if (result) {
        std::cout &lt;&lt; *result &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; result.error() &lt;&lt; std::endl;
    }
    return 0;
}
</code></pre>
<blockquote>
<p>if there is an error, use or_else and call a error handler</p>
</blockquote>
<pre><code class="language-c++">std::expected&lt;int, std::string&gt; result = /* ... */;
auto recovered = result.or_else([](const std::string&amp; err) {
    std::cerr &lt;&lt; "Error: " &lt;&lt; err &lt;&lt; std::endl;
    return std::expected&lt;int, std::string&gt;(0); // Provide a default value
});

</code></pre>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;expected&gt;

std::expected&lt;int, std::string&gt; getValue(bool success) {
    if (success) return 42;
    return std::unexpected("Failed to get value");
}

std::expected&lt;int, std::string&gt; handleError(const std::string&amp; error) {
    std::cout &lt;&lt; "Handling error: " &lt;&lt; error &lt;&lt; std::endl;
    return 0; // Default value
}

int main() {
    auto result = getValue(false).or_else(handleError);
    if (result) {
        std::cout &lt;&lt; *result &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; result.error() &lt;&lt; std::endl;
    }
    return 0;
}
</code></pre>
<p>but std::expected has support value, value_or and error like std::optional. it's implicitly convertible to bool.</p>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;expected&gt;
#include &lt;string&gt;

std::expected&lt;int, std::string&gt; parseInt(const std::string&amp; str) {
    try {
        return std::stoi(str);
    } catch (const std::invalid_argument&amp;) {
        return std::unexpected("Invalid argument");
    } catch (const std::out_of_range&amp;) {
        return std::unexpected("Out of range");
    }
}

int main() {
    auto result = parseInt("123");
    if (result) { // check if it's valid
        std::cout &lt;&lt; "Parsed value: " &lt;&lt; *result &lt;&lt; std::endl;
    } else {
        std::cerr &lt;&lt; "Error: " &lt;&lt; result.error() &lt;&lt; std::endl;
    }

    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-ranges-lib-constrained-algorithms"><a class="header" href="#use-ranges-lib-constrained-algorithms">use ranges-lib constrained algorithms</a></h1>
<p>these are called <code>constrained</code> algorithms - naming is same with old std::algorithms but concept is a little bit different.</p>
<ul>
<li>range can be iterator-sentinel pair</li>
<li>range can be range based</li>
</ul>
<p>it supports sentinel, projection and pointer to members.</p>
<p>popular ones...</p>
<h2 id="all_of-any_of-none_of"><a class="header" href="#all_of-any_of-none_of">all_of, any_of, none_of</a></h2>
<p>all elements or some of them or neither of them must be ok with a condition</p>
<pre><code class="language-c++">
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;ranges&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; vec = {2, 4, 6, 8};
    bool all_even =
        std::ranges::all_of(vec, [](auto&amp;&amp; n) { return n % 2 == 0; });
    std::cout &lt;&lt; "All elements are even: " &lt;&lt; std::boolalpha &lt;&lt; all_even
              &lt;&lt; std::endl;

    bool any_even =
        std::ranges::any_of(vec, [](auto&amp;&amp; n) { return n % 2 == 0; });
    std::cout &lt;&lt; "Any element is even: " &lt;&lt; std::boolalpha &lt;&lt; any_even
              &lt;&lt; std::endl;

    bool none_even =
        std::ranges::none_of(vec, [](auto&amp;&amp; n) { return n % 2 == 0; });
    std::cout &lt;&lt; "No elements are even: " &lt;&lt; std::boolalpha &lt;&lt; none_even
              &lt;&lt; std::endl;

    return 0;


</code></pre>
<h2 id="count-count_if"><a class="header" href="#count-count_if">count, count_if</a></h2>
<p>count or count if condition applies and return the count of element</p>
<pre><code class="language-c++">
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;ranges&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; vec = {1, 2, 3, 2, 4, 2};
    auto count_twos = std::ranges::count(vec, 2);
    std::cout &lt;&lt; "Number of twos: " &lt;&lt; count_twos &lt;&lt; std::endl;

    auto count_even =
        std::ranges::count_if(vec, [](auto&amp;&amp; n) { return n % 2 == 0; });
    std::cout &lt;&lt; "Number of even elements: " &lt;&lt; count_even &lt;&lt; std::endl;

    return 0;
}

</code></pre>
<h2 id="replace-replace_if-replace_copy-replace_copy_if"><a class="header" href="#replace-replace_if-replace_copy-replace_copy_if">replace, replace_if, replace_copy, replace_copy_if</a></h2>
<p>update the range's element with new one or after checking a condition. _copy ones will create a new range.</p>
<pre><code class="language-c++">
#include &lt;algorithm&gt;
#include &lt;print&gt;
#include &lt;ranges&gt;
#include &lt;vector&gt;

namespace ranges = std::ranges;
namespace views = std::ranges::views;

struct MyS {
    int value;
    constexpr auto operator&lt;=&gt;(MyS const&amp;) const = default;
    constexpr bool operator==(MyS const&amp;) const = default;
};

int main() {
    {
        std::vector&lt;MyS&gt; data = {{1}, {2}, {3}, {4}, {2}, {5}};

        ranges::replace(data, MyS{2}, MyS{101});

        for (auto&amp; item : data) std::print("{}, ", item.value);
        std::println();
    }

    {
        std::vector&lt;MyS&gt; data = {{1}, {2}, {3}, {4}, {2}, {5}};

        ranges::replace_if(
            data, [](MyS const&amp; ms) { return ms.value == 2; }, MyS{101});

        for (auto&amp; item : data) std::print("{}, ", item.value);
        std::println();
    }

    {
        std::vector&lt;MyS&gt; data = {{1}, {2}, {3}, {4}, {2}, {5}};
        std::vector&lt;MyS&gt; copy_data;

        ranges::replace_copy_if(
            data, std::back_inserter(copy_data),
            [](MyS const&amp; ms) { return ms.value == 2; }, MyS{101});
        for (auto&amp; item : data) std::print("{}, ", item.value);
        std::println();
        for (auto&amp; item : copy_data) std::print("{}, ", item.value);
        std::println();
    }

    return 0;
}

</code></pre>
<h2 id="mismatch"><a class="header" href="#mismatch">mismatch</a></h2>
<p>find the first positions in each range that's a mismatch. returns a type with two iterator types that show the mismatch points in ranges.</p>
<pre><code class="language-c++">#include &lt;algorithm&gt;
#include &lt;print&gt;
#include &lt;ranges&gt;
#include &lt;vector&gt;

namespace ranges = std::ranges;
namespace views = std::ranges::views;

int main() {
    {
        std::vector v1 = {1, 2, 3, 5, 6};
        std::vector v2 = {1, 2, 3, 4};

        auto [it1, it2] = ranges::mismatch(v1, v2);
        std::println("{} != {}", *it1, *it2);
    }

    {
        std::vector v1 = {1, 2, 3};
        std::vector v2 = {1};

        auto [it1, it2] = ranges::mismatch(v1, v2);
        std::println("{} != {}", *it1, *it2);
    }
    {
        // crashes the program
        // std::vector v1 = {1, 2, 3};
        // std::vector&lt;int&gt; v2 = {};

        // auto [it1, it2] = ranges::mismatch(v1, v2);
        // std::println("{} != {}", *it1, *it2);
    }
    {
        std::string name = "abba";
        auto&amp;&amp; rev = name | views::reverse;

        auto [it1, it2] = ranges::mismatch(name, rev);
        if (it1 == name.end() &amp;&amp; it2 == rev.end()) std::println("same");
    }
}

</code></pre>
<h2 id="equal"><a class="header" href="#equal">equal</a></h2>
<p>compare if both ranges are equal...many containers have already implemented <code>operator==</code> so they compare items which must have implemented them. so you can cmp: vector, array, string... but if your range doesn't have it you can use this.</p>
<pre><code class="language-c++">#include &lt;algorithm&gt;
#include &lt;print&gt;
#include &lt;vector&gt;

namespace ranges = std::ranges;

int main() {
    std::vector v1 = {1, 2, 3};
    std::vector v2 = {1, 2, 3};
    std::vector v3 = {2, 3, 4};

    std::println("{}", v1 == v2);

    if (ranges::equal(v1, v2)) std::println("v1 == v2");

    if (ranges::equal(v1, v3)) std::println("v1 == v3");
}
</code></pre>
<h2 id="lexicographical_compare"><a class="header" href="#lexicographical_compare">lexicographical_compare</a></h2>
<p>you can compare 2 ranges - vector, string, array...</p>
<p>possible results:</p>
<ul>
<li>true: &lt;</li>
<li>false: &gt;=</li>
</ul>
<pre><code class="language-c++">#include &lt;algorithm&gt;  // ranges::algo
#include &lt;print&gt;
#include &lt;ranges&gt;  // ranges::range
#include &lt;vector&gt;
#include &lt;string&gt;

namespace ranges = std::ranges;
namespace views = std::ranges::views;

int main() {
    std::string s1 = "hakan";
    std::string s2 = "hasan";
    std::string s3 = "hakan";

    auto res = ranges::lexicographical_compare(s1, s2);
    if (res)
        std::println("{} &lt; {}", s1, s2);
    else
        std::println("{} &gt;= {}", s1, s2);

    res = ranges::lexicographical_compare(s1, s3);
    if (res)
        std::println("{} &lt; {}", s1, s3);
    else
        std::println("{} &gt;= {}", s1, s3);

    return 0;
}
</code></pre>
<h2 id="find-find_if-find_if_not"><a class="header" href="#find-find_if-find_if_not">find, find_if, find_if_not</a></h2>
<p>find or find if condition applies or doesn't applies. find_if_not will return first item that doesn't support the given functor's condition.</p>
<pre><code class="language-c++">
#include &lt;algorithm&gt;  // ranges::algo
#include &lt;print&gt;
#include &lt;ranges&gt;  // ranges::range
#include &lt;vector&gt;

namespace ranges = std::ranges;
namespace views = std::ranges::views;


int main() {
    std::vector&lt;int&gt; data = {1, 2, 3, 4, 5, 6};
    {
        if (auto it = ranges::find(data, 3); it != data.end())
            std::println("{} exists", *it);
    }
    {
        if (auto it = ranges::find_if(data, [](int x) { return x % 3 == 0; });
            it != data.end()) {
            std::println("{} % 3 == 0 exists", *it);
        }
    }
    {
        if (auto it =
                ranges::find_if_not(data, [](int x) { return x % 3 == 0; });
            it != data.end()) {
            std::println("{} % 3 != 0 exists", *it);
        }
    }

    return 0;
}
</code></pre>
<h2 id="copy-copy_if"><a class="header" href="#copy-copy_if">copy, copy_if</a></h2>
<p>copy or copy if condition applies. copy constructs are used if src type has it.</p>
<pre><code class="language-c++">#include &lt;algorithm&gt;  // ranges::algo
#include &lt;cstring&gt;
#include &lt;functional&gt;
#include &lt;print&gt;
#include &lt;ranges&gt;  // ranges::range
#include &lt;vector&gt;

namespace ranges = std::ranges;
namespace views = std::ranges::views;

struct MyS {
    MyS(std::string&amp;&amp; n) : data(std::move(n)) {}
    MyS(const MyS&amp; other) : data(other.data) {
        std::println("MyS const&amp; called");
    }
    MyS(MyS&amp;&amp; other) : data(std::move(other.data)) {
        std::println("MyS&amp;&amp; called");
    }
    std::string data;
};

int main() {
    std::vector&lt;MyS&gt; src;
    src.emplace_back("hakan");
    src.emplace_back("gedek");
    src.emplace_back("swe");
    std::println();

    std::vector&lt;MyS&gt; dst;

    ranges::copy(src, std::back_inserter(dst));
    for (auto&amp; ms : dst) std::print("{}, ", ms.data);
    std::println();

    std::vector&lt;int&gt; data{1, 2, 3, 4, 5, 6};
    std::vector&lt;int&gt; selected;

    ranges::copy_if(data, std::back_inserter(selected),
                    std::bind_back(std::greater&lt;int&gt;{}, 4));
    for (auto item : selected) std::print("{}, ", item);

    return 0;
}
</code></pre>
<h2 id="move"><a class="header" href="#move">move</a></h2>
<p>instead of copying; move the elements from one to other. move constructor is used if the src type has it. also delete copy constructors - at the end c++ loves copying - block it.</p>
<pre><code class="language-c++">#include &lt;algorithm&gt;  // ranges::algo
#include &lt;array&gt;
#include &lt;cassert&gt;
#include &lt;cstring&gt;
#include &lt;functional&gt;
#include &lt;print&gt;
#include &lt;random&gt;
#include &lt;ranges&gt;  // ranges::range
#include &lt;vector&gt;

namespace ranges = std::ranges;
namespace views = std::ranges::views;

struct MyS {
    MyS() = default;
    MyS(std::string&amp;&amp; n) : data(std::move(n)) {}
    MyS(MyS&amp;&amp; other) {
        std::println("MyS&amp;&amp; called");
        data = std::move(other.data);
    }
    std::string data;
};

int main() {
    std::vector&lt;std::string&gt; strs = {"hakan", "gedek", "coventry"};
    std::vector&lt;std::string&gt; new_owner;

    ranges::move(strs, std::back_inserter(new_owner));
    for (auto&amp; elem : strs) std::print("{}, ", elem);
    std::println();

    assert(strs.size() != 0);  // str data gone but "" stays

    std::vector&lt;MyS&gt; ms_old;
    ms_old.emplace_back("hakan");
    ms_old.emplace_back("gedek");

    std::println();
    std::vector&lt;MyS&gt; ms_new;
    ranges::move(ms_old, std::back_inserter(ms_new));

    for (auto&amp; old : ms_old) std::print("{}, ", old.data);
    std::println();
    for (auto&amp; nw : ms_new) std::print("{}, ", nw.data);
    std::println();

    return 0;
}
</code></pre>
<h2 id="fill-fill_n"><a class="header" href="#fill-fill_n">fill, fill_n</a></h2>
<p>fill the range with a value. fill does same job what memset does.</p>
<pre><code class="language-c++">
#include &lt;algorithm&gt;  // ranges::algo
#include &lt;array&gt;
#include &lt;cassert&gt;
#include &lt;cstring&gt;
#include &lt;functional&gt;
#include &lt;print&gt;
#include &lt;random&gt;
#include &lt;ranges&gt;  // ranges::range
#include &lt;vector&gt;

namespace ranges = std::ranges;
namespace views = std::ranges::views;

int main() {
    {
        std::vector&lt;int&gt; data(10);
        ranges::fill(data, -1);

        for (auto elem : data) std::print("{}, ", elem);
        std::println();

        // memset vs fill
        char name[20];
        memset(name, 'a', sizeof name);
        for (auto elem : name) std::print("{}, ", elem);
        std::println();
        // or
        ranges::fill(name, 'b');
        for (auto elem : name) std::print("{}, ", elem);
        std::println();
    }
    {
        std::vector&lt;int&gt; data(10);
        ranges::fill_n(data.begin(), 5, 101);

        for (auto elem : data) std::print("{}, ", elem);
        std::println();
    }

    return 0;

}

</code></pre>
<h2 id="generate-generate_n"><a class="header" href="#generate-generate_n">generate, generate_n</a></h2>
<p>create a range with items created by a generator you have. generate_n will take iterator as first elem.</p>
<pre><code class="language-c++">
#include &lt;algorithm&gt;  // ranges::algo
#include &lt;array&gt;
#include &lt;cassert&gt;
#include &lt;functional&gt;
#include &lt;print&gt;
#include &lt;random&gt;
#include &lt;ranges&gt;  // ranges::range
#include &lt;vector&gt;

namespace ranges = std::ranges;
namespace views = std::ranges::views;

int main() {
    std::random_device rnd;
    std::mt19937 gen{rnd()};
    std::uniform_int_distribution dis(1, 10);

    {
        std::vector&lt;int&gt; data(10);

        ranges::generate(data, [&amp;dis, &amp;gen] { return dis(gen); });

        for (auto elem : data) std::print("{},", elem);

        std::println();
    }

    {
        std::vector&lt;int&gt; data(10);

        ranges::generate_n(data.begin(), 5, [&amp;dis, &amp;gen] { return dis(gen); });

        for (auto elem : data) std::print("{},", elem);
        std::println();
    }

    return 0;
}
</code></pre>
<h2 id="transform"><a class="header" href="#transform">transform</a></h2>
<p>this is called map in other languages. create a changed range.</p>
<pre><code class="language-c++">
#include &lt;algorithm&gt;  // ranges::algo
#include &lt;array&gt;
#include &lt;cassert&gt;
#include &lt;functional&gt;
#include &lt;print&gt;
#include &lt;random&gt;
#include &lt;ranges&gt;  // ranges::range
#include &lt;vector&gt;

namespace ranges = std::ranges;
namespace views = std::ranges::views;

int main() {
    auto data = std::to_array&lt;int&gt;({1, 2, 3, 4, 5, 6});

    ranges::transform(data, data.begin(), std::negate&lt;&gt;{});
    ranges::transform(data, data.begin(),
                      std::bind_front(std::multiplies&lt;int&gt;{}, 10));

    for (auto item : data) std::print("{}, ", item);

    return 0;
}

</code></pre>
<h2 id="remove-remove_if-remove_copy-remove_copy_if"><a class="header" href="#remove-remove_if-remove_copy-remove_copy_if">remove, remove_if, remove_copy, remove_copy_if</a></h2>
<p>remove and remove if condition applies..._copy ones don't update the range but create a new copy...</p>
<p>remove doesn't erase the data but changes the locations of them to end of the container. you may need to call erase after it. (remove - erase idiom)</p>
<pre><code class="language-c++">#include &lt;algorithm&gt;  // ranges::algo
#include &lt;array&gt;
#include &lt;cassert&gt;
#include &lt;functional&gt;
#include &lt;print&gt;
#include &lt;random&gt;
#include &lt;ranges&gt;  // ranges::range
#include &lt;vector&gt;

namespace ranges = std::ranges;
namespace views = std::ranges::views;

int main() {
    {
        std::vector data = {1, 2, 3, 4, 5, 5, 5, 6, 7};

        ranges::for_each(data, [](auto elem) { std::print("{}, ", elem); });
        std::println();
        // deleted sub-range
        auto sub_range = ranges::remove(data, 5);

        data.erase(sub_range.begin(), sub_range.end());

        ranges::for_each(data, [](auto elem) { std::print("{}, ", elem); });
        std::println();
        std::println();
    }
    {
        std::vector data = {1, 2, 3, 4, 5, 5, 5, 6, 7};

        ranges::for_each(data, [](auto elem) { std::print("{}, ", elem); });
        std::println();

        auto sub_range = ranges::remove_if(
            data, std::bind(std::greater_equal&lt;&gt;{}, std::placeholders::_1, 5));

        data.erase(sub_range.begin(), sub_range.end());

        ranges::for_each(data, [](auto elem) { std::print("{}, ", elem); });
        std::println();
        std::println();
    }
    {
        const std::vector data = {1, 2, 3, 4, 5, 5, 5, 6, 7};

        std::vector&lt;int&gt; copy_data;
        copy_data.reserve(data.size());

        ranges::remove_copy(data, std::back_inserter(copy_data), 5);
        ranges::for_each(data, [](auto elem) { std::print("{}, ", elem); });
        std::println();
        ranges::for_each(copy_data,
                         [](auto elem) { std::print("{}, ", elem); });
        std::println();
        std::println();
    }
    {
        const std::vector data = {1, 2, 3, 4, 5, 5, 5, 6, 7};

        std::vector&lt;int&gt; copy_data;
        copy_data.reserve(data.size());

        ranges::remove_copy_if(data, std::back_inserter(copy_data),
                               std::bind_back(std::greater_equal&lt;int&gt;{}, 5));
        ranges::for_each(data, [](auto elem) { std::print("{}, ", elem); });
        std::println();

        ranges::for_each(copy_data,
                         [](auto elem) { std::print("{}, ", elem); });
        std::println();
    }

    return 0;
}

</code></pre>
<h2 id="unique-unique_copy"><a class="header" href="#unique-unique_copy">unique, unique_copy</a></h2>
<p>remove consecutive duplications so you need a sorted range. _copy will create a copy of new range.</p>
<pre><code class="language-c++">#include &lt;algorithm&gt;  // ranges::algo
#include &lt;array&gt;
#include &lt;print&gt;
#include &lt;random&gt;
#include &lt;ranges&gt;  // ranges::range
#include &lt;vector&gt;

namespace ranges = std::ranges;
namespace views = std::ranges::views;

int main() {
    {
        // sorted
        std::vector data = {1, 2, 2, 3, 3, 3, 4, 5, 5};
        auto it = ranges::unique(data);
        data.erase(it.begin(), it.end());
        ranges::for_each(data, [](auto elem) { std::print("{},", elem); });
        std::println();
    }
    {
        std::vector&lt;int&gt; output;

        // sorted and immutable
        constexpr auto data = std::to_array&lt;int&gt;({1, 2, 2, 3, 3, 3, 4, 5, 5});
        // reserve to speed
        output.reserve(data.size());

        ranges::unique_copy(data, std::back_inserter(output));
        ranges::for_each(data, [](auto elem) { std::print("{},", elem); });
        std::println();
        ranges::for_each(output, [](auto elem) { std::print("{},", elem); });
    }

    return 0;
}

</code></pre>
<h2 id="sort-stable_sort"><a class="header" href="#sort-stable_sort">sort, stable_sort</a></h2>
<p>sort all the range. if you want to keep sorted elements to keep their old position then use this ( placement is important)</p>
<pre><code class="language-c++">
#include &lt;algorithm&gt;  // ranges::algo
#include &lt;array&gt;
#include &lt;print&gt;
#include &lt;random&gt;
#include &lt;ranges&gt;  // ranges::range

namespace ranges = std::ranges;
namespace views = std::ranges::views;

int main() {
    auto data = std::to_array&lt;int&gt;({5, 3, 8, 1, 9, 2, 7, 6, 4, 0, 2, 10});
    {
        ranges::sort(data);
        ranges::for_each(data, [](auto val) { std::print("{},", val); });
        std::println();
    }

    return 0;


</code></pre>
<h2 id="partial_sort"><a class="header" href="#partial_sort">partial_sort</a></h2>
<p>partially sort the subrange - don't care about full range.</p>
<pre><code class="language-c++">#include &lt;algorithm&gt;  // ranges::algo
#include &lt;array&gt;
#include &lt;print&gt;
#include &lt;random&gt;
#include &lt;ranges&gt;  // ranges::range

namespace ranges = std::ranges;
namespace views = std::ranges::views;

int main() {
    auto data = std::to_array&lt;int&gt;({5, 3, 8, 1, 9, 2, 7, 6, 4, 0, 2, 10});
    {
        ranges::partial_sort(data, data.begin() + 4);
        ranges::for_each(data, [](auto val) { std::print("{},", val); });
        std::println();
    }
    {
        ranges::sort(data);
        ranges::for_each(data, [](auto val) { std::print("{},", val); });
        std::println();
    }

    return 0;
}
</code></pre>
<h2 id="nth_element"><a class="header" href="#nth_element">nth_element</a></h2>
<p>only care nth element which is at the correct position as sorted. items before and after are not sorted.</p>
<pre><code class="language-c++">#include &lt;algorithm&gt;  // ranges::algo
#include &lt;array&gt;
#include &lt;print&gt;
#include &lt;random&gt;
#include &lt;ranges&gt;  // ranges::range
#include &lt;vector&gt;

namespace ranges = std::ranges;
namespace views = std::ranges::views;

int main() {
    auto data = std::to_array&lt;int&gt;({3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5});
    constexpr auto index = 5;
    // looking for 5th element in sorted array but without sorting all

    // Q: what's the 5th smallest element in the order ?

    {
        // nth
        ranges::nth_element(data, data.begin() + index);
        std::println("{}th element: {}", index, data[index]);
        ranges::for_each(data, [](auto val) { std::print("{},", val); });
        std::println();
    }
    {
        // full-sort
        ranges::sort(data);
        std::println("{}th element: {}", index, data[index]);
        ranges::for_each(data, [](auto val) { std::print("{},", val); });
        std::println();
    }

    return 0;
}

Program stdout
5th element: 4
3,1,2,1,3,4,5,5,6,9,5,
5th element: 4
1,1,2,3,3,4,5,5,5,6,9,
</code></pre>
<h2 id="equal_range-lower_bound-upper_bound"><a class="header" href="#equal_range-lower_bound-upper_bound">equal_range, lower_bound, upper_bound</a></h2>
<p>if there are duplicated elements in a range; you can get start-end pos of them like a sub-range. -valid only for <strong>sorted</strong> ranges</p>
<p>you can use lower_bound and upper_bound :</p>
<ul>
<li>to create a subrange (ranges::subrange or yourself)
<ul>
<li>to find if item exists in the range</li>
<li>if not exists you get either a different element position for lower bound or end of the range - control it before using</li>
</ul>
</li>
</ul>
<pre><code class="language-c++">#include &lt;algorithm&gt;  // ranges::algo
#include &lt;array&gt;
#include &lt;print&gt;
#include &lt;ranges&gt;  // ranges::range

namespace ranges = std::ranges;
namespace views = std::ranges::views;

int main() {
   const auto data =
       std::to_array&lt;int&gt;({1, 2, 3, 4, 5, 5, 5, 5, 6, 7, 8, 9, 10});

   auto sub_range = ranges::equal_range(data, 5);

   ranges::for_each(sub_range, [](auto val) { std::print("{},", val); });

   std::println();
   std::println("count of 5: {}", sub_range.size());

   auto lb = ranges::lower_bound(data, 5);
   auto ub = ranges::upper_bound(data, 5);

   ranges::subrange sub_range2(lb, ub);

   ranges::for_each(sub_range, [](auto val) { std::print("{},", val); });

   std::println();
   std::println("count of 5: {}", sub_range2.size());

   return 0;
}

</code></pre>
<h2 id="merge"><a class="header" href="#merge">merge</a></h2>
<p>merge two sorted ranges . if it's not sorted it tries to keep the sort between ranges.</p>
<pre><code class="language-c++">#include &lt;algorithm&gt;  // ranges::algo
#include &lt;array&gt;
#include &lt;cassert&gt;
#include &lt;print&gt;
#include &lt;random&gt;
#include &lt;ranges&gt;  // ranges::range
#include &lt;vector&gt;

namespace ranges = std::ranges;
namespace views = std::ranges::views;

int main() {
    constexpr auto LENGTH = 20;

    std::array&lt;int, LENGTH / 2&gt; r1;
    std::array&lt;int, LENGTH / 2&gt; r2;

    // preparation
    std::random_device rnd;
    std::mt19937 gen(rnd());

    std::uniform_int_distribution&lt;&gt; dis(1, LENGTH * 2);

    for (auto i = 0; i &lt; LENGTH / 2; ++i) r1[i] = dis(gen);
    for (auto i = 0; i &lt; LENGTH / 2; ++i) r2[i] = dis(gen);

    std::array&lt;int, LENGTH&gt; result;

    ranges::merge(r1, r2, ranges::begin(result));

    ranges::for_each(r1, [](auto value) { std::print("{}, ", value); });
    std::println();
    ranges::for_each(r2, [](auto value) { std::print("{}, ", value); });
    std::println();
    ranges::for_each(result, [](auto value) { std::print("{}, ", value); });
    std::println();

    ranges::sort(r1);
    ranges::sort(r2);

    ranges::merge(r1, r2, ranges::begin(result));

    ranges::for_each(r1, [](auto value) { std::print("{}, ", value); });
    std::println();
    ranges::for_each(r2, [](auto value) { std::print("{}, ", value); });
    std::println();
    ranges::for_each(result, [](auto value) { std::print("{}, ", value); });

    return 0;

</code></pre>
<h2 id="max-min-minmax-max_element-min_element-minmax_element"><a class="header" href="#max-min-minmax-max_element-min_element-minmax_element">max, min, minmax, max_element, min_element, minmax_element</a></h2>
<p>search for min, max or both... if you need positions in the range use _element ones</p>
<pre><code class="language-c++">
#include &lt;algorithm&gt;  // ranges::algo
#include &lt;array&gt;
#include &lt;cassert&gt;
#include &lt;print&gt;
#include &lt;random&gt;
#include &lt;ranges&gt;  // ranges::range
#include &lt;vector&gt;

namespace ranges = std::ranges;
namespace views = std::ranges::views;

int main() {
    constexpr auto LENGTH = 50;
    std::array&lt;int, LENGTH&gt; data;

    // preparation
    std::random_device rnd;
    std::mt19937 gen(rnd());
    std::uniform_int_distribution&lt;&gt; dis(1, LENGTH);

    for (auto i = 0; i &lt; LENGTH; ++i) data[i] = dis(gen);
    std::println("data:");
    ranges::for_each(data, [](auto value) { std::print("{}, ", value); });
    std::println();

    std::println("min: {}", ranges::min(data));
    std::println("max: {}", ranges::max(data));

    auto p = ranges::minmax(data);
    std::println("min: {}, max: {}", p.min, p.max);

    auto min_it = ranges::min_element(data);
    auto max_it = ranges::max_element(data);
    auto mm_it = ranges::minmax_element(data);

    std::println("min: {} pos: {}", *min_it,
                 std::distance(ranges::begin(data), min_it));
    std::println("max: {} pos: {}", *max_it,
                 std::distance(ranges::begin(data), max_it));
    std::println("min: {} pos: {}, max: {} pos: {}", *(mm_it.min),
                 std::distance(ranges::begin(data), mm_it.min), *(mm_it.max),
                 std::distance(ranges::begin(data), mm_it.max));

    return 0;

}

</code></pre>
<h2 id="iota"><a class="header" href="#iota">iota</a></h2>
<p>fill the range with incrementing values</p>
<pre><code class="language-c++">#include &lt;algorithm&gt;  // ranges::algo
#include &lt;array&gt;
#include &lt;cassert&gt;
#include &lt;print&gt;
#include &lt;random&gt;
#include &lt;ranges&gt;  // ranges::range
#include &lt;vector&gt;

namespace ranges = std::ranges;
namespace views = std::ranges::views;

int main() {
    std::array&lt;int, 100&gt; data;

    ranges::iota(data, 0);

    ranges::for_each(data, [](auto val) {
        std::println("{}", val);
    });

    return 0;

</code></pre>
<h2 id="clamp"><a class="header" href="#clamp">clamp</a></h2>
<p>fix the value into a boundary</p>
<pre><code class="language-c++">#include &lt;algorithm&gt;  // ranges::algo
#include &lt;array&gt;
#include &lt;cassert&gt;
#include &lt;print&gt;
#include &lt;random&gt;
#include &lt;ranges&gt;  // ranges::range
#include &lt;vector&gt;

namespace ranges = std::ranges;
namespace views = std::ranges::views;

int main() {
    std::random_device rnd;
    std::mt19937 gen(rnd());
    std::uniform_int_distribution&lt;&gt; dis{1, 50};  // provides data

    while (true) {
        static int i = 0;

        auto value = dis(gen);
        auto clamped_value = ranges::clamp(value, 10, 20);
        std::println("original: {} clamped_value: {}", value, clamped_value);
        i++;

        if (i &gt; 10) break;
    }

    return 0;
}
</code></pre>
<h2 id="set-operations-includes-difference-intersection-union"><a class="header" href="#set-operations-includes-difference-intersection-union">set operations: includes, difference, intersection, union</a></h2>
<p>may help with comparisons of two ranges if they are part of each other or you can create a union of ranges</p>
<pre><code class="language-c++">#include &lt;algorithm&gt;  // ranges::algo
#include &lt;array&gt;
#include &lt;cassert&gt;
#include &lt;print&gt;
#include &lt;random&gt;
#include &lt;ranges&gt;  // ranges::range
#include &lt;vector&gt;

namespace ranges = std::ranges;
namespace views = std::ranges::views;

void print(auto&amp;&amp; r) {
    std::print(" [");
    ranges::for_each(r, [](auto val) { std::print("{},", val); });
    std::print("] ");
}

void includes_test(auto&amp;&amp; r1, auto&amp;&amp; r2) {  // use new generic usecase of auto&amp;&amp;
    print(r1);
    std::print("includes");
    print(r2);
    auto result = ranges::includes(r1, r2);
    std::print("{}", result);
    std::println();
}

void difference_test(auto&amp;&amp; r1, auto&amp;&amp; r2) {
    print(r1);
    std::print("different");
    print(r2);
    std::vector&lt;int&gt; r3;
    auto [lhs, rhs] = ranges::set_difference(r1, r2, std::back_inserter(r3));
    assert(lhs == r1.end());

    print(r3);
    std::println();
    // if you've a large r3; you can remove empty items by r3.erase(rhs,
    // r3.end());
}

void intersection_test(auto&amp;&amp; r1, auto&amp;&amp; r2) {
    print(r1);
    std::print("intersect");
    print(r2);
    std::vector&lt;int&gt; r3;
    auto [lhs, mhs, rhs] =
        ranges::set_intersection(r1, r2, std::back_inserter(r3));
    assert(lhs == r1.end());
    assert(mhs == r2.end());

    print(r3);
    std::println();
}

void union_test(auto&amp;&amp; r1, auto&amp;&amp; r2) {
    print(r1);
    std::print("union");
    print(r2);
    std::vector&lt;int&gt; r3;
    auto [lhs, mhs, rhs] = ranges::set_union(r1, r2, std::back_inserter(r3));
    assert(lhs == r1.end());
    assert(mhs == r2.end());

    print(r3);
    std::println();
}

int main() {
    auto range1 = std::to_array({1, 2, 3, 4, 5});
    auto key1 = std::to_array({2, 3});
    auto key2 = std::to_array({3, 2});
    auto key3 = std::to_array({2, 4});
    auto range2 = std::to_array({6, 7, 8, 9});

    {
        includes_test(range1, key1);
        difference_test(range1, key1);
        intersection_test(range1, key1);
        union_test(range1, key1);
        std::println();
    }
    {
        includes_test(range1, key2);
        difference_test(range1, key2);
        intersection_test(range1, key2);
        union_test(range1, key2);
        std::println();
    }
    {
        includes_test(range1, key3);
        difference_test(range1, key3);
        intersection_test(range1, key3);
        union_test(range1, key3);
        std::println();
    }
    {
        includes_test(range1, range2);
        difference_test(range1, range2);
        intersection_test(range1, range2);
        union_test(range1, range2);
        std::println();
    }

    return 0;

</code></pre>
<h2 id="shuffle"><a class="header" href="#shuffle">shuffle</a></h2>
<p>randomize the range - randomly replace items in a range</p>
<pre><code class="language-c++">#include &lt;algorithm&gt;  // ranges::algo
#include &lt;array&gt;
#include &lt;print&gt;
#include &lt;random&gt;
#include &lt;ranges&gt;  // ranges::range

namespace ranges = std::ranges;
namespace views = std::ranges::views;

int main() {
    auto arr = std::to_array({1, 2, 3, 4, 5, 6, 7, 8, 9});

    std::random_device rnd;
    std::mt19937 gen(rnd());

    ranges::shuffle(arr, gen);

    ranges::for_each(arr, [](auto val) { std::print("{} ", val); });

    std::println();

    return 0;
}
</code></pre>
<h2 id="sample"><a class="header" href="#sample">sample</a></h2>
<p>select random elements from a sequence</p>
<p>format: <code>(in_range, out_range, count, generator)</code></p>
<pre><code class="language-c++">#include &lt;algorithm&gt;  // ranges::algo
#include &lt;array&gt;
#include &lt;print&gt;
#include &lt;random&gt;
#include &lt;ranges&gt;  // ranges::range

namespace ranges = std::ranges;
namespace views = std::ranges::views;

int main() {
    constexpr auto arr = std::to_array({1, 2, 3, 4, 5, 6, 7, 8, 9});
    constexpr auto len = 4;

    std::random_device rnd;
    std::mt19937 gen(rnd());

    std::array&lt;int, len&gt; out;

    ranges::sample(arr, out.begin(), len, gen);

    ranges::for_each(out, [](int val) { std::print("{} ", val); });
    std::println();

    return 0;
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-monadic-operations-with-optional"><a class="header" href="#use-monadic-operations-with-optional">use monadic operations with optional</a></h1>
<p>std::optional is a unique type in c++. it's size minimum sizeof(T) + sizeof(bool). it's a stack type not heap - so this works.</p>
<pre><code class="language-c++">
#include &lt;optional&gt;
#include &lt;print&gt;

int main() {
    constexpr std::optional&lt;int&gt; opt = 4;

    static_assert(opt == 4);

    return 0;
}

</code></pre>
<p>implicitly convertible_to and _from it's T type and can be converted_to bool so you can check it as <code>if (opt)</code>... has_value, value, value_or(default)... are it's methods... but monadics are better.</p>
<pre><code class="language-c++">
#include &lt;optional&gt;
#include &lt;print&gt;

std::optional&lt;int&gt; square(int x) { return x * x; }

std::optional&lt;int&gt; divide(int a, int b) {
    if (b == 0) return std::nullopt;
    return a / b;
}

int main() {
    std::optional o1 = 10;

    auto squared = o1.transform(square);

    std::optional&lt;int&gt; empty;
    auto squred_empty = empty.transform(square);

    auto result =
        o1.and_then([](int x) { return divide(x, 2); }).and_then(square);

    std::println("{}", result.value());

    std::optional&lt;std::string&gt; empty_str;
    auto default_str = empty_str.value_or("hakan gedek");

    std::println("{}", default_str);

    auto another_str = empty_str.or_else(
        [] { return std::optional&lt;std::string&gt;{"alternative"}; });

    std::println("{}", another_str.value_or("none"));

    std::optional&lt;std::string&gt; value = "12";
    auto processed = value
                         .and_then([](std::string const&amp; str) {
                             try {
                                 return std::optional&lt;int&gt;{std::stoi(str)};
                             } catch (...) {
                                 return std::optional&lt;int&gt;{std::nullopt};
                             }
                         })
                         .transform(square)
                         .value_or(-1);

    return 0;
}

</code></pre>
<blockquote>
<p>nullopt is a nullopt_t element; it's not a std::optional</p>
</blockquote>
<blockquote>
<p>all monadics return std::optional</p>
</blockquote>
<pre><code class="language-c++">
#include &lt;optional&gt;
#include &lt;print&gt;

int main() {
    {
        std::optional&lt;int&gt; value = 101;

        std::optional&lt;int&gt; ret =
            value
                .or_else([]() -&gt; std::optional&lt;int&gt; { return -1; }) // pass -&gt; 101
                .and_then(
                    [](auto&amp;&amp; elem) -&gt; std::optional&lt;int&gt; { return elem * 2; }) // 101 * 2 =&gt; 202
                .transform([](auto&amp;&amp; elem) { return elem * 10; }) // 202 =&gt; 2020
                .transform([](auto&amp;&amp; elem) { return elem * -1; }) // 2020 =&gt; -2020
                .value_or(-1); // pass =&gt; -2020
        std::println("{}", ret.value());
    }
    {

        std::optional&lt;int&gt; value = std::nullopt;

        std::optional&lt;int&gt; ret =
            value
                .and_then(
                    [](auto&amp;&amp; elem) -&gt; std::optional&lt;int&gt; { return elem * 2; })
                .transform([](auto&amp;&amp; elem) { return elem * 10; }) // only for and_then
                .transform([](auto&amp;&amp; elem) { return elem * -1; }) // only for and_then
                .or_else([]() -&gt; std::optional&lt;int&gt; { return -1; }) // -1
                .value_or(-1); // -1
        std::println("{}", ret.value()); // prints -1
    }



    return 0;
}

</code></pre>
<p>all methods must return optional and we can use trailing RT to call optional ctors.</p>
<blockquote>
<p>if you put or_else and and_then before transform; one of them will work and then transform comes so order of the monadics is important.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-advanced-template-solutions"><a class="header" href="#use-advanced-template-solutions">use advanced template solutions</a></h1>
<blockquote>
<p>removing pointer from a type</p>
</blockquote>
<pre><code class="language-c++">template &lt;typename T, typename Stream = std::ostream&gt;
struct is_streamable {
private:
    template &lt;typename U&gt;
    static auto test(int) -&gt; decltype(std::declval&lt;Stream&gt;() &lt;&lt; std::declval&lt;U&gt;(), std::true_type);

    template &lt;typename&gt;
    static auto test(...) -&gt; std::false_type;
public:
    static constexpr auto value = decltype(test&lt;T&gt;(0))::value;
};

</code></pre>
<blockquote>
<p>checking if a type has a method with sfinae technique</p>
</blockquote>
<p>this is easily re-written with concepts</p>
<pre><code class="language-c++">

template &lt;typename T&gt;
struct has_method {
private:
    template &lt;typename U&gt;
    static auto test(int) -&gt; decltype(declval&lt;U&gt;().method(), std::true_type());

    template &lt;typename&gt;
    static auto test(...) -&gt; std::false_type;
public:
    static constexpr auto value = decltype(test&lt;T&gt;(0))::value;
};

// or

template &lt;typename T, typename = void&gt;
struct has_method: std::false_type{};

template &lt;typename T&gt;
struct has_method&lt;T, std::void_t&lt; decltype(std::declval&lt;T&gt;().method())&gt;&gt;: std::true_type{};

</code></pre>
<blockquote>
<p>has common type</p>
</blockquote>
<pre><code class="language-c++">
template &lt;typename T, typename U&gt;
struct has_common_type {
    static constexpr auto value =
        std::is_same_v&lt;decltype(std::declval&lt;T&gt;() + std::declval&lt;U&gt;()), T&gt; ||
        std::is_same_v&lt;decltype(std::declval&lt;T&gt;() + std::declval&lt;U&gt;()), U&gt;
};
</code></pre>
<blockquote>
<p>trailing return types</p>
</blockquote>
<pre><code class="language-c++">
template &lt;typename T, typename U&gt;
auto add(T t, U u) -&gt; decltype(std::declval&lt;T&gt;() + std::declval&lt;U&gt;()) {
    return t + u;
}

</code></pre>
<blockquote>
<p>checking if a type iterable</p>
</blockquote>
<p>this is easily re-written with concepts</p>
<pre><code class="language-c++">
template &lt;typename T&gt;
struct is_iterable {
private:
    template &lt;typename U&gt;
    static auto test(int) -&gt; decltype(std::begin(std::declval&lt;T&amp;&gt;()) != std::end(std::declval&lt;T&amp;&gt;())), std::true_type());

    template &lt;typename&gt;
    static auto test(...) -&gt; std::false_type;
public:
    static constexpr bool value = decltype(test&lt;T&gt;(0))::value;
};

</code></pre>
<blockquote>
<p>compile time function composition</p>
</blockquote>
<pre><code class="language-c++">
template &lt;typename F, typename G&gt;
struct compose {
private:
    F f;
    G g;

public:
    compose(F f, G g): f(f), g(g) {}

    template &lt;typename...Args&gt;
    auto operator()(Args&amp;&amp;...args) -&gt; decltype(f(g(std::forward&lt;Args&gt;(args)...))) {
        return f(g(std::forward&lt;Args&gt;(args)...));
    }
}

</code></pre>
<blockquote>
<p>detecting if a type is callable</p>
</blockquote>
<pre><code class="language-c++">
template &lt;typename F, typename...Args&gt;
struct is_callable {
private:
    template &lt;typename U&gt;
    static auto test(int) -&gt; decltype(std::declval&lt;U&gt;()(std::declval&lt;Args&gt;()...), std::true_type());

    template &lt;typename U&gt;
    static auto test(...) -&gt; std::false_type;
public:
    static constexpr bool value = decltype(test&lt;T&gt;(0))::value;
};

</code></pre>
<blockquote>
<p>transform tuple: applying projection to each tuple value and creating a new tuple</p>
</blockquote>
<pre><code class="language-c++">
template &lt;typename Tuple, typename F, size_t...Is&gt;
auto transform_tuple_impl(Tuple&amp;&amp; t, F&amp;&amp; f, std::index_sequence&lt;Is...&gt;) {
    return std::make_tuple(
        f(std::get&lt;Is&gt;(std::forward&lt;Tuple&gt;(t))...
    );
}

template &lt;typename Tuple, typename F&gt;
auto transform_tuple(Tuple&amp;&amp; t, F&amp;&amp; f) {
    constexpr size_t N = std::tuple_size_v&lt;std::remove_reference_t&lt;Tuple&gt;&gt;; // template typenames can hold references to support universal reference
    return transform_tuple_impl(
        std::forward&lt;Tuple&gt;(t),
        std::forward&lt;F&gt;(f),
        std::make_index_sequence&lt;N&gt;{}
    );
}


// this is modern approach using std::apply
template&lt;typename Tuple, typename Func&gt;
constexpr auto transformTuple(Tuple&amp;&amp; tuple, Func&amp;&amp; func) {
    return std::apply([&amp;func](auto&amp;&amp;... args) {
        return std::make_tuple(func(std::forward&lt;decltype(args)&gt;(args))...);
    }, std::forward&lt;Tuple&gt;(tuple));
}

</code></pre>
<blockquote>
<p>checking if type is addable</p>
</blockquote>
<p>again, concepts can solve this easily</p>
<pre><code class="language-c++">
template &lt;typename T, typename U&gt;
struct has_addition {
private:
    template &lt;typename A, typename B&gt;
    static auto test(int) -&gt; decltype(std::declval&lt;A&gt;() + std::declval&lt;B&gt;(), std::true_type());

    template &lt;typename, typename&gt;
    static auto test(...) -&gt; std::false_type;
public:
    static constexpr auto value = decltype(test&lt;T,U&gt;(0))::value;
};
</code></pre>
<blockquote>
<p>iterating over tuple types</p>
</blockquote>
<pre><code class="language-c++">
template &lt;typename Tuple, size_t ...Is&gt;
void print_tuple_types(std::index_sequence&lt;Is...&gt;) {
    (std::cout &lt;&lt; ... &lt;&lt; typeid(std::tuple_element_t&lt;Is,Tuple&gt;).name() &lt;&lt; " " );
}

void foo() {
    using tuple_t = std::tuple&lt;int,float, const char*&gt;;
    print_tuple_types&lt;tuple_t&gt;(std::make_index_sequence&lt;std::tuple_size_v&lt;tuple_t&gt;&gt;{});
}
</code></pre>
<blockquote>
<p>serializer with sfinae guards</p>
</blockquote>
<pre><code class="language-c++">
#include &lt;array&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;type_traits&gt;
#include &lt;vector&gt;

struct data {
    int id;
    std::array&lt;char, 20&gt; text;
};

template &lt;typename T&gt;
class serializer {
   public:
    template &lt;typename U = T&gt;
    typename std::enable_if_t&lt;std::is_trivially_copyable_v&lt;U&gt;,
                              std::vector&lt;char&gt;&gt;
    serialize() {
        std::vector&lt;char&gt; buffer(
            sizeof(T));  // create a continuous memory in heap
        T* obj = reinterpret_cast&lt;T*&gt;(buffer.data());
        *obj = value_;
        return buffer;
    }

    template &lt;typename U = T&gt;
    typename std::enable_if_t&lt;std::is_same_v&lt;U, std::string&gt;, std::vector&lt;char&gt;&gt;
    serialize() {
        return std::vector&lt;char&gt;{value_.begin(), value_.end()};
    }

    T value_;
};

int main() {
    data d{.id = 101, .text = "hakan gedek"};
    serializer&lt;data&gt; s(d);

    auto res = s.serialize();

    for (auto&amp; ch : res) std::cout &lt;&lt; ch;
}

</code></pre>
<blockquote>
<p>optimization for copying</p>
</blockquote>
<pre><code class="language-c++">
// trivially stuff decides if a type has encapsulation or not - like POD , data classes etc..they don't implement encapsulation rules.

template&lt;typename T&gt;
class OptimizedWrapper {
public:
    // Optimize for trivially copyable types
    template&lt;typename U = T&gt;
    typename std::enable_if_t&lt;std::is_trivially_copyable_v&lt;U&gt;, void&gt;
    store(const T&amp; value) {
        // Potentially more efficient storage for trivially copyable types
        memcpy(&amp;data, &amp;value, sizeof(T)); // raw data assignment
    }

    // Fallback for complex types
    template&lt;typename U = T&gt;
    typename std::enable_if_t&lt;!std::is_trivially_copyable_v&lt;U&gt;, void&gt;
    store(const T&amp; value) {
        data = value; // own copy assignment called - slower
    }

private:
    T data;
}
</code></pre>
<blockquote>
<p>static buffer</p>
</blockquote>
<pre><code class="language-c++">template&lt;int Size&gt;
class StaticBuffer {
private:
    std::array&lt;char, Size&gt; buffer;

public:
    constexpr StaticBuffer() : buffer{} {}

    constexpr size_t size() const { return Size; }
};

</code></pre>
<blockquote>
<p>type based optimization</p>
</blockquote>
<pre><code class="language-c++">
template&lt;typename T&gt;
constexpr T processValue(T value) {
    if constexpr (std::is_integral_v&lt;T&gt;) {
        return value * 2;  // Optimize for integral types
    } else if constexpr (std::is_floating_point_v&lt;T&gt;) {
        return value / 2.0;  // Different optimization for floating-point
    } else {
        return value;  // Fallback for other types
    }
}

</code></pre>
<blockquote>
<p>compile time sum</p>
</blockquote>
<pre><code class="language-c++">
template&lt;int N&gt;
struct CompileTimeSum {
    static constexpr int value = N + CompileTimeSum&lt;N - 1&gt;::value;
};

template&lt;&gt;
struct CompileTimeSum&lt;0&gt; {
    static constexpr int value = 0;
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-decltype-and-declval"><a class="header" href="#use-decltype-and-declval">use decltype and declval</a></h1>
<p>decltype: evaluate the type of variable at compilation time. can deduce types of vars, expressions, function return types</p>
<p>declval: can construct a value without creating it - used in type deduction - used to get return types in meta-programming</p>
<blockquote>
<p>diff declval<T>() and declval&lt;T&amp;&gt;()</p>
</blockquote>
<ul>
<li>
<p>T: rvalue, move ctor, rvalue scenarios...so this creates an rvalue without creating it and used to deduce expression results which waiting for rvalue</p>
</li>
<li>
<p>T&amp;: lvalue ref, binding to existing objects. so this creates a lvalue reference without creating it and used to check expression results.</p>
</li>
</ul>
<blockquote>
<p>declval: return add_rvalue_reference<T>::value which means that if T + T&amp;&amp; =&gt; T&amp;&amp; and T&amp; + T&amp;&amp; =&gt; T&amp;... so think about it.</p>
</blockquote>
<pre><code class="language-c++">
#include &lt;print&gt;

struct MyS {
    float getValue() &amp; { return .1f; }
    int getValue() &amp;&amp; { return 2; }
};

struct MySS {
    int getValue() { return 2; }
};

int main() {
    {
        // 2 funcs for each -&gt; T-&gt; calls for rvalue
        using rvalue_t = decltype(std::declval&lt;MyS&gt;().getValue());
        static_assert(std::is_same&lt;rvalue_t, int&gt;::value);

        // T&amp; calls for lvalue
        using lvalue_t = decltype(std::declval&lt;MyS&amp;&gt;().getValue());
        static_assert(std::is_same&lt;lvalue_t, float&gt;::value);
    }
    {
        // one func for all
        using rvalue_t = decltype(std::declval&lt;MySS&gt;().getValue());
        static_assert(std::is_same&lt;rvalue_t, int&gt;::value);

        using lvalue_t = decltype(std::declval&lt;MySS&amp;&gt;().getValue());
        static_assert(std::is_same&lt;lvalue_t, int&gt;::value);
    }
}

</code></pre>
<pre><code class="language-c++">
#include &lt;iostream&gt;

class Noncopyable {
   public:
    Noncopyable() = default;
    Noncopyable(Noncopyable const&amp;) = delete;
    Noncopyable&amp; operator=(Noncopyable const&amp;) = delete;

    int modifyFoo() { return -1; }
    int constFoo() const { return -1; }
};

template &lt;typename T&gt;
void declvalDiffs() {
    std::cout
        &lt;&lt; "Is declval&lt;T&gt; an rvalue: "
        &lt;&lt; std::is_rvalue_reference_v&lt;decltype(std::declval&lt;T&gt;())&gt; &lt;&lt; std::endl;
    std::cout &lt;&lt; "Is declval&lt;T&gt; an rvalue: "
              &lt;&lt; std::is_rvalue_reference_v&lt;
                     decltype(std::declval&lt;T&amp;&amp;&gt;())&gt; &lt;&lt; std::endl;
    std::cout &lt;&lt; "Is declval&lt;T&amp;&gt; an lvalue: "
              &lt;&lt; std::is_lvalue_reference_v&lt;
                     decltype(std::declval&lt;T&amp;&gt;())&gt; &lt;&lt; std::endl;

    std::cout &lt;&lt; "Is declval&lt;T&gt;() const: "
              &lt;&lt; std::is_const_v&lt;std::remove_reference_t&lt;
                     decltype(std::declval&lt;T&gt;())&gt;&gt; &lt;&lt; std::endl;
    std::cout &lt;&lt; "Is declval&lt;T const&gt;() const: "
              &lt;&lt; std::is_const_v&lt;std::remove_reference_t&lt;
                     decltype(std::declval&lt;T const&gt;())&gt;&gt; &lt;&lt; std::endl;
    std::cout &lt;&lt; "Is declval&lt;T const&gt;() const: "
              &lt;&lt; std::is_const_v&lt;std::remove_reference_t&lt;
                     decltype(std::declval&lt;const T&amp;&gt;())&gt;&gt; &lt;&lt; std::endl;
}

template &lt;typename T&gt;
void methodTests() {
    using x = decltype(std::declval&lt;T&gt;().modifyFoo());
    using y = decltype(std::declval&lt;T&amp;&gt;().modifyFoo());

    using a = decltype(std::declval&lt;T const&gt;().constFoo());
    using b = decltype(std::declval&lt;const T&amp;&gt;().constFoo());
}

template &lt;typename T&gt;
struct is_movable {
   private:
    template &lt;typename U&gt;
    static auto test(int) -&gt; decltype(std::declval&lt;U&amp;&amp;&gt;(), std::true_type());

    template &lt;typename&gt;
    static auto test(...) -&gt; std::false_type;

   public:
    static constexpr bool value = decltype(test&lt;T&gt;(0))::value;
};

int main() {
    declvalDiffs&lt;Noncopyable&gt;();
    methodTests&lt;Noncopyable&gt;();

    std::cout &lt;&lt; "in Noncopyable movable: " &lt;&lt; is_movable&lt;Noncopyable&gt;::value
              &lt;&lt; std::endl;
}
</code></pre>
<blockquote>
<p>you can combine decltype and declval to check stuff at compilation time lik they exist. if they don't then your test fails but if you put alternative you will have no problem. True and false cases.</p>
</blockquote>
<p>this example can be re-written by concepts easily but old versions from sfinae time was like this...</p>
<blockquote>
<p>static keyword belongs to class so for each T; this class will be unique like a 1:1 =&gt; int =&gt; is_streamable<int> , float =&gt; is_streamable<float>...</p>
</blockquote>
<pre><code class="language-c++">
template &lt;typename T, typename Stream = std::ostream&gt;
struct is_streamable {
private:
    template &lt;typename U&gt;
    static auto test(int) -&gt; decltype(std::declval&lt;Stream&gt;() &lt;&lt; std::declval&lt;U&gt;(), std::true_type());

    template &lt;typename&gt;
    static auto test(...) -&gt; std::false_type;
public:
    static constexpr auto value = decltype(test&lt;T&gt;(0))::value;
};

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-stdref-and-stdcref"><a class="header" href="#use-stdref-and-stdcref">use std::ref and std::cref</a></h1>
<p>both create <code>std::reference_wrapper</code> type which is used to wrap T&amp; or const T&amp;. in c++; you cannot store references in containers but using this wrapper type; it's possible;</p>
<p>usage areas:</p>
<blockquote>
<p>passing ref to threads</p>
</blockquote>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;thread&gt;

void modifyValue(int&amp; value) {
    value *= 2;
}

int main() {
    int myValue = 10;
    // pass by ref to thread solution
    std::thread t(modifyValue, std::ref(myValue));
    t.join();
    std::cout &lt;&lt; "Modified value: " &lt;&lt; myValue &lt;&lt; std::endl;
    return 0;
}

</code></pre>
<blockquote>
<p>passing ref to std::bind</p>
</blockquote>
<p>by default; std::bind, std::bind_front, std::bind_back copy the values.</p>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;functional&gt;

void printValue(const int&amp; value) {
    std::cout &lt;&lt; "Value: " &lt;&lt; value &lt;&lt; std::endl;
}

int main() {
    int myValue = 5;
    auto boundFunction = std::bind(printValue, std::ref(myValue));
    boundFunction();
    myValue = 15;
    boundFunction();
    return 0;
}

</code></pre>
<blockquote>
<p>storing refs in containers</p>
</blockquote>
<p>be sure; your refs should not outlive your original data. c++ cannot detect life times so if you dispose your original data while keeping ref to them; it will UB.</p>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;functional&gt;

int main() {
    int a = 1, b = 2, c = 3;
    std::vector&lt;std::reference_wrapper&lt;int&gt;&gt; refs = {std::ref(a), std::ref(b), std::ref(c)};

    for (auto&amp; ref : refs) {
        ref.get() *= 2;
    }

    std::cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; " " &lt;&lt; c &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<blockquote>
<p>passing const references</p>
</blockquote>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;functional&gt;

void printConstValue(const int&amp; value) {
    std::cout &lt;&lt; "Const Value: " &lt;&lt; value &lt;&lt; std::endl;
}

int main(){
    const int myConstValue = 30;
    auto boundConstFunction = std::bind(printConstValue, std::cref(myConstValue));
    boundConstFunction();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-perfect-forwarding-and-return"><a class="header" href="#use-perfect-forwarding-and-return">use perfect forwarding and return</a></h1>
<p>perfect forwarding: forward variables from function to function while preserving their types. this helps with unnecessary copies</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;utility&gt;

void process(int&amp; i) {
    std::cout &lt;&lt; "lvalue reference\n";
}

void process(int&amp;&amp; i) {
    std::cout &lt;&lt; "rvalue reference\n";
}

template &lt;typename T&gt;
void forwarder(T&amp;&amp; arg) {
    process(std::forward&lt;T&gt;(arg));
}

int main() {
    int x = 10;
    forwarder(x);      // lvalue
    forwarder(20);     // rvalue
    return 0;
}

</code></pre>
<p>perfect returning: returning a value from a function while preserving it's original value category</p>
<blockquote>
<p>use decltype(auto) as return type</p>
</blockquote>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;utility&gt;

int global_value = 42;

int&amp; get_lvalue() {
    return global_value;
}

int get_rvalue() {
    return 123;
}

template &lt;typename Function&gt;
decltype(auto) forward_return(Function&amp;&amp; func) {
    return std::forward&lt;Function&gt;(func)();
}

int main() {
    int&amp; lvalue_ref = forward_return(get_lvalue);
    lvalue_ref = 50;
    std::cout &lt;&lt; global_value &lt;&lt; std::endl; // Output: 50

    int rvalue = forward_return(get_rvalue);
    std::cout &lt;&lt; rvalue &lt;&lt; std::endl; // Output: 123

    return 0;
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-thread-locals"><a class="header" href="#use-thread-locals">use thread locals</a></h1>
<p>TLS: thread local storage</p>
<p>TLS allows us to create variables that have thread specific storage duration. they only exist in threads and isolated. updates from one thread will not effect the other thread's variable.</p>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;thread&gt;

thread_local int threadId = 0; // Thread-local variable

void threadFunction(int id) {
    threadId = id;
    std::cout &lt;&lt; "Thread ID: " &lt;&lt; threadId &lt;&lt; std::endl;
    threadId++;
    std::cout &lt;&lt; "Thread ID after increment: " &lt;&lt; threadId &lt;&lt; std::endl;
}

int main() {
    std::thread t1(threadFunction, 1);
    std::thread t2(threadFunction, 2);

    t1.join();
    t2.join();

    std::cout &lt;&lt; "Main thread ID: " &lt;&lt; threadId &lt;&lt; std::endl;

    return 0;
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-std-functors"><a class="header" href="#use-std-functors">use std functors</a></h1>
<p>std library has many predefined functors in std::functional. instead of coding them with lambdas again you can use them - via binds or std::algorithms.</p>
<p>some of them:</p>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;functional&gt;

int main() {
    std::plus&lt;int&gt; add;
    std::minus&lt;int&gt; subtract;
    std::multiplies&lt;int&gt; multiply;
    std::divides&lt;int&gt; divide;

    int a = 10, b = 5;

    std::cout &lt;&lt; "Add: " &lt;&lt; add(a, b) &lt;&lt; std::endl;        // Outputs: 15
    std::cout &lt;&lt; "Subtract: " &lt;&lt; subtract(a, b) &lt;&lt; std::endl; // Outputs: 5
    std::cout &lt;&lt; "Multiply: " &lt;&lt; multiply(a, b) &lt;&lt; std::endl; // Outputs: 50
    std::cout &lt;&lt; "Divide: " &lt;&lt; divide(a, b) &lt;&lt; std::endl;    // Outputs: 2

    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-error-codes"><a class="header" href="#use-error-codes">use error codes</a></h1>
<p>c++ supports error codes and they are good to standardize the tracking errors in programs.</p>
<p>like std::exception; it supports an interface and via it we can provide our custom types. starting with defined enums.</p>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;system_error&gt;

enum class MyErrorCodes {
    DATABASE_CONNECTION_FAILED = 100,
    INVALID_USER_INPUT = 101
};

class MyErrorCategory : public std::error_category {
public:
    const char* name() const noexcept override {
        return "MyErrorCategory";
    }

    std::string message(int ev) const override {
        switch (static_cast&lt;MyErrorCodes&gt;(ev)) {
            case MyErrorCodes::DATABASE_CONNECTION_FAILED:
                return "Database connection failed.";
            case MyErrorCodes::INVALID_USER_INPUT:
                return "Invalid user input.";
            default:
                return "Unknown error.";
        }
    }
};

const MyErrorCategory myErrorCategory{};

std::error_code make_error_code(MyErrorCodes e) {
    return {static_cast&lt;int&gt;(e), myErrorCategory};
}

int main() {
    std::error_code ec1 = make_error_code(MyErrorCodes::DATABASE_CONNECTION_FAILED);
    std::error_code ec2 = std::make_error_code(MyErrorCodes::INVALID_USER_INPUT);

    std::cout &lt;&lt; "Error 1: " &lt;&lt; ec1.message() &lt;&lt; std::endl;
    std::cout &lt;&lt; "Error 2: " &lt;&lt; ec2.message() &lt;&lt; std::endl;

    return 0;
}

</code></pre>
<p>or use stds</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;system_error&gt;

std::error_code readFile(const std::string&amp; filename) {
    std::ifstream file(filename);
    if (!file.is_open()) {
        return std::make_error_code(std::errc::no_such_file_or_directory);
    }
    // ... read file content ...
    if(file.fail()){
        return std::make_error_code(std::errc::io_error);
    }
    return {}; // No error
}

int main() {
    std::error_code ec = readFile("my_file.txt");
    if (ec) {
        std::cerr &lt;&lt; "Error: " &lt;&lt; ec.message() &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; "File read successfully." &lt;&lt; std::endl;
    }
    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-smart-pointers"><a class="header" href="#use-smart-pointers">use smart pointers</a></h1>
<p>firstly; they are here to manage memory better. we have 3 different std smart pointers. they are created according to ownership models.</p>
<ul>
<li>
<p>unique_ptr: single ownership. sole owner the memory - not shared.</p>
<ul>
<li>can be moved</li>
<li>scope based so it automatically release memory after leaving the scope</li>
</ul>
</li>
<li>
<p>shared_ptr: shared ownership. one memory but more owners - counting based. when count is 0 then memory is released.</p>
<ul>
<li>reference counting: whenever it's 0 then memory is released.</li>
</ul>
</li>
<li>
<p>weak_ptr: not owner but just user - doesn't care about owning but if possible it tries to use it via shared_ptr.</p>
<ul>
<li>implementing cyclic data structures with shared_ptr : one owner + one user</li>
</ul>
</li>
</ul>
<p>simple examples:</p>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;memory&gt;

int main() {
    std::unique_ptr&lt;int&gt; ptr(new int(42));
    std::cout &lt;&lt; *ptr &lt;&lt; std::endl; // Output: 42

    // Move ownership
    std::unique_ptr&lt;int&gt; ptr2 = std::move(ptr);
    if (ptr2) {
        std::cout &lt;&lt; *ptr2 &lt;&lt; std::endl; // Output: 42
    }

    // ptr is now null
    if (!ptr) {
        std::cout &lt;&lt; "ptr is now null" &lt;&lt; std::endl;
    }

    return 0;
}

</code></pre>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;memory&gt;

int main() {
    std::shared_ptr&lt;int&gt; ptr1(new int(10));
    std::shared_ptr&lt;int&gt; ptr2 = ptr1; // Shared ownership

    std::cout &lt;&lt; "ptr1 count: " &lt;&lt; ptr1.use_count() &lt;&lt; std::endl; // Output: ptr1 count: 2
    std::cout &lt;&lt; "ptr2 count: " &lt;&lt; ptr2.use_count() &lt;&lt; std::endl; // Output: ptr2 count: 2

    return 0;
}

</code></pre>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;memory&gt;

int main() {
    std::shared_ptr&lt;int&gt; sharedPtr(new int(5));
    std::weak_ptr&lt;int&gt; weakPtr = sharedPtr;

    if (auto lockedPtr = weakPtr.lock()) {
        std::cout &lt;&lt; "Value: " &lt;&lt; *lockedPtr &lt;&lt; std::endl; // Output: Value: 5
    }

    sharedPtr.reset(); // Release ownership

    if (weakPtr.lock()) {
        std::cout &lt;&lt; "This won't be printed." &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; "Object no longer exists." &lt;&lt; std::endl; // Object no longer exists.
    }

    return 0;
}

</code></pre>
<blockquote>
<p>cyclic dependency problem solution with shared_ptr and weak_ptr</p>
</blockquote>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;memory&gt;

class B; // Forward declaration

class A {
public:
    std::shared_ptr&lt;B&gt; b_ptr;

    ~A() {
        std::cout &lt;&lt; "A destroyed" &lt;&lt; std::endl;
    }
};

class B {
public:
    std::weak_ptr&lt;A&gt; a_ptr; // Changed to weak_ptr

    ~B() {
        std::cout &lt;&lt; "B destroyed" &lt;&lt; std::endl;
    }
};

int main() {
    {
        std::shared_ptr&lt;A&gt; a = std::make_shared&lt;A&gt;();
        std::shared_ptr&lt;B&gt; b = std::make_shared&lt;B&gt;();

        a-&gt;b_ptr = b;
        b-&gt;a_ptr = a; // Weak ptr does not increment the ref count.
    } // a and b go out of scope here

    std::cout &lt;&lt; "Program ends" &lt;&lt; std::endl;

    return 0;
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-padding-and-alignments"><a class="header" href="#use-padding-and-alignments">use padding and alignments</a></h1>
<p>alignment: different types have different alignments on memory</p>
<p>padding: used to arrange alignments because cpu can access them better if they follow alignment size rules.</p>
<pre><code class="language-c++">
struct Example {
    char a;   // 1 byte
    int b;    // 4 bytes
    char c;   // 1 byte
};

</code></pre>
<p>Without padding, the memory layout would look like this:</p>
<p>| a | b | b | b | b | c |</p>
<p>However, due to alignment requirements, it might actually look like this:</p>
<p>| a | pad | pad | pad | b | b | b | b | c | pad | pad | pad |</p>
<p>Here, pad represents padding bytes added to align b and c properly.</p>
<h2 id="how-to-control-alignment"><a class="header" href="#how-to-control-alignment">How to Control Alignment</a></h2>
<p>You can control alignment using the alignas specifier:</p>
<pre><code class="language-c++">struct Example {
char a;
alignas(4) int b; // Ensure 'b' is aligned to 4 bytes
char c;
};
</code></pre>
<h2 id="practical-tips"><a class="header" href="#practical-tips">Practical Tips</a></h2>
<ul>
<li>Order Members by Size: Place larger members first to minimize padding.</li>
<li>Use alignas: Explicitly specify alignment if needed.</li>
<li>Understand Compiler Behavior: Different compilers might handle padding differently.</li>
</ul>
<pre><code class="language-c++">
struct OptimizedExample {
    int b;    // 4 bytes
    char a;   // 1 byte
    char c;   // 1 byte
    // 2 bytes of padding added automatically
};

</code></pre>
<p>In this case, the memory layout is more efficient:</p>
<p>| b | b | b | b | a | c | pad | pad |</p>
<blockquote>
<p>control a struct alignment</p>
</blockquote>
<pre><code class="language-c++">struct alignas(16) AlignedStruct {
    // ...
};
</code></pre>
<blockquote>
<p>use alignas when you have specific alignment requirements</p>
</blockquote>
<p>a test for a different aligned struct:</p>
<pre><code class="language-c++">
#include &lt;algorithm&gt;
#include &lt;chrono&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;

struct UnalignedStruct {
    char c;
    int i;

    UnalignedStruct&amp; operator=(int val) {
        c = val;
        i = val;
        return *this;
    }
};

struct alignas(16) AlignedStruct {
    char c;
    int i;
    AlignedStruct&amp; operator=(int val) {
        c = val;
        i = val;
        return *this;
    }
};

template &lt;typename T&gt;
double benchmarkAccess(std::vector&lt;T&gt;&amp; data) {
    auto start = std::chrono::high_resolution_clock::now();

    // Access all elements in the vector
    long long sum = 0;
    for (auto&amp; item : data) {
        sum += item.i;
    }

    auto end = std::chrono::high_resolution_clock::now();
    std::chrono::duration&lt;double&gt; duration = end - start;

    // Avoid compiler optimization of sum;
    std::cout &lt;&lt; "Sum: " &lt;&lt; sum &lt;&lt; std::endl;

    return duration.count();
}

int main() {
    const size_t numElements = 10000;

    // Unaligned struct
    std::vector&lt;UnalignedStruct&gt; unalignedData(numElements);
    std::iota(unalignedData.begin(), unalignedData.end(), 0);

    // Aligned struct
    std::vector&lt;AlignedStruct&gt; alignedData(numElements);
    std::iota(alignedData.begin(), alignedData.end(), 0);

    double unalignedTime = benchmarkAccess(unalignedData);
    double alignedTime = benchmarkAccess(alignedData);

    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(6);
    std::cout &lt;&lt; "Unaligned access time: " &lt;&lt; unalignedTime &lt;&lt; " seconds"
              &lt;&lt; std::endl;
    std::cout &lt;&lt; "Aligned access time: " &lt;&lt; alignedTime &lt;&lt; " seconds"
              &lt;&lt; std::endl;

    return 0;


</code></pre>
<pre><code class="language-c++">Program stdout
Sum: 49995000
Sum: 49995000
Unaligned access time: 0.000087 seconds
Aligned access time: 0.000096 seconds

</code></pre>
<pre><code class="language-c++">
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;vector&gt;

struct AlignedStruct {
    int a;     // 4 bytes
    double b;  // 8 bytes
    char c;    // 1 byte
    // Padding added automatically to align 'b' and 'c'
};

struct MisalignedStruct {
    char c;    // 1 byte
    int a;     // 4 bytes
    double b;  // 8 bytes
    // Misalignment due to the order of members
};

template &lt;typename T&gt;
void benchmark(const std::vector&lt;std::shared_ptr&lt;T&gt;&gt;&amp; vec) {
    auto start = std::chrono::high_resolution_clock::now();
    double sum = 0;
    for (const auto&amp; item : vec) {
        sum += item-&gt;a + item-&gt;b + item-&gt;c;
    }
    auto end = std::chrono::high_resolution_clock::now();
    std::chrono::duration&lt;double&gt; duration = end - start;
    std::cout &lt;&lt; "Time taken: " &lt;&lt; duration.count() &lt;&lt; " seconds\n";
}

int main() {
    const int numElements = 1000000;

    std::vector&lt;std::shared_ptr&lt;AlignedStruct&gt;&gt; alignedVec;
    std::vector&lt;std::shared_ptr&lt;MisalignedStruct&gt;&gt; misalignedVec;

    for (int i = 0; i &lt; numElements; ++i) {
        alignedVec.push_back(std::make_shared&lt;AlignedStruct&gt;());
        misalignedVec.push_back(std::make_shared&lt;MisalignedStruct&gt;());
    }

    std::cout &lt;&lt; "Benchmarking AlignedStruct...\n";
    benchmark(alignedVec);

    std::cout &lt;&lt; "Benchmarking MisalignedStruct...\n";
    benchmark(misalignedVec);

    return 0;
}

</code></pre>
<pre><code class="language-c++">Program stdout
Benchmarking AlignedStruct...
Time taken: 0.0515799 seconds
Benchmarking MisalignedStruct...
Time taken: 0.0515753 seconds
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="convert-multi-byte-to-wide"><a class="header" href="#convert-multi-byte-to-wide">convert multi-byte to wide</a></h1>
<p>in c/c++ ecosystem; char is 1 byte and wchar_t is 2 bytes. this is a problem with utf8. for example rust's char is 4 bytes - standard.</p>
<p>1 byte or 2 bytes can save us from large programs but create problem when dealing with utf8 and others... std::string etc supports utf8 coding (u8string, u16string...) but it's wrapped inside and using <code>operator []</code> is a problem.</p>
<p>c/c++ has functions to convert wide to multi-byte methods.</p>
<p><strong>wide: wchar_t, wstring</strong>
<strong>mb : char , string</strong></p>
<blockquote>
<p>c methods</p>
</blockquote>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;cwchar&gt;

int main() {
    const char* multibyteStr = "Hello, world!";
    wchar_t wideStr[50];

    std::size_t convertedChars = std::mbstowcs(wideStr, multibyteStr, 50);
    if (convertedChars == static_cast&lt;std::size_t&gt;(-1)) {
        std::cerr &lt;&lt; "Conversion error\n";
        return 1;
    }

    std::wcout &lt;&lt; L"Wide character string: " &lt;&lt; wideStr &lt;&lt; std::endl;
    return 0;
}

</code></pre>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;cwchar&gt;

int main() {
    const wchar_t* wideStr = L"Hello, world!";
    char multibyteStr[50];

    std::size_t convertedChars = std::wcstombs(multibyteStr, wideStr, 50);
    if (convertedChars == static_cast&lt;std::size_t&gt;(-1)) {
        std::cerr &lt;&lt; "Conversion error\n";
        return 1;
    }

    std::cout &lt;&lt; "Multibyte string: " &lt;&lt; multibyteStr &lt;&lt; std::endl;
    return 0;
}

</code></pre>
<blockquote>
<p>c++ methods: std::mbrtoc16, std::mbrtoc32, std::c16rtomb, std::c32rtomb</p>
</blockquote>
<p>reading mb chars with iterators is good. don't try operator[] with mb chars - they may be larger than 1 byte and this will problem. in this example; we convert all to 4 bytes and creating a u32string.</p>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;cuchar&gt;
#include &lt;locale&gt;
#include &lt;string&gt;

int main() {
    std::locale::global(std::locale("en_US.UTF-8")); // Set locale

    std::string multibyteStr = "こんにちは"; // Example UTF-8 string
    std::u32string utf32Str;

    std::mbstate_t state{};
    const char* mbPtr = multibyteStr.c_str();
    const char* mbEnd = mbPtr + multibyteStr.size();
    char32_t c32;

    while (mbPtr &lt; mbEnd) {
        std::size_t result = std::mbrtoc32(&amp;c32, mbPtr, mbEnd - mbPtr, &amp;state);
        if (result == static_cast&lt;std::size_t&gt;(-1) || result == static_cast&lt;std::size_t&gt;(-2)) {
            std::cerr &lt;&lt; "Conversion error" &lt;&lt; std::endl;
            break;
        }
        if (result == 0) {
            break; // Null character
        }
        utf32Str += c32;
        mbPtr += result;
    }

    std::cout &lt;&lt; "UTF-32 string: " &lt;&lt; std::endl;
    for (char32_t c : utf32Str) {
        std::cout &lt;&lt; std::hex &lt;&lt; static_cast&lt;uint32_t&gt;(c) &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::dec &lt;&lt; std::endl;

    return 0;
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="read-and-write-file-with-iterators"><a class="header" href="#read-and-write-file-with-iterators">read and write file with iterators</a></h1>
<p>we can use std::istream_iterator and std::ostream_iterators</p>
<p>if you don't need to parse while reading which means reading raw bytes then use istreambuf_iterator and ostreambuf_iterator.</p>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::ifstream inputFile("input.txt");
    if (!inputFile) {
        std::cerr &lt;&lt; "Error opening input file." &lt;&lt; std::endl;
        return 1;
    }

    std::istream_iterator&lt;int&gt; inputIterator(inputFile);
    std::istream_iterator&lt;int&gt; endIterator; // Default-constructed is end-of-stream

    std::vector&lt;int&gt; numbers(inputIterator, endIterator);

    std::cout &lt;&lt; "Numbers read from file: ";
    for (int num : numbers) {
        std::cout &lt;&lt; num &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<pre><code class="language-c++">
std::ifstream inputFile("input.txt");
std::istream_iterator&lt;std::string&gt; inputIterator(inputFile);
std::istream_iterator&lt;std::string&gt; endIterator;
std::vector&lt;std::string&gt; words(inputIterator, endIterator);

</code></pre>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;int&gt; numbers = {10, 20, 30, 40, 50};

    std::ofstream outputFile("output.txt");
    if (!outputFile) {
        std::cerr &lt;&lt; "Error opening output file." &lt;&lt; std::endl;
        return 1;
    }

    std::ostream_iterator&lt;int&gt; outputIterator(outputFile, " "); // Delimiter is a space

    std::copy(numbers.begin(), numbers.end(), outputIterator);

    outputFile &lt;&lt; std::endl; // Add a newline at the end

    return 0;
}
</code></pre>
<blockquote>
<p>Reading and Writing Character-by-Character:</p>
</blockquote>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;iterator&gt;

int main() {
    std::ifstream inputFile("input.txt");
    std::ofstream outputFile("output.txt");

    if (!inputFile || !outputFile) {
        std::cerr &lt;&lt; "Error opening files." &lt;&lt; std::endl;
        return 1;
    }

    std::istreambuf_iterator&lt;char&gt; inputIterator(inputFile);
    std::istreambuf_iterator&lt;char&gt; endIterator;

    std::ostreambuf_iterator&lt;char&gt; outputIterator(outputFile);

    while (inputIterator != endIterator) {
        *outputIterator = *inputIterator;
        ++inputIterator;
        ++outputIterator;
    }

    return 0;
}

</code></pre>
<blockquote>
<p>File Modes: Use the appropriate file modes (e.g., std::ios::binary, std::ios::app) when opening files.</p>
</blockquote>
<blockquote>
<p>Buffering: File streams are buffered, so you may need to flush the buffer (e.g., outputFile.flush()) to ensure that data is written immediately.</p>
</blockquote>
<blockquote>
<p>Performance: For large files, consider using buffered I/O or memory-mapped files for better performance.</p>
</blockquote>
<blockquote>
<p>Text vs. Binary: Be aware of the differences between text and binary file modes and use the appropriate mode for your data.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-projection-in-ranges"><a class="header" href="#use-projection-in-ranges">use projection in ranges</a></h1>
<p>Projections in the C++20 Ranges library are a powerful feature that allow you to transform elements of a range before applying an algorithm to them. This can be particularly useful for operations like sorting or searching based on a specific attribute of the elements.</p>
<p>Projection: A callable (like a function, lambda, or function object) that is applied to each element of a range before the main algorithm operates on it. This allows you to work with a specific part of each element, such as a member variable.</p>
<blockquote>
<p>The third argument to std::ranges::sort is a projection, &amp;Person::age, which extracts the age member from each Person object.</p>
</blockquote>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;ranges&gt;

struct Person {
    std::string name;
    int age;
};

int main() {
    std::vector&lt;Person&gt; people = {
        {"Alice", 30},
        {"Bob", 25},
        {"Charlie", 35}
    };

    std::ranges::sort(people, {}, &amp;Person::age);

    for (const auto&amp; person : people) {
        std::cout &lt;&lt; person.name &lt;&lt; " (" &lt;&lt; person.age &lt;&lt; ")\n";
    }

    return 0;
}

</code></pre>
<blockquote>
<p>The lambda function { return p.name.size(); } is used as a projection to sort the people vector by the length of the name.</p>
</blockquote>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;ranges&gt;

struct Person {
    std::string name;
    int age;
};

int main() {
    std::vector&lt;Person&gt; people = {
        {"Alice", 30},
        {"Bob", 25},
        {"Charlie", 35}
    };

    std::ranges::sort(people, {},  { return p.name.size(); });

    for (const auto&amp; person : people) {
        std::cout &lt;&lt; person.name &lt;&lt; " (" &lt;&lt; person.age &lt;&lt; ")\n";
    }

    return 0;
}
</code></pre>
<blockquote>
<p>almost all constrained algorithms support projections - you transform the original data then you apply algorithm if you want or pick a part of the data to use in the algorithm; here we use age again not all Person.</p>
</blockquote>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;ranges&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;

struct Person {
    std::string name;
    int age;
};

int main() {
    std::vector&lt;Person&gt; people = {
        {"Alice", 30},
        {"Bob", 25},
        {"Charlie", 35}
    };

    // Find the person with the maximum age
    auto maxPerson = std::ranges::max_element(people, {}, &amp;Person::age);

    if (maxPerson != people.end()) {
        std::cout &lt;&lt; "Max age: " &lt;&lt; maxPerson-&gt;name &lt;&lt; ": " &lt;&lt; maxPerson-&gt;age &lt;&lt; std::endl;
    }

    return 0;
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-regular-expressions"><a class="header" href="#use-regular-expressions">use regular expressions</a></h1>
<blockquote>
<p>Key classes</p>
</blockquote>
<ul>
<li>
<p>std::regex: pattern handler</p>
</li>
<li>
<p>std::smatch: match results</p>
</li>
<li>
<p>std::sregex_iterator: multiple match iteration</p>
</li>
</ul>
<p>basic usage:</p>
<pre><code class="language-c++">
std::regex pattern(R"(regex_here)");
std::regex_search(text, pattern);  // Check if pattern exists
std::regex_match(text, pattern);   // Full string match

</code></pre>
<p>match types:</p>
<ul>
<li>
<p>smatch: c++ string match</p>
</li>
<li>
<p>cmatch: c string match</p>
</li>
<li>
<p>wsmatch: wide string match</p>
</li>
</ul>
<p>regex methods:</p>
<ul>
<li>
<p>regex_search: find pattern in text</p>
</li>
<li>
<p>regex_match: complete string match</p>
</li>
<li>
<p>regex_replace: replace matched pattern</p>
</li>
</ul>
<blockquote>
<p>use R"()" when creating regex</p>
</blockquote>
<pre><code class="language-c++">
Email: R"([\w.]+@[\w.]+\.\w+)"
Phone: R"((\d{3})-(\d{3})-(\d{4}))"

</code></pre>
<blockquote>
<p>basic matching</p>
</blockquote>
<pre><code class="language-c++">
void basic_matching() {
    std::cout &lt;&lt; "\n--- Basic Matching ---\n";

    std::string text = "Hello, my email is john.doe@example.com";
    std::regex email_pattern(R"([\w.]+@[\w.]+\.\w+)");

    // Check if pattern exists in the string
    if (std::regex_search(text, email_pattern)) {
        std::cout &lt;&lt; "Email found in the text\n";
    }

    // Full match
    std::smatch match;
    if (std::regex_search(text, match, email_pattern)) {
        std::cout &lt;&lt; "Matched email: " &lt;&lt; match[0] &lt;&lt; std::endl;
    }
}

void basic_matching2() {
    std::string input = "hello";
    std::regex pattern("hello");

    if (std::regex_match(input, pattern)) {
        std::cout &lt;&lt; "Match found!" &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; "Match not found." &lt;&lt; std::endl;
    }
}

</code></pre>
<blockquote>
<p>search for substrings</p>
</blockquote>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;regex&gt;
#include &lt;string&gt;

int main() {
    std::string input = "This is a hello world";
    std::regex pattern("hello");
    std::smatch match;

    if (std::regex_search(input, match, pattern)) {
        std::cout &lt;&lt; "Match found at position: " &lt;&lt; match.position() &lt;&lt; std::endl;
        std::cout &lt;&lt; "Matched string: " &lt;&lt; match.str() &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; "Match not found." &lt;&lt; std::endl;
    }

    return 0;
}

</code></pre>
<blockquote>
<p>extraction</p>
</blockquote>
<pre><code class="language-c++">
void match_extraction() {
    std::cout &lt;&lt; "\n--- Match Extraction ---\n";

    std::string text = "The price is $24.99 and the quantity is 5";
    std::regex price_pattern(R"(\$(\d+\.\d+))");

    std::smatch match;
    if (std::regex_search(text, match, price_pattern)) {
        std::cout &lt;&lt; "Full match: " &lt;&lt; match[0] &lt;&lt; std::endl;
        std::cout &lt;&lt; "Captured price: " &lt;&lt; match[1] &lt;&lt; std::endl;
    }
}

void match_extraction2() {
    std::string input = "My phone number is 123-456-7890.";
    std::regex pattern("(\\d{3})-(\\d{3})-(\\d{4})");
    std::smatch match;

    if (std::regex_search(input, match, pattern)) {
        std::cout &lt;&lt; "Area code: " &lt;&lt; match[1].str() &lt;&lt; std::endl;
        std::cout &lt;&lt; "Prefix: " &lt;&lt; match[2].str() &lt;&lt; std::endl;
        std::cout &lt;&lt; "Line number: " &lt;&lt; match[3].str() &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; "Match not found." &lt;&lt; std::endl;
    }
}
</code></pre>
<blockquote>
<p>multiple matching</p>
</blockquote>
<pre><code class="language-c++">void multiple_match() {
    std::cout &lt;&lt; "\n--- Multiple Matches ---\n";

    std::string text = "Contacts: john@email.com, jane@email.com, bob@email.com";
    std::regex email_pattern(R"([\w.]+@[\w.]+\.\w+)");

    // Find all matches
    auto words_begin = std::sregex_iterator(text.begin(), text.end(), email_pattern);
    auto words_end = std::sregex_iterator();

    std::cout &lt;&lt; "Found " &lt;&lt; std::distance(words_begin, words_end) &lt;&lt; " emails:\n";
    for (std::sregex_iterator i = words_begin; i != words_end; ++i) {
        std::smatch match = *i;
        std::cout &lt;&lt; match.str() &lt;&lt; std::endl;
    }
}

void multiple_match_iter() {
    std::string input = "apple banana apple orange apple";
    std::regex pattern("apple");

    for (std::sregex_iterator it(input.begin(), input.end(), pattern), end_it; it != end_it; ++it) {
        std::smatch match = *it;
        std::cout &lt;&lt; "Match found at position: " &lt;&lt; match.position() &lt;&lt; std::endl;
        std::cout &lt;&lt; "Matched string: " &lt;&lt; match.str() &lt;&lt; std::endl;
    }
}

</code></pre>
<blockquote>
<p>replacement</p>
</blockquote>
<pre><code class="language-c++">
void replacement() {
    std::cout &lt;&lt; "\n--- Replacement ---\n";

    std::string text = "The phone number is 123-456-7890";
    std::regex phone_pattern(R"((\d{3})-(\d{3})-(\d{4}))");

    // Replace with reformatted number
    std::string formatted = std::regex_replace(text, phone_pattern, "($1) $2-$3");
    std::cout &lt;&lt; "Original: " &lt;&lt; text &lt;&lt; std::endl;
    std::cout &lt;&lt; "Formatted: " &lt;&lt; formatted &lt;&lt; std::endl;
}

void replacement2() {
    std::string input = "Replace all apples with oranges.";
    std::regex pattern("apple");
    std::string replacement = "orange";

    std::string result = std::regex_replace(input, pattern, replacement);
    std::cout &lt;&lt; "Result: " &lt;&lt; result &lt;&lt; std::endl;
}
</code></pre>
<blockquote>
<p>others</p>
</blockquote>
<pre><code class="language-c++">    void others() {
        std::cout &lt;&lt; "\n--- Advanced Patterns ---\n";

        // Validate complex password
        std::regex password_pattern(
            R"(^(?=.*[A-Z])(?=.*[a-z])(?=.*\d)(?=.*[!@#$%^&amp;*])[\w!@#$%^&amp;*]{8,}$)"
        );

        std::vector&lt;std::string&gt; passwords = {
            "weakpass",
            "StrongPass123!",
            "NoSpecialChar123"
        };

        for (const auto&amp; pass : passwords) {
            bool is_valid = std::regex_match(pass, password_pattern);
            std::cout &lt;&lt; "Password '" &lt;&lt; pass &lt;&lt; "' is "
                      &lt;&lt; (is_valid ? "valid" : "invalid") &lt;&lt; std::endl;
        }
    }

</code></pre>
<blockquote>
<p>case insensitive</p>
</blockquote>
<pre><code class="language-c++">    void case_insensitive() {
        std::cout &lt;&lt; "\n--- Case-Insensitive Matching ---\n";

        std::string text = "Hello, World!";
        // Case-insensitive match
        std::regex pattern("hello", std::regex_constants::icase);

        if (std::regex_search(text, pattern)) {
            std::cout &lt;&lt; "Case-insensitive match found\n";
        }
    }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-stdapply-stdinvoke-and-stdinvoke_r"><a class="header" href="#use-stdapply-stdinvoke-and-stdinvoke_r">use std::apply, std::invoke and std::invoke_r</a></h1>
<p>std::invoke: used with callables (callable, args...)</p>
<p>std::invoke_r: invoke + casting... it casts the result to your passed type</p>
<p>std::apply: used with callables with tuple args ( callable, tuple)</p>
<blockquote>
<p>invoke</p>
</blockquote>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;functional&gt;

struct MyClass {
    int add(int a, int b) { return a + b; }
};

int main() {
    auto lambda = [](int a, int b) { return a * b; };
    MyClass obj;

    std::cout &lt;&lt; std::invoke(lambda, 5, 3) &lt;&lt; std::endl; // Output: 15
    std::cout &lt;&lt; std::invoke(&amp;MyClass::add, obj, 5, 3) &lt;&lt; std::endl; // Output: 8

    return 0;
}

</code></pre>
<blockquote>
<p>apply</p>
</blockquote>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;tuple&gt;
#include &lt;functional&gt;

int multiply(int a, int b) { return a * b; }

int main() {
    std::tuple&lt;int, int&gt; args(5, 3);
    std::cout &lt;&lt; std::apply(multiply, args) &lt;&lt; std::endl; // Output: 15

    auto lambda = [](int a, int b, int c){return a + b + c;};
    std::tuple&lt;int, int, int&gt; args2(1,2,3);
    std::cout &lt;&lt; std::apply(lambda, args2) &lt;&lt; std::endl; // output: 6

    return 0;
}
</code></pre>
<blockquote>
<p>invoke_r</p>
</blockquote>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;functional&gt;

double divide(int a, int b) { return static_cast&lt;double&gt;(a) / b; }

int main() {
    int result = std::invoke_r&lt;int&gt;(divide, 10, 3); // Convert double to int
    std::cout &lt;&lt; result &lt;&lt; std::endl; // Output: 3

    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-std-distributions-to-generate-data"><a class="header" href="#use-std-distributions-to-generate-data">use std distributions to generate data</a></h1>
<p>in &lt;random&gt; header we can find some distribution methods which can give us random - ranged data to use especially while testing.</p>
<p>distributions:</p>
<pre><code class="language-c++">
std::uniform_int_distribution&lt;int&gt; distribution(1, 10); // Generates integers between 1 and 10

std::uniform_real_distribution&lt;double&gt; distribution(0.0, 1.0); // Generates doubles between 0.0 and 1.0

std::normal_distribution&lt;double&gt; distribution(0.0, 1.0); // Mean 0, standard deviation 1

std::binomial_distribution&lt;int&gt; distribution(10, 0.5); // 10 trials, 50% probability

std::poisson_distribution&lt;int&gt; distribution(5.0); // Mean 5

</code></pre>
<p>how to use them ?</p>
<pre><code class="language-c++">
std::mt19937 rng(std::random_device{}()); // Seed with a non-deterministic random value

</code></pre>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;random&gt;

int main() {
    std::mt19937 rng(std::random_device{}());
    std::uniform_int_distribution&lt;int&gt; distribution(1, 10);

    for (int i = 0; i &lt; 10; ++i) {
        std::cout &lt;&lt; distribution(rng) &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;

    return 0;
}

</code></pre>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;random&gt;

int main() {
    std::mt19937 rng(std::random_device{}());
    std::uniform_real_distribution&lt;double&gt; distribution(0.0, 1.0);

    for (int i = 0; i &lt; 10; ++i) {
        std::cout &lt;&lt; distribution(rng) &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;random&gt;

int main() {
    std::random_device rd;  // Seed generator
    std::mt19937 gen(rd()); // Mersenne Twister engine
    std::normal_distribution&lt;&gt; dist(0, 1); // Normal distribution with mean 0 and standard deviation 1

    for (int i = 0; i &lt; 10; ++i) {
        std::cout &lt;&lt; dist(gen) &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-bitwise-operations"><a class="header" href="#use-bitwise-operations">use bitwise operations</a></h1>
<h2 id="basic-bitwise-operators"><a class="header" href="#basic-bitwise-operators">Basic Bitwise Operators</a></h2>
<ul>
<li>
<p>AND (&amp;): Sets bit to 1 if both bits are 1.</p>
</li>
<li>
<p>OR (|): Sets bit to 1 if one of the bits is 1.</p>
</li>
<li>
<p>XOR (^): Sets bit to 1 if only one of the bits is 1.</p>
</li>
</ul>
<p>-NOT (~): Inverts all the bits.</p>
<ul>
<li>Left Shift (&lt;&lt;): Shifts bits to the left, filling with zeros.</li>
</ul>
<p>-Right Shift (&gt;&gt;): Shifts bits to the right, filling with the sign bit (for signed integers) or zeros (for unsigned integers).</p>
<blockquote>
<p>checking</p>
</blockquote>
<pre><code class="language-c++">
#include &lt;iostream&gt;

int main() {
    int value = 10; // Binary: 1010
    int bitToCheck = 1; // Check the 2nd bit (from right)

    if (value &amp; (1 &lt;&lt; bitToCheck)) {
        std::cout &lt;&lt; "Bit " &lt;&lt; bitToCheck &lt;&lt; " is set." &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; "Bit " &lt;&lt; bitToCheck &lt;&lt; " is not set." &lt;&lt; std::endl;
    }
    return 0;
}

</code></pre>
<blockquote>
<p>setting</p>
</blockquote>
<pre><code class="language-c++">#include &lt;iostream&gt;

int main() {
    int value = 5; // Binary: 0101
    int bitToSet = 2; // Set the 3rd bit

    value |= (1 &lt;&lt; bitToSet);
    std::cout &lt;&lt; "Value after setting bit: " &lt;&lt; value &lt;&lt; std::endl; // Output: 9 (1001)
    return 0;
}

</code></pre>
<blockquote>
<p>clearing</p>
</blockquote>
<pre><code class="language-c++">
#include &lt;iostream&gt;

int main() {
    int value = 13; // Binary: 1101
    int bitToClear = 2; // Clear the 3rd bit

    value &amp;= ~(1 &lt;&lt; bitToClear);
    std::cout &lt;&lt; "Value after clearing bit: " &lt;&lt; value &lt;&lt; std::endl; // Output: 9 (1001)
    return 0;
}
</code></pre>
<blockquote>
<p>toggling</p>
</blockquote>
<pre><code class="language-c++">
#include &lt;iostream&gt;

int main() {
    int value = 7; // Binary: 0111
    int bitToToggle = 1; // Toggle the 2nd bit

    value ^= (1 &lt;&lt; bitToToggle);
    std::cout &lt;&lt; "Value after toggling bit: " &lt;&lt; value &lt;&lt; std::endl; // Output: 5 (0101)
    return 0;
}

</code></pre>
<blockquote>
<p>using bitmasks</p>
</blockquote>
<pre><code class="language-c++">#include &lt;iostream&gt;

int main() {
    int flags = 0b0110; // Example flags (binary literal)
    int mask = 0b0010; // Mask for the 2nd bit

    if (flags &amp; mask) {
        std::cout &lt;&lt; "Flag is set." &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; "Flag is not set." &lt;&lt; std::endl;
    }
    return 0;
}
</code></pre>
<blockquote>
<p>multiplying or dividing by pow of 2</p>
</blockquote>
<pre><code class="language-c++">#include &lt;iostream&gt;

int main() {
    int value = 5;

    int multiplied = value &lt;&lt; 2; // Multiply by 2^2 (4)
    int divided = value &gt;&gt; 1; // Divide by 2^1 (2)

    std::cout &lt;&lt; "Multiplied: " &lt;&lt; multiplied &lt;&lt; std::endl; // Output: 20
    std::cout &lt;&lt; "Divided: " &lt;&lt; divided &lt;&lt; std::endl; // Output: 2
    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-pmr-with-stack-memory"><a class="header" href="#use-pmr-with-stack-memory">use pmr with stack memory</a></h1>
<p>pmr is a good tool to use different memory resources. it's a tool to run away default memory allocators std is using...</p>
<blockquote>
<p>a general example show a complete usage</p>
</blockquote>
<pre><code class="language-c++">
#include &lt;memory_resource&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;array&gt;

class StackMemoryResource {
public:
    // Create a stack-based memory resource with a fixed buffer
    template&lt;size_t BufferSize&gt;
    static std::pmr::monotonic_buffer_resource CreateStackResource() {
        // Static buffer allocated on the stack
        static std::array&lt;std::byte, BufferSize&gt; buffer;

        // Create a monotonic buffer resource using the stack buffer
        return std::pmr::monotonic_buffer_resource(
            buffer.data(),   // Pointer to buffer start
            buffer.size(),   // Buffer size
            std::pmr::null_memory_resource() // No upstream resource -&gt; stops using heap if not enough
        );
    }

    // Example function using stack-based memory resource
    static void DemonstrateStackAllocation() {
        // Create a 1024-byte stack-based memory resource
        auto stack_resource = CreateStackResource&lt;1024&gt;();

        // Create a vector using the stack memory resource
        std::pmr::vector&lt;int&gt; stack_vector{&amp;stack_resource};

        // Add elements (will allocate from stack buffer)
        for (int i = 0; i &lt; 100; ++i) {
            stack_vector.push_back(i);
        }

        // Print vector contents
        for (int val : stack_vector) {
            std::cout &lt;&lt; val &lt;&lt; " ";
        }
        std::cout &lt;&lt; std::endl;
    }

    // Demonstrate different types of allocation
    static void MultipleAllocations() {
        // Create a 2048-byte stack resource
        auto stack_resource = CreateStackResource&lt;2048&gt;();

        // Allocate different types using the same stack resource
        std::pmr::vector&lt;char&gt; char_vector{&amp;stack_resource};
        std::pmr::vector&lt;double&gt; double_vector{&amp;stack_resource};

        char_vector.resize(100);
        double_vector.resize(50);
    }
};

int main() {
    // Demonstrate stack-based memory resource usage
    StackMemoryResource::DemonstrateStackAllocation();
    StackMemoryResource::MultipleAllocations();

    return 0;
}
</code></pre>
<blockquote>
<p>using pmr::vector like heap usage</p>
</blockquote>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;memory_resource&gt;
#include &lt;vector&gt;
#include &lt;array&gt;

int main() {
    std::array&lt;std::byte, 1024&gt; buffer;
    std::pmr::monotonic_buffer_resource resource(buffer.data(), buffer.size());

    // Use a pmr vector with the stack-based memory resource
    std::pmr::vector&lt;int&gt; numbers({1, 2, 3, 4, 5}, &amp;resource);

    for (int num : numbers) {
        std::cout &lt;&lt; num &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;

    return 0;
}

</code></pre>
<blockquote>
<p>direct allocation</p>
</blockquote>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;memory_resource&gt;
#include &lt;array&gt;

int main() {
    std::array&lt;std::byte, 1024&gt; buffer;
    std::pmr::monotonic_buffer_resource resource(buffer.data(), buffer.size());

    // Allocate memory from the stack buffer
    int* ptr = static_cast&lt;int*&gt;(resource.allocate(sizeof(int)));
    *ptr = 42;

    std::cout &lt;&lt; *ptr &lt;&lt; std::endl;

    // Deallocate memory (optional with monotonic_buffer_resource)
    resource.deallocate(ptr, sizeof(int));

    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-uninitialized-memory-methods"><a class="header" href="#use-uninitialized-memory-methods">use uninitialized memory methods</a></h1>
<p>when you need uninitialized memory ops ?</p>
<ul>
<li>
<p>working with placement new</p>
</li>
<li>
<p>custom allocators are used</p>
</li>
<li>
<p>managing raw memory with not classic tools</p>
</li>
</ul>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;ranges&gt;

int main() {
    std::vector&lt;int&gt; src = {1, 2, 3, 4, 5};
    std::vector&lt;int&gt; dest(src.size());

    std::uninitialized_copy(src.begin(), src.end(), dest.begin());

    for (int n : dest) {
        std::cout &lt;&lt; n &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;

    return 0;
}

</code></pre>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;ranges&gt;

int main() {
    std::vector&lt;int&gt; vec(5);

    std::uninitialized_fill(vec.begin(), vec.end(), 42);

    for (int n : vec) {
        std::cout &lt;&lt; n &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;

    return 0;
}

</code></pre>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;ranges&gt;

int main() {
    std::vector&lt;int&gt; src = {1, 2, 3, 4, 5};
    std::vector&lt;int&gt; dest(src.size());

    std::uninitialized_move(src.begin(), src.end(), dest.begin());

    for (int n : dest) {
        std::cout &lt;&lt; n &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;

    return 0;
}

</code></pre>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;ranges&gt;

int main() {
    std::vector&lt;int&gt; vec(5);

    std::uninitialized_default_construct(vec.begin(), vec.end());

    for (int n : vec) {
        std::cout &lt;&lt; n &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;

    return 0;
}

</code></pre>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;ranges&gt;

int main() {
    std::vector&lt;int&gt; vec(5);

    std::uninitialized_value_construct(vec.begin(), vec.end());

    for (int n : vec) {
        std::cout &lt;&lt; n &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;

    return 0;
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-std-concepts"><a class="header" href="#use-std-concepts">use std concepts</a></h1>
<p>concepts are guards of classes and functions. type-checking is easier than before. It replaces SFINAE. <code>constraints</code> on template params is a strong method for guarding.</p>
<ul>
<li>
<p>stronger type checking</p>
</li>
<li>
<p>better compiler error messages</p>
</li>
<li>
<p>compile time type checking</p>
</li>
</ul>
<p>simple examples:</p>
<pre><code class="language-c++">template &lt;typename T&gt;
concept Addable = requires(T a, T b) {
    { a + b } -&gt; std::convertible_to&lt;T&gt;; // Expression must be valid and convertible to T
};

// Using concept-name syntax:
template &lt;Addable T&gt;
T add(T a, T b) {
    return a + b;
}

// Using requires clause:
template &lt;typename T&gt;
    requires Addable&lt;T&gt;
T add(T a, T b) {
    return a + b;
}

auto generic_add = [](Addable auto a, Addable auto b) {
    return a + b;
};

template &lt;typename T&gt;
concept Numeric = std::integral&lt;T&gt; || std::floating_point&lt;T&gt;;

template &lt;typename T&gt;
    requires Numeric&lt;T&gt;
T square(T value) {
    return value * value;
}

</code></pre>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;concepts&gt;

template &lt;std::integral T&gt;
T factorial(T n) {
    if (n &lt;= 1) {
        return 1;
    }
    return n * factorial(n - 1);
}

int main() {
    std::cout &lt;&lt; factorial(5) &lt;&lt; std::endl; // Output: 120
    // std::cout &lt;&lt; factorial(5.5) &lt;&lt; std::endl; // Error: 5.5 is not an integral type
    return 0;
}

</code></pre>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;concepts&gt;

template &lt;typename T&gt;
concept Comparable = requires(T a, T b) {
    { a &lt; b } -&gt; std::convertible_to&lt;bool&gt;;
    { a &gt; b } -&gt; std::convertible_to&lt;bool&gt;;
};

template &lt;Comparable T&gt;
bool is_greater(T a, T b) {
    return a &gt; b;
}

int main() {
    std::cout &lt;&lt; std::boolalpha;
    std::cout &lt;&lt; is_greater(10, 5) &lt;&lt; std::endl; // Output: true
    std::cout &lt;&lt; is_greater('a', 'b') &lt;&lt; std::endl; // Output: false
    // std::cout &lt;&lt; is_greater("hello", 5); // Error: "hello" is not Comparable with int
    return 0;
}
</code></pre>
<p>a full example:</p>
<pre><code class="language-c++">
#include &lt;concepts&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;type_traits&gt;

// Basic concept definition
template&lt;typename T&gt;
concept Printable = requires(T x) {
    { std::cout &lt;&lt; x } -&gt; std::same_as&lt;std::ostream&amp;&gt;;
};

// Numeric concept
template&lt;typename T&gt;
concept Numeric = std::integral&lt;T&gt; || std::floating_point&lt;T&gt;;

// Container concept
template&lt;typename T&gt;
concept Container = requires(T a) {
    { a.begin() } -&gt; std::input_or_output_iterator;
    { a.end() } -&gt; std::input_or_output_iterator;
    { a.size() } -&gt; std::convertible_to&lt;std::size_t&gt;;
};

// Advanced composite concept
template&lt;typename T&gt;
concept ComparableContainer = Container&lt;T&gt; &amp;&amp;
    requires(T a) {
        { std::begin(a) != std::end(a) } -&gt; std::convertible_to&lt;bool&gt;;
    };

class ConceptDemonstrator {
public:
    // Function using a simple concept
    template&lt;Printable T&gt;
    static void printAnything(const T&amp; value) {
        std::cout &lt;&lt; "Printable value: " &lt;&lt; value &lt;&lt; std::endl;
    }

    // Function with numeric concept
    template&lt;Numeric T&gt;
    static T add(T a, T b) {
        return a + b;
    }

    // Function with container concept
    template&lt;Container T&gt;
    static void demonstrateContainer(const T&amp; container) {
        std::cout &lt;&lt; "Container size: " &lt;&lt; container.size() &lt;&lt; std::endl;
        for (const auto&amp; item : container) {
            std::cout &lt;&lt; item &lt;&lt; " ";
        }
        std::cout &lt;&lt; std::endl;
    }

    // Constrained class template
    template&lt;Numeric T&gt;
    class NumericWrapper {
    private:
        T value;
    public:
        NumericWrapper(T val) : value(val) {}
        T getValue() const { return value; }
    };

    // Requires clause with multiple constraints
    template&lt;typename T&gt;
    requires Printable&lt;T&gt; &amp;&amp; std::default_constructible&lt;T&gt;
    static void advancedFunction(T&amp; obj) {
        T newObj{};  // Guaranteed default constructible
        std::cout &lt;&lt; "Advanced function with printable object" &lt;&lt; std::endl;
    }

    // Requires expression with more complex constraints
    template&lt;typename T&gt;
    static void complexConstraints() requires
        requires(T x) {
            { T{} } -&gt; std::same_as&lt;T&gt;;  // Must be default constructible
            { x + x } -&gt; std::convertible_to&lt;T&gt;;  // Must support addition
        }
    {
        std::cout &lt;&lt; "Complex constraints satisfied" &lt;&lt; std::endl;
    }
};

// Concept-based function overloading
void processValue(Numeric auto value) {
    std::cout &lt;&lt; "Numeric value: " &lt;&lt; value &lt;&lt; std::endl;
}

void processValue(const std::string&amp; value) {
    std::cout &lt;&lt; "String value: " &lt;&lt; value &lt;&lt; std::endl;
}

int main() {
    // Demonstration of various concept usages
    ConceptDemonstrator::printAnything(42);
    ConceptDemonstrator::printAnything(std::string("Hello"));

    std::cout &lt;&lt; "Numeric addition: "
              &lt;&lt; ConceptDemonstrator::add(10, 20) &lt;&lt; std::endl;

    std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};
    ConceptDemonstrator::demonstrateContainer(vec);

    // Concept-based class template instantiation
    ConceptDemonstrator::NumericWrapper&lt;int&gt; numWrapper(100);

    // Function overloading with concepts
    processValue(42);
    processValue("String");

    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-va_opt-and-va_args-together"><a class="header" href="#use-va_opt-and-va_args-together">use VA_OPT and VA_ARGS together</a></h1>
<p>in c macros; <strong>VA_ARGS</strong> used to pass <code>...</code> to macro definition</p>
<pre><code class="language-c++">#define FUNC(...) func(__VA_ARGS__)
</code></pre>
<p>if we need some optionals like <code>,</code> we can use <code>__VA_OPT__(,)</code> to place them</p>
<blockquote>
<p>If <strong>VA_OPT</strong> is not used, pack will not be expanded correctly</p>
</blockquote>
<pre><code class="language-c++">
#define FUNC(X, ...) func(X, __VA_ARGS__)o

FUNC(1,2,3) =&gt; func(1,2,3)
FUNC(1) =&gt; failed

#define FUNC(X, ...) func(X _VA_OPT__(,) __VA_ARGS__)

FUNC(1,2,3) =&gt; func(1,2,3)
FUNC(1) =&gt; func(1)

</code></pre>
<pre><code class="language-c++">#define PRINT(...) printf(__VA_ARGS__)

#define LOG(format, ...) printf(format __VA_OPT__(, ) __VA_ARGS__)

#define DEBUG_LOG(format, ...)                                                 \
    printf("DEBUG: " format __VA_OPT__(, ) __VA_ARGS__)

int main() {
    PRINT("%s %s\n", "hakan", "gedek");
    PRINT("%d %d\n", 1, 2);
    PRINT("");

    LOG("%s %s\n", "hakan", "gedek");
    LOG("%d %d\n", 1, 2);
    LOG("");

    DEBUG_LOG("%s %s\n", "hakan", "gedek");
    DEBUG_LOG("%d %d\n", 1, 2);
    DEBUG_LOG("");
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design-builder-pattern"><a class="header" href="#design-builder-pattern">design builder pattern</a></h1>
<p>there are multiple ways of implementing builder pattern. inheritance and own builder type.</p>
<blockquote>
<p>all pattern examples are ai generated solutions</p>
</blockquote>
<p>using rvalue functions...</p>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

class Product {
   public:
    class Builder;  // Forward declaration

    void display() const {
        std::cout &lt;&lt; "Product Details:\n";
        std::cout &lt;&lt; "Name: " &lt;&lt; name &lt;&lt; "\n";
        std::cout &lt;&lt; "Price: $" &lt;&lt; price &lt;&lt; "\n";

        std::cout &lt;&lt; "Features:\n";
        for (const auto&amp; feature : features) {
            std::cout &lt;&lt; "- " &lt;&lt; feature &lt;&lt; "\n";
        }

        std::cout &lt;&lt; "Variants:\n";
        for (const auto&amp; variant : variants) {
            std::cout &lt;&lt; "- " &lt;&lt; variant &lt;&lt; "\n";
        }
    }

   private:
    friend class Builder;
    std::string name;
    double price = 0.0;
    std::vector&lt;std::string&gt; features;
    std::vector&lt;std::string&gt; variants;
};

// Rvalue Reference Builder Implementation
class Product::Builder {
   public:
    // Rvalue reference methods for efficient move semantics
    Builder&amp;&amp; name(std::string&amp;&amp; productName) &amp;&amp; {
        product.name = std::move(productName);
        return std::move(*this);
    }

    Builder&amp;&amp; price(double productPrice) &amp;&amp; {
        product.price = productPrice;
        return std::move(*this);
    }

    Builder&amp;&amp; addFeature(std::string&amp;&amp; feature) &amp;&amp; {
        product.features.push_back(std::move(feature));
        return std::move(*this);
    }

    Builder&amp;&amp; addVariant(std::string&amp;&amp; variant) &amp;&amp; {
        product.variants.push_back(std::move(variant));
        return std::move(*this);
    }

    // Rvalue reference build method
    Product build() &amp;&amp; { return std::move(product); }

   private:
    Product product;
};

int main() {
    // Rvalue Reference Builder Usage
    auto product = Product::Builder()
                       .name("SmartPhone")
                       .price(599.99)
                       .addFeature("5G Support")
                       .addFeature("Quad Camera")
                       .addVariant("Black")
                       .addVariant("White")
                       .build();

    product.display();
}

```


```c++

#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;memory&gt;
#include &lt;vector&gt;
#include &lt;optional&gt;

class Pizza {
public:
    class Builder;  // Forward declaration

    void display() const {
        std::cout &lt;&lt; "Pizza Details:\n";
        std::cout &lt;&lt; "Size: " &lt;&lt; size &lt;&lt; "\n";
        std::cout &lt;&lt; "Cheese: " &lt;&lt; (hasCheese ? "Yes" : "No") &lt;&lt; "\n";
        std::cout &lt;&lt; "Toppings:\n";
        for (const auto&amp; topping : toppings) {
            std::cout &lt;&lt; "- " &lt;&lt; topping &lt;&lt; "\n";
        }
    }

private:
    friend class Builder;
    std::string size = "Medium";
    bool hasCheese = false;
    std::vector&lt;std::string&gt; toppings;
};

// Builder nested within Pizza class
class Pizza::Builder {
public:
    Builder&amp; setSize(const std::string&amp; newSize) {
        pizza.size = newSize;
        return *this;
    }

    Builder&amp; addCheese() {
        pizza.hasCheese = true;
        return *this;
    }

    Builder&amp; addTopping(const std::string&amp; topping) {
        pizza.toppings.push_back(topping);
        return *this;
    }

    Pizza build() {
        return std::move(pizza);
    }

private:
    Pizza pizza;
};

// Fluent Builder with Inheritance
class Burger {
public:
    class Builder;
    virtual ~Burger() = default;

    virtual void display() const {
        std::cout &lt;&lt; "Burger Details:\n";
        std::cout &lt;&lt; "Size: " &lt;&lt; size &lt;&lt; "\n";
        std::cout &lt;&lt; "Type: " &lt;&lt; type &lt;&lt; "\n";
        std::cout &lt;&lt; "Extras: " &lt;&lt; extras &lt;&lt; "\n";
    }

protected:
    std::string size = "Medium";
    std::string type = "Classic";
    std::string extras;
};

class Burger::Builder {
public:
    virtual Builder&amp; setSize(const std::string&amp; newSize) {
        burger.size = newSize;
        return *this;
    }

    virtual Builder&amp; setType(const std::string&amp; newType) {
        burger.type = newType;
        return *this;
    }

    virtual Builder&amp; addExtras(const std::string&amp; newExtras) {
        burger.extras = newExtras;
        return *this;
    }

    virtual std::unique_ptr&lt;Burger&gt; build() {
        return std::make_unique&lt;Burger&gt;(std::move(burger));
    }

protected:
    Burger burger;
};

// Advanced Builder with Director
class House {
public:
    class Builder;

    void display() const {
        std::cout &lt;&lt; "House Details:\n";
        std::cout &lt;&lt; "Walls: " &lt;&lt; wallType &lt;&lt; "\n";
        std::cout &lt;&lt; "Doors: " &lt;&lt; doorType &lt;&lt; "\n";
        std::cout &lt;&lt; "Windows: " &lt;&lt; windowType &lt;&lt; "\n";
        std::cout &lt;&lt; "Garage: " &lt;&lt; (hasGarage ? "Yes" : "No") &lt;&lt; "\n";
    }

private:
    friend class Builder;
    std::string wallType = "Brick";
    std::string doorType = "Wood";
    std::string windowType = "Glass";
    bool hasGarage = false;
};

class House::Builder {
public:
    Builder&amp; setWallType(const std::string&amp; type) {
        house.wallType = type;
        return *this;
    }

    Builder&amp; setDoorType(const std::string&amp; type) {
        house.doorType = type;
        return *this;
    }

    Builder&amp; setWindowType(const std::string&amp; type) {
        house.windowType = type;
        return *this;
    }

    Builder&amp; addGarage() {
        house.hasGarage = true;
        return *this;
    }

    House build() {
        return std::move(house);
    }

private:
    House house;
};

// House Director
class HouseDirector {
public:
    static House buildLuxuryHouse(House::Builder&amp; builder) {
        return builder
            .setWallType("Marble")
            .setDoorType("Mahogany")
            .setWindowType("Double-Glazed")
            .addGarage()
            .build();
    }

    static House buildSimpleHouse(House::Builder&amp; builder) {
        return builder
            .setWallType("Concrete")
            .setDoorType("Steel")
            .build();
    }
};

// Modern C++20 Concept-Based Builder
template&lt;typename T&gt;
concept BuilderConcept = requires(T builder) {
    { builder.build() } -&gt; std::convertible_to&lt;House&gt;;
};

int main() {
    // Traditional Builder Usage
    auto pizza = Pizza::Builder()
        .setSize("Large")
        .addCheese()
        .addTopping("Pepperoni")
        .addTopping("Mushrooms")
        .build();
    pizza.display();

    // Fluent Builder with Inheritance
    auto burger = Burger::Builder()
        .setSize("Large")
        .setType("Veggie")
        .addExtras("Extra Sauce")
        .build();
    burger-&gt;display();

    // House Builder with Director
    House::Builder houseBuilder;
    auto luxuryHouse = HouseDirector::buildLuxuryHouse(houseBuilder);
    luxuryHouse.display();

    auto simpleHouse = HouseDirector::buildSimpleHouse(houseBuilder);
    simpleHouse.display();

    return 0;
}

</code></pre>
<h2 id="using-inheritance"><a class="header" href="#using-inheritance">Using inheritance</a></h2>
<pre><code class="language-c++">
class Product {
public:
    void setPartA(const std::string&amp; partA) { partA_ = partA; }
    void setPartB(const std::string&amp; partB) { partB_ = partB; }
    void setPartC(const std::string&amp; partC) { partC_ = partC; }

    void show() const {
        std::cout &lt;&lt; "PartA: " &lt;&lt; partA_ &lt;&lt; "\n"
                  &lt;&lt; "PartB: " &lt;&lt; partB_ &lt;&lt; "\n"
                  &lt;&lt; "PartC: " &lt;&lt; partC_ &lt;&lt; "\n";
    }

private:
    std::string partA_;
    std::string partB_;
    std::string partC_;
};


class Builder {
public:
    virtual ~Builder() = default;
    virtual void buildPartA() = 0;
    virtual void buildPartB() = 0;
    virtual void buildPartC() = 0;
    virtual Product* getResult() = 0;
};


class ConcreteBuilder : public Builder {
public:
    ConcreteBuilder() { product_ = new Product(); }
    ~ConcreteBuilder() { delete product_; }

    void buildPartA() override { product_-&gt;setPartA("PartA1"); }
    void buildPartB() override { product_-&gt;setPartB("PartB1"); }
    void buildPartC() override { product_-&gt;setPartC("PartC1"); }

    Product* getResult() override {
        Product* result = product_;
        product_ = new Product(); // Reset for next build
        return result;
    }

private:
    Product* product_;
};


class Director {
public:
    void setBuilder(Builder* builder) { builder_ = builder; }

    void construct() {
        builder_-&gt;buildPartA();
        builder_-&gt;buildPartB();
        builder_-&gt;buildPartC();
    }

private:
    Builder* builder_;
};

int main() {
    Director director;
    ConcreteBuilder builder;

    director.setBuilder(&amp;builder);
    director.construct();

    Product* product = builder.getResult();
    product-&gt;show();

    delete product;
    return 0;
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design-factory-method-pattern"><a class="header" href="#design-factory-method-pattern">design factory method pattern</a></h1>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;unordered_map&gt;
#include &lt;functional&gt;
#include &lt;stdexcept&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

// Base Product Interface
class Vehicle {
public:
    virtual void start() = 0;
    virtual void stop() = 0;
    virtual ~Vehicle() = default;
};

// Concrete Products
class Car : public Vehicle {
public:
    void start() override {
        std::cout &lt;&lt; "Car started. Vroom!" &lt;&lt; std::endl;
    }

    void stop() override {
        std::cout &lt;&lt; "Car stopped." &lt;&lt; std::endl;
    }
};

class Motorcycle : public Vehicle {
public:
    void start() override {
        std::cout &lt;&lt; "Motorcycle started. Roar!" &lt;&lt; std::endl;
    }

    void stop() override {
        std::cout &lt;&lt; "Motorcycle stopped." &lt;&lt; std::endl;
    }
};

class Truck : public Vehicle {
public:
    void start() override {
        std::cout &lt;&lt; "Truck started. Rumble!" &lt;&lt; std::endl;
    }

    void stop() override {
        std::cout &lt;&lt; "Truck stopped." &lt;&lt; std::endl;
    }
};

// Classic Factory Method Pattern
class VehicleFactory {
public:
    // Pure virtual factory method
    virtual std::unique_ptr&lt;Vehicle&gt; createVehicle() = 0;
    virtual ~VehicleFactory() = default;
};

class CarFactory : public VehicleFactory {
public:
    std::unique_ptr&lt;Vehicle&gt; createVehicle() override {
        return std::make_unique&lt;Car&gt;();
    }
};

class MotorcycleFactory : public VehicleFactory {
public:
    std::unique_ptr&lt;Vehicle&gt; createVehicle() override {
        return std::make_unique&lt;Motorcycle&gt;();
    }
};

class TruckFactory : public VehicleFactory {
public:
    std::unique_ptr&lt;Vehicle&gt; createVehicle() override {
        return std::make_unique&lt;Truck&gt;();
    }
};

// Static Factory Method
class StaticVehicleFactory {
public:
    enum class VehicleType {
        Car,
        Motorcycle,
        Truck
    };

    static std::unique_ptr&lt;Vehicle&gt; createVehicle(VehicleType type) {
        switch (type) {
            case VehicleType::Car:
                return std::make_unique&lt;Car&gt;();
            case VehicleType::Motorcycle:
                return std::make_unique&lt;Motorcycle&gt;();
            case VehicleType::Truck:
                return std::make_unique&lt;Truck&gt;();
            default:
                throw std::invalid_argument("Unknown vehicle type");
        }
    }
};

// Modern C++: Template Factory Method
template&lt;typename ProductBase, typename... Factories&gt;
class TemplateFactory {
public:
    template&lt;typename FactoryType&gt;
    static std::unique_ptr&lt;ProductBase&gt; create() {
        return std::make_unique&lt;FactoryType&gt;();
    }

    // Compile-time factory selection
    template&lt;typename FactoryType&gt;
    static bool isValidFactory() {
        return std::is_base_of_v&lt;ProductBase, FactoryType&gt;;
    }
};

// Advanced Factory with Registration Mechanism
class AbstractProductFactory {
public:
    using CreatorFunc = std::function&lt;std::unique_ptr&lt;Vehicle&gt;()&gt;;

    // Singleton-like registration mechanism
    static void registerProduct(const std::string&amp; key, CreatorFunc creator) {
        getRegistry()[key] = creator;
    }

    static std::unique_ptr&lt;Vehicle&gt; createProduct(const std::string&amp; key) {
        auto&amp; registry = getRegistry();
        auto it = registry.find(key);
        if (it != registry.end()) {
            return it-&gt;second();
        }
        throw std::runtime_error("Unknown product type");
    }

private:
    // Thread-safe singleton registry
    static std::unordered_map&lt;std::string, CreatorFunc&gt;&amp; getRegistry() {
        static std::unordered_map&lt;std::string, CreatorFunc&gt; registry;
        return registry;
    }
};

// Product Registration Helpers
class ProductRegistrar {
public:
    ProductRegistrar(const std::string&amp; key, AbstractProductFactory::CreatorFunc creator) {
        AbstractProductFactory::registerProduct(key, creator);
    }
};

// Macro for easy product registration
#define REGISTER_PRODUCT(Key, ProductType) \
    static ProductRegistrar registrar_##ProductType( \
        Key, []() { return std::make_unique&lt;ProductType&gt;(); } \
    )

int main() {
    // Classic Factory Method
    {
        std::unique_ptr&lt;VehicleFactory&gt; carFactory = std::make_unique&lt;CarFactory&gt;();
        auto car = carFactory-&gt;createVehicle();
        car-&gt;start();
        car-&gt;stop();
    }

    // Static Factory Method
    {
        auto motorcycle = StaticVehicleFactory::createVehicle(
            StaticVehicleFactory::VehicleType::Motorcycle
        );
        motorcycle-&gt;start();
        motorcycle-&gt;stop();
    }

    // Template Factory Method
    {
        auto truck = TemplateFactory&lt;Vehicle, CarFactory, MotorcycleFactory, TruckFactory&gt;
            ::create&lt;TruckFactory&gt;();
        truck-&gt;start();
        truck-&gt;stop();
    }

    // Advanced Registration-Based Factory
    {
        // Register products (typically done at program initialization)
        REGISTER_PRODUCT("car", Car);
        REGISTER_PRODUCT("motorcycle", Motorcycle);
        REGISTER_PRODUCT("truck", Truck);

        // Create products dynamically
        auto registeredCar = AbstractProductFactory::createProduct("car");
        registeredCar-&gt;start();
        registeredCar-&gt;stop();
    }

    return 0;
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design-composite-pattern"><a class="header" href="#design-composite-pattern">design composite pattern</a></h1>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;stdexcept&gt;
#include &lt;functional&gt;

// Base Component Interface
class FileSystemComponent {
public:
    virtual void display(int depth = 0) const = 0;
    virtual void add(std::shared_ptr&lt;FileSystemComponent&gt; component) {
        throw std::runtime_error("Operation not supported");
    }
    virtual void remove(const std::string&amp; name) {
        throw std::runtime_error("Operation not supported");
    }
    virtual std::shared_ptr&lt;FileSystemComponent&gt; getChild(const std::string&amp; name) {
        return nullptr;
    }
    virtual std::string getName() const = 0;
    virtual long getSize() const = 0;

    virtual ~FileSystemComponent() = default;
};

// Leaf Component (File)
class File : public FileSystemComponent {
public:
    File(const std::string&amp; name, long size)
        : name(name), size(size) {}

    void display(int depth = 0) const override {
        std::string indent(depth * 2, ' ');
        std::cout &lt;&lt; indent &lt;&lt; "File: " &lt;&lt; name
                  &lt;&lt; " (Size: " &lt;&lt; size &lt;&lt; " bytes)" &lt;&lt; std::endl;
    }

    std::string getName() const override { return name; }
    long getSize() const override { return size; }

private:
    std::string name;
    long size;
};

// Composite Component (Directory)
class Directory : public FileSystemComponent {
public:
    Directory(const std::string&amp; name) : name(name) {}

    void display(int depth = 0) const override {
        std::string indent(depth * 2, ' ');
        std::cout &lt;&lt; indent &lt;&lt; "Directory: " &lt;&lt; name &lt;&lt; std::endl;

        for (const auto&amp; component : components) {
            component-&gt;display(depth + 1);
        }
    }

    void add(std::shared_ptr&lt;FileSystemComponent&gt; component) override {
        components.push_back(component);
    }

    void remove(const std::string&amp; componentName) override {
        components.erase(
            std::remove_if(components.begin(), components.end(),
                [&amp;componentName](const auto&amp; component) {
                    return component-&gt;getName() == componentName;
                }),
            components.end()
        );
    }

    std::shared_ptr&lt;FileSystemComponent&gt; getChild(const std::string&amp; name) override {
        auto it = std::find_if(components.begin(), components.end(),
            [&amp;name](const auto&amp; component) {
                return component-&gt;getName() == name;
            });

        return (it != components.end()) ? *it : nullptr;
    }

    std::string getName() const override { return name; }

    long getSize() const override {
        long totalSize = 0;
        for (const auto&amp; component : components) {
            totalSize += component-&gt;getSize();
        }
        return totalSize;
    }

private:
    std::string name;
    std::vector&lt;std::shared_ptr&lt;FileSystemComponent&gt;&gt; components;
};

// Advanced Composite with Visitor Pattern
class FileSystemVisitor {
public:
    virtual void visitFile(const File&amp; file) = 0;
    virtual void visitDirectory(const Directory&amp; directory) = 0;
    virtual ~FileSystemVisitor() = default;
};

// Visitor Implementation
class SizeCalculatorVisitor : public FileSystemVisitor {
public:
    void visitFile(const File&amp; file) override {
        totalSize += file.getSize();
    }

    void visitDirectory(const Directory&amp; directory) override {
        // Can add additional directory-level processing if needed
        for (const auto&amp; component : directory.getComponents()) {
            component-&gt;accept(*this);
        }
    }

    long getTotalSize() const { return totalSize; }

private:
    long totalSize = 0;
};

// Extending Base Component with Visitor Support
class FileSystemComponent {
public:
    virtual void accept(FileSystemVisitor&amp; visitor) = 0;
    // ... (previous method declarations)
};

// Updated File and Directory with Visitor Support
class File : public FileSystemComponent {
public:
    void accept(FileSystemVisitor&amp; visitor) override {
        visitor.visitFile(*this);
    }
    // ... (previous implementation)
};

class Directory : public FileSystemComponent {
public:
    void accept(FileSystemVisitor&amp; visitor) override {
        visitor.visitDirectory(*this);
    }

    // Utility method for visitors
    const std::vector&lt;std::shared_ptr&lt;FileSystemComponent&gt;&gt;&amp; getComponents() const {
        return components;
    }
    // ... (previous implementation)
};

// Functional Composite with Lambda Visitors
class FunctionalComposite {
public:
    using VisitorFunc = std::function&lt;void(const FileSystemComponent&amp;)&gt;;

    void traverse(VisitorFunc visitor) const {
        for (const auto&amp; component : components) {
            traverseRecursive(component, visitor);
        }
    }

private:
    void traverseRecursive(
        const std::shared_ptr&lt;FileSystemComponent&gt;&amp; component,
        const VisitorFunc&amp; visitor
    ) const {
        visitor(*component);

        // If it's a directory, recursively visit children
        if (auto directory = std::dynamic_pointer_cast&lt;Directory&gt;(component)) {
            for (const auto&amp; child : directory-&gt;getComponents()) {
                traverseRecursive(child, visitor);
            }
        }
    }

    std::vector&lt;std::shared_ptr&lt;FileSystemComponent&gt;&gt; components;
};

int main() {
    // Create a file system structure
    auto root = std::make_shared&lt;Directory&gt;("Root");

    // Create subdirectories
    auto documents = std::make_shared&lt;Directory&gt;("Documents");
    auto pictures = std::make_shared&lt;Directory&gt;("Pictures");

    // Add files to directories
    documents-&gt;add(std::make_shared&lt;File&gt;("report.docx", 1024));
    documents-&gt;add(std::make_shared&lt;File&gt;("budget.xlsx", 512));

    pictures-&gt;add(std::make_shared&lt;File&gt;("vacation.jpg", 2048));
    pictures-&gt;add(std::make_shared&lt;File&gt;("family.png", 1536));

    // Build file system hierarchy
    root-&gt;add(documents);
    root-&gt;add(pictures);
    root-&gt;add(std::make_shared&lt;File&gt;("readme.txt", 256));

    // Display file system structure
    std::cout &lt;&lt; "File System Structure:" &lt;&lt; std::endl;
    root-&gt;display();

    // Calculate total size using visitor
    SizeCalculatorVisitor sizeVisitor;
    root-&gt;accept(sizeVisitor);
    std::cout &lt;&lt; "\nTotal Size: " &lt;&lt; sizeVisitor.getTotalSize()
              &lt;&lt; " bytes" &lt;&lt; std::endl;

    // Functional composite demonstration
    FunctionalComposite functionalFs;
    functionalFs.traverse([](const FileSystemComponent&amp; component) {
        std::cout &lt;&lt; "Visited: " &lt;&lt; component.getName() &lt;&lt; std::endl;
    });

    return 0;
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design-adapter-pattern"><a class="header" href="#design-adapter-pattern">design adapter pattern</a></h1>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;stdexcept&gt;
#include &lt;functional&gt;

// Legacy Interface (Existing System)
class LegacyRectangle {
public:
    void oldDrawMethod(int x1, int y1, int x2, int y2) {
        std::cout &lt;&lt; "Legacy Rectangle drawn from ("
                  &lt;&lt; x1 &lt;&lt; "," &lt;&lt; y1 &lt;&lt; ") to ("
                  &lt;&lt; x2 &lt;&lt; "," &lt;&lt; y2 &lt;&lt; ")" &lt;&lt; std::endl;
    }
};

// Target Interface (New System)
class Shape {
public:
    virtual void draw() = 0;
    virtual void resize(double factor) = 0;
    virtual ~Shape() = default;
};

// Object Adapter (Composition-based)
class RectangleAdapter : public Shape {
public:
    RectangleAdapter(int x, int y, int width, int height)
        : x(x), y(y), width(width), height(height),
          legacyRectangle(std::make_unique&lt;LegacyRectangle&gt;()) {}

    void draw() override {
        // Adapt legacy drawing method to new interface
        legacyRectangle-&gt;oldDrawMethod(x, y, x + width, y + height);
    }

    void resize(double factor) override {
        width = static_cast&lt;int&gt;(width * factor);
        height = static_cast&lt;int&gt;(height * factor);
    }

private:
    int x, y, width, height;
    std::unique_ptr&lt;LegacyRectangle&gt; legacyRectangle;
};

// Class Adapter (Inheritance-based)
class ClassRectangleAdapter :
    public Shape,
    private LegacyRectangle {
public:
    ClassRectangleAdapter(int x, int y, int width, int height)
        : x(x), y(y), width(width), height(height) {}

    void draw() override {
        // Adapt legacy method using inheritance
        oldDrawMethod(x, y, x + width, y + height);
    }

    void resize(double factor) override {
        width = static_cast&lt;int&gt;(width * factor);
        height = static_cast&lt;int&gt;(height * factor);
    }

private:
    int x, y, width, height;
};

// Functional Adapter (Modern C++ Approach)
class FunctionalAdapter {
public:
    // Adapter that can wrap any callable with different signature
    template&lt;typename Callable, typename... Args&gt;
    class Adapter {
    public:
        Adapter(Callable callable) : callable(callable) {}

        auto operator()(Args... args) {
            // Potential transformation of arguments or return value
            return callable(std::forward&lt;Args&gt;(args)...);
        }

    private:
        Callable callable;
    };

    // Factory method to create adapters
    template&lt;typename Callable, typename... Args&gt;
    static auto adapt(Callable callable) {
        return Adapter&lt;Callable, Args...&gt;(callable);
    }
};

// Interface Adapter with Type Erasure
class DrawingTool {
public:
    virtual void renderShape() = 0;
    virtual ~DrawingTool() = default;
};

class TypeErasedAdapter {
public:
    template&lt;typename T&gt;
    class Adaptor : public DrawingTool {
    public:
        Adaptor(T shape) : shape(std::move(shape)) {}

        void renderShape() override {
            shape.draw();
        }

    private:
        T shape;
    };

    // Factory method for type-erased adaptation
    template&lt;typename T&gt;
    static std::unique_ptr&lt;DrawingTool&gt; adapt(T shape) {
        return std::make_unique&lt;Adaptor&lt;T&gt;&gt;(std::move(shape));
    }
};

// Advanced Multiple Interface Adapter
class MultiInterfaceAdapter {
public:
    // Adaptee with different interface
    class DataProcessor {
    public:
        void processData(const std::vector&lt;int&gt;&amp; data) {
            std::cout &lt;&lt; "Processing data: ";
            for (int val : data) {
                std::cout &lt;&lt; val &lt;&lt; " ";
            }
            std::cout &lt;&lt; std::endl;
        }
    };

    // Adapter supporting multiple interfaces
    class Adapter {
    public:
        void processIntData(const std::vector&lt;int&gt;&amp; data) {
            processor.processData(data);
        }

        void processStringData(const std::vector&lt;std::string&gt;&amp; data) {
            std::vector&lt;int&gt; convertedData;
            for (const auto&amp; str : data) {
                try {
                    convertedData.push_back(std::stoi(str));
                } catch(...) {
                    // Ignore conversion errors
                }
            }
            processor.processData(convertedData);
        }

    private:
        DataProcessor processor;
    };
};

int main() {
    // Object Adapter Demonstration
    {
        std::unique_ptr&lt;Shape&gt; rectangle =
            std::make_unique&lt;RectangleAdapter&gt;(10, 20, 100, 50);

        std::cout &lt;&lt; "Object Adapter:" &lt;&lt; std::endl;
        rectangle-&gt;draw();
        rectangle-&gt;resize(2.0);
        rectangle-&gt;draw();
    }

    // Class Adapter Demonstration
    {
        std::unique_ptr&lt;Shape&gt; classRectangle =
            std::make_unique&lt;ClassRectangleAdapter&gt;(30, 40, 200, 100);

        std::cout &lt;&lt; "\nClass Adapter:" &lt;&lt; std::endl;
        classRectangle-&gt;draw();
        classRectangle-&gt;resize(0.5);
        classRectangle-&gt;draw();
    }

    // Functional Adapter Demonstration
    {
        std::cout &lt;&lt; "\nFunctional Adapter:" &lt;&lt; std::endl;
        auto adaptedFunc = FunctionalAdapter::adapt&lt;
            std::function&lt;int(int, int)&gt;
        &gt;([](int a, int b) { return a + b; });

        std::cout &lt;&lt; "Adapted function result: "
                  &lt;&lt; adaptedFunc(5, 3) &lt;&lt; std::endl;
    }

    // Type Erased Adapter Demonstration
    {
        std::cout &lt;&lt; "\nType Erased Adapter:" &lt;&lt; std::endl;
        auto drawingTool = TypeErasedAdapter::adapt(
            RectangleAdapter(50, 60, 150, 75)
        );
        drawingTool-&gt;renderShape();
    }

    // Multiple Interface Adapter
    {
        std::cout &lt;&lt; "\nMultiple Interface Adapter:" &lt;&lt; std::endl;
        MultiInterfaceAdapter::Adapter adapter;

        // Process integer data
        std::vector&lt;int&gt; intData = {1, 2, 3, 4, 5};
        adapter.processIntData(intData);

        // Process string data
        std::vector&lt;std::string&gt; stringData = {"10", "20", "30"};
        adapter.processStringData(stringData);
    }

    return 0;
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design-command-pattern"><a class="header" href="#design-command-pattern">design command pattern</a></h1>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;functional&gt;
#include &lt;unordered_map&gt;
#include &lt;string&gt;
#include &lt;stdexcept&gt;
#include &lt;chrono&gt;
#include &lt;thread&gt;

// Command Interface
class Command {
public:
    virtual void execute() = 0;
    virtual void undo() = 0;
    virtual ~Command() = default;
};

// Receiver Class (Object that performs the actual work)
class TextEditor {
public:
    void insertText(const std::string&amp; text) {
        content += text;
        std::cout &lt;&lt; "Inserted: " &lt;&lt; text &lt;&lt; std::endl;
    }

    void deleteText(size_t count) {
        if (count &gt; content.length()) {
            count = content.length();
        }
        deletedText = content.substr(content.length() - count);
        content = content.substr(0, content.length() - count);
        std::cout &lt;&lt; "Deleted: " &lt;&lt; deletedText &lt;&lt; std::endl;
    }

    std::string getContent() const {
        return content;
    }

private:
    std::string content;
    std::string deletedText;
};

// Concrete Command for Text Insertion
class InsertTextCommand : public Command {
public:
    InsertTextCommand(TextEditor&amp; editor, const std::string&amp; text)
        : editor(editor), text(text) {}

    void execute() override {
        editor.insertText(text);
    }

    void undo() override {
        editor.deleteText(text.length());
    }

private:
    TextEditor&amp; editor;
    std::string text;
};

// Concrete Command for Text Deletion
class DeleteTextCommand : public Command {
public:
    DeleteTextCommand(TextEditor&amp; editor, size_t count)
        : editor(editor), count(count) {}

    void execute() override {
        editor.deleteText(count);
    }

    void undo() override {
        // We would need to store the deleted text in the actual implementation
        // This is a simplified version
        throw std::runtime_error("Undo not fully implemented");
    }

private:
    TextEditor&amp; editor;
    size_t count;
};

// Command Invoker (Manages command execution and history)
class CommandInvoker {
public:
    void executeCommand(std::unique_ptr&lt;Command&gt; command) {
        command-&gt;execute();
        commandHistory.push(std::move(command));
    }

    void undo() {
        if (!commandHistory.empty()) {
            auto command = std::move(commandHistory.top());
            commandHistory.pop();
            command-&gt;undo();
        }
    }

private:
    std::stack&lt;std::unique_ptr&lt;Command&gt;&gt; commandHistory;
};

// Macro Command (Composite Command)
class MacroCommand : public Command {
public:
    void addCommand(std::unique_ptr&lt;Command&gt; command) {
        commands.push_back(std::move(command));
    }

    void execute() override {
        for (auto&amp; command : commands) {
            command-&gt;execute();
        }
    }

    void undo() override {
        // Undo in reverse order
        for (auto it = commands.rbegin(); it != commands.rend(); ++it) {
            (*it)-&gt;undo();
        }
    }

private:
    std::vector&lt;std::unique_ptr&lt;Command&gt;&gt; commands;
};

// Command Factory
class CommandFactory {
public:
    using CommandCreator = std::function&lt;std::unique_ptr&lt;Command&gt;()&gt;;

    void registerCommand(const std::string&amp; name, CommandCreator creator) {
        commandRegistry[name] = creator;
    }

    std::unique_ptr&lt;Command&gt; createCommand(const std::string&amp; name) {
        auto it = commandRegistry.find(name);
        if (it != commandRegistry.end()) {
            return it-&gt;second();
        }
        throw std::runtime_error("Unknown command");
    }

private:
    std::unordered_map&lt;std::string, CommandCreator&gt; commandRegistry;
};

// Functional Command (Modern C++ Approach)
class FunctionalCommand {
public:
    template&lt;typename Func&gt;
    class Command {
    public:
        Command(Func executeFunc, Func undoFunc)
            : execute(executeFunc), undo(undoFunc) {}

        void operator()() { execute(); }
        void rollback() { undo(); }

    private:
        Func execute;
        Func undo;
    };

    template&lt;typename Func&gt;
    static auto create(Func executeFunc, Func undoFunc) {
        return Command&lt;Func&gt;(executeFunc, undoFunc);
    }
};

// Thread-Safe Command Executor
class ThreadSafeCommandExecutor {
public:
    void enqueueCommand(std::unique_ptr&lt;Command&gt; command) {
        std::lock_guard&lt;std::mutex&gt; lock(mutex);
        commandQueue.push(std::move(command));
    }

    void processCommands() {
        while (true) {
            std::unique_ptr&lt;Command&gt; command;

            {
                std::lock_guard&lt;std::mutex&gt; lock(mutex);
                if (commandQueue.empty()) {
                    break;
                }
                command = std::move(commandQueue.front());
                commandQueue.pop();
            }

            command-&gt;execute();

            // Simulate processing time
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
        }
    }

private:
    std::queue&lt;std::unique_ptr&lt;Command&gt;&gt; commandQueue;
    std::mutex mutex;
};

int main() {
    // Basic Command Pattern Demonstration
    {
        TextEditor editor;
        CommandInvoker invoker;

        // Execute commands
        invoker.executeCommand(
            std::make_unique&lt;InsertTextCommand&gt;(editor, "Hello ")
        );
        invoker.executeCommand(
            std::make_unique&lt;InsertTextCommand&gt;(editor, "World!")
        );

        std::cout &lt;&lt; "Current Content: " &lt;&lt; editor.getContent() &lt;&lt; std::endl;

        // Undo last command
        invoker.undo();
        std::cout &lt;&lt; "After Undo: " &lt;&lt; editor.getContent() &lt;&lt; std::endl;
    }

    // Macro Command Demonstration
    {
        TextEditor editor;
        MacroCommand macroCommand;

        macroCommand.addCommand(
            std::make_unique&lt;InsertTextCommand&gt;(editor, "Hello ")
        );
        macroCommand.addCommand(
            std::make_unique&lt;InsertTextCommand&gt;(editor, "World!")
        );

        macroCommand.execute();
        std::cout &lt;&lt; "Macro Command Content: " &lt;&lt; editor.getContent() &lt;&lt; std::endl;
    }

    // Command Factory Demonstration
    {
        TextEditor editor;
        CommandFactory factory;

        // Register commands
        factory.registerCommand("insert", [&amp;]() {
            return std::make_unique&lt;InsertTextCommand&gt;(editor, "Hello ");
        });

        // Create and execute command
        auto command = factory.createCommand("insert");
        command-&gt;execute();
    }

    // Functional Command Demonstration
    {
        int value = 0;
        auto incrementCmd = FunctionalCommand::create(
            [&amp;]() { value++; },
            [&amp;]() { value--; }
        );

        incrementCmd();
        std::cout &lt;&lt; "Value after increment: " &lt;&lt; value &lt;&lt; std::endl;
    }

    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design-state-pattern"><a class="header" href="#design-state-pattern">design state pattern</a></h1>
<pre><code class="language-c++">
#include &lt;iostream&gt;

enum class State {
    STATE_A,
    STATE_B,
    STATE_C
};

class Context {
public:
    Context() : currentState_(State::STATE_A) {}

    void performAction() {
        switch (currentState_) {
        case State::STATE_A:
            handleStateA();
            break;
        case State::STATE_B:
            handleStateB();
            break;
        case State::STATE_C:
            handleStateC();
            break;
        }
    }

private:
    void handleStateA() {
        std::cout &lt;&lt; "Handling State A. Transitioning to State B." &lt;&lt; std::endl;
        currentState_ = State::STATE_B;
    }

    void handleStateB() {
        std::cout &lt;&lt; "Handling State B. Transitioning to State C." &lt;&lt; std::endl;
        currentState_ = State::STATE_C;
    }

    void handleStateC() {
        std::cout &lt;&lt; "Handling State C. Transitioning to State A." &lt;&lt; std::endl;
        currentState_ = State::STATE_A;
    }

    State currentState_;
};

int main() {
    Context context;

    context.performAction(); // State A -&gt; State B
    context.performAction(); // State B -&gt; State C
    context.performAction(); // State C -&gt; State A
    context.performAction(); // State A -&gt; State B

    return 0;
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design-mediator-pattern"><a class="header" href="#design-mediator-pattern">design mediator pattern</a></h1>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;

class Mediator; // Forward declaration

class Colleague {
public:
    Colleague(Mediator* mediator) : mediator_(mediator) {}
    virtual ~Colleague() = default;
    virtual void receive(const std::string&amp; message) = 0;

protected:
    Mediator* mediator_;
};


class ConcreteColleagueA : public Colleague {
public:
    ConcreteColleagueA(Mediator* mediator) : Colleague(mediator) {}

    void send(const std::string&amp; message) {
        mediator_-&gt;notify(this, message);
    }

    void receive(const std::string&amp; message) override {
        std::cout &lt;&lt; "ConcreteColleagueA received: " &lt;&lt; message &lt;&lt; std::endl;
    }
};

class ConcreteColleagueB : public Colleague {
public:
    ConcreteColleagueB(Mediator* mediator) : Colleague(mediator) {}

    void send(const std::string&amp; message) {
        mediator_-&gt;notify(this, message);
    }

    void receive(const std::string&amp; message) override {
        std::cout &lt;&lt; "ConcreteColleagueB received: " &lt;&lt; message &lt;&lt; std::endl;
    }
};


class Mediator {
public:
    virtual ~Mediator() = default;
    virtual void notify(Colleague* sender, const std::string&amp; message) = 0;
    virtual void addColleague(Colleague* colleague) = 0;
};


class ConcreteMediator : public Mediator {
public:
    void notify(Colleague* sender, const std::string&amp; message) override {
        for (auto colleague : colleagues_) {
            if (colleague != sender) {
                colleague-&gt;receive(message);
            }
        }
    }

    void addColleague(Colleague* colleague) override {
        colleagues_.push_back(colleague);
    }

private:
    std::vector&lt;Colleague*&gt; colleagues_;
};


int main() {
    ConcreteMediator mediator;

    ConcreteColleagueA colleagueA(&amp;mediator);
    ConcreteColleagueB colleagueB(&amp;mediator);

    mediator.addColleague(&amp;colleagueA);
    mediator.addColleague(&amp;colleagueB);

    colleagueA.send("Hello from Colleague A!");
    colleagueB.send("Hi from Colleague B!");

    return 0;
}


</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design-observer-pattern"><a class="header" href="#design-observer-pattern">design observer pattern</a></h1>
<pre><code class="language-c++">

#include &lt;iostream&gt;
#include &lt;vector&gt;

class Observer; // Forward declaration

class Subject {
public:
    virtual ~Subject() = default;
    virtual void attach(Observer* observer) = 0;
    virtual void detach(Observer* observer) = 0;
    virtual void notify() = 0;
};


class ConcreteSubject : public Subject {
public:
    void attach(Observer* observer) override {
        observers_.push_back(observer);
    }

    void detach(Observer* observer) override {
        observers_.erase(std::remove(observers_.begin(), observers_.end(), observer), observers_.end());
    }

    void notify() override {
        for (Observer* observer : observers_) {
            observer-&gt;update(this);
        }
    }

    void setState(int state) {
        state_ = state;
        notify();
    }

    int getState() const {
        return state_;
    }

private:
    std::vector&lt;Observer*&gt; observers_;
    int state_;
};

class Observer {
public:
    virtual ~Observer() = default;
    virtual void update(Subject* subject) = 0;
};

class ConcreteObserverA : public Observer {
public:
    void update(Subject* subject) override {
        ConcreteSubject* concreteSubject = dynamic_cast&lt;ConcreteSubject*&gt;(subject);
        if (concreteSubject) {
            std::cout &lt;&lt; "ConcreteObserverA received update. New state: " &lt;&lt; concreteSubject-&gt;getState() &lt;&lt; std::endl;
        }
    }
};

class ConcreteObserverB : public Observer {
public:
    void update(Subject* subject) override {
        ConcreteSubject* concreteSubject = dynamic_cast&lt;ConcreteSubject*&gt;(subject);
        if (concreteSubject) {
            std::cout &lt;&lt; "ConcreteObserverB received update. New state: " &lt;&lt; concreteSubject-&gt;getState() &lt;&lt; std::endl;
        }
    }
};

#include &lt;algorithm&gt;

int main() {
    ConcreteSubject subject;
    ConcreteObserverA observerA;
    ConcreteObserverB observerB;

    subject.attach(&amp;observerA);
    subject.attach(&amp;observerB);

    subject.setState(10);
    subject.setState(20);

    subject.detach(&amp;observerA);
    subject.setState(30);

    return 0;
}


</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design-strategy-pattern"><a class="header" href="#design-strategy-pattern">design strategy pattern</a></h1>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;memory&gt;

class Strategy {
public:
    virtual ~Strategy() = default;
    virtual void execute() const = 0;
};


class ConcreteStrategyA : public Strategy {
public:
    void execute() const override {
        std::cout &lt;&lt; "Executing Strategy A." &lt;&lt; std::endl;
    }
};

class ConcreteStrategyB : public Strategy {
public:
    void execute() const override {
        std::cout &lt;&lt; "Executing Strategy B." &lt;&lt; std::endl;
    }
};

class ConcreteStrategyC : public Strategy {
public:
    void execute() const override {
        std::cout &lt;&lt; "Executing Strategy C." &lt;&lt; std::endl;
    }
};

class Context {
public:
    Context(std::unique_ptr&lt;Strategy&gt; strategy) : strategy_(std::move(strategy)) {}

    void setStrategy(std::unique_ptr&lt;Strategy&gt; strategy) {
        strategy_ = std::move(strategy);
    }

    void performAction() const {
        strategy_-&gt;execute();
    }

private:
    std::unique_ptr&lt;Strategy&gt; strategy_;
};


int main() {
    Context context(std::make_unique&lt;ConcreteStrategyA&gt;()); // Initial strategy

    context.performAction(); // Executes Strategy A

    context.setStrategy(std::make_unique&lt;ConcreteStrategyB&gt;());
    context.performAction(); // Executes Strategy B

    context.setStrategy(std::make_unique&lt;ConcreteStrategyC&gt;());
    context.performAction(); // Executes Strategy C

    return 0;
}


</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design-archive-pattern"><a class="header" href="#design-archive-pattern">design archive pattern</a></h1>
<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;fstream&gt;
#include &lt;sstream&gt;

class Archive {
public:
    virtual ~Archive() = default;

    virtual void saveInt(int value) = 0;
    virtual void loadInt(int&amp; value) = 0;

    virtual void saveString(const std::string&amp; value) = 0;
    virtual void loadString(std::string&amp; value) = 0;

    // Add other save/load methods for different data types as needed
};


class TextArchive : public Archive {
public:
    TextArchive(std::ostream&amp; os) : os_(os) {}
    TextArchive(std::istream&amp; is) : is_(is) {}

    void saveInt(int value) override { os_ &lt;&lt; value &lt;&lt; " "; }
    void loadInt(int&amp; value) override { is_ &gt;&gt; value; }

    void saveString(const std::string&amp; value) override { os_ &lt;&lt; value &lt;&lt; " "; }
    void loadString(std::string&amp; value) override { is_ &gt;&gt; value; }

private:
    std::ostream&amp; os_;
    std::istream&amp; is_;
};

class BinaryArchive : public Archive {
public:
    BinaryArchive(std::ostream&amp; os) : os_(os) {}
    BinaryArchive(std::istream&amp; is) : is_(is) {}

    void saveInt(int value) override { os_.write(reinterpret_cast&lt;const char*&gt;(&amp;value), sizeof(value)); }
    void loadInt(int&amp; value) override { is_.read(reinterpret_cast&lt;char*&gt;(&amp;value), sizeof(value)); }

    void saveString(const std::string&amp; value) override {
        size_t size = value.size();
        os_.write(reinterpret_cast&lt;const char*&gt;(&amp;size), sizeof(size));
        os_.write(value.c_str(), size);
    }
    void loadString(std::string&amp; value) override {
        size_t size;
        is_.read(reinterpret_cast&lt;char*&gt;(&amp;size), sizeof(size));
        value.resize(size);
        is_.read(&amp;value[0], size);
    }

private:
    std::ostream&amp; os_;
    std::istream&amp; is_;
};

class MyData {
public:
    MyData() = default;
    MyData(int id, const std::string&amp; name) : id_(id), name_(name) {}

    void save(Archive&amp; archive) const {
        archive.saveInt(id_);
        archive.saveString(name_);
    }

    void load(Archive&amp; archive) {
        archive.loadInt(id_);
        archive.loadString(name_);
    }

    void display() const {
        std::cout &lt;&lt; "ID: " &lt;&lt; id_ &lt;&lt; ", Name: " &lt;&lt; name_ &lt;&lt; std::endl;
    }

private:
    int id_;
    std::string name_;
};

int main() {
    MyData data1(123, "Example");

    // Save to text archive
    std::ofstream textOut("data.txt");
    TextArchive textArchiveOut(textOut);
    data1.save(textArchiveOut);
    textOut.close();

    // Load from text archive
    std::ifstream textIn("data.txt");
    TextArchive textArchiveIn(textIn);
    MyData data2;
    data2.load(textArchiveIn);
    textIn.close();
    data2.display();

    // Save to binary archive
    std::ofstream binaryOut("data.bin", std::ios::binary);
    BinaryArchive binaryArchiveOut(binaryOut);
    data1.save(binaryArchiveOut);
    binaryOut.close();

    // Load from binary archive
    std::ifstream binaryIn("data.bin", std::ios::binary);
    BinaryArchive binaryArchiveIn(binaryIn);
    MyData data3;
    data3.load(binaryArchiveIn);
    binaryIn.close();
    data3.display();

    return 0;
}

</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
